{"meta":{"title":"xiaofan'blog","subtitle":"","description":"","author":"小凡","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2018-09-30T09:25:30.000Z","updated":"2020-02-28T05:01:29.418Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"留言板","date":"2018-09-30T09:25:30.000Z","updated":"2020-02-28T05:01:09.442Z","comments":true,"path":"contact/index.html","permalink":"http://yoursite.com/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"分类","date":"2018-09-30T09:25:30.000Z","updated":"2020-02-28T05:01:22.799Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"友情链接","date":"2018-12-12T13:25:30.000Z","updated":"2020-06-25T09:35:09.827Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"标签","date":"2018-09-30T10:23:38.000Z","updated":"2020-02-28T05:00:38.845Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"HDU - 6774 String Distance","slug":"hdu6774","date":"2020-08-02T08:31:31.000Z","updated":"2020-08-02T08:37:08.223Z","comments":true,"path":"2020/08/02/hdu6774/","link":"","permalink":"http://yoursite.com/2020/08/02/hdu6774/","excerpt":"","text":"传送门：HDU - 6774 思路分析实际上就是求询问串和$t$串的$lcs$如果按照普通的求$lcs$的方法，肯定是不行的$dp[i][j]$表示在t串的长度为$i$的前缀里，匹配到长度为$j$的$lcs$的最小右端点可以通过序列自动机预处理来优化匹配的过程，这样匹配的复杂度是$O(m*m)$的 AC代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e5+10; int nex[N][30],dp[30][30]; char s[N],t[N]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int T; cin>>T; while(T--) { cin>>s+1; cin>>t+1; int n=strlen(s+1); int m=strlen(t+1); for(int j=0; j&lt;26; j++) { nex[n][j]=n+1; } nex[n][s[n]-'a']=n; for(int i=n-1; i>=1; i--) { for(int j=0; j&lt;26; j++) { nex[i][j]=nex[i+1][j]; } nex[i][s[i]-'a'] = i; } int q; cin>>q; while(q--){ int l,r; cin>>l>>r; mem(dp,INF); for(int i=1;i&lt;=m;i++) dp[i][1]=nex[l][t[i]-'a']; for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=i;j++){ if(dp[i-1][j]&lt;=r) dp[i][j]=min(dp[i][j],dp[i-1][j]); if(dp[i-1][j-1]&lt;r) dp[i][j]=min(dp[i][j],nex[dp[i-1][j-1]+1][t[i]-'a']); } } int ma=0; dp[m][0]=0; for(int i=m;i>=0;i--){ if(dp[m][i]&lt;=r) { ma=i; break; } } int del=r-l+1-ma; int add=m-ma; cout&lt;&lt;del+add&lt;&lt;endl; } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"序列自动机","slug":"序列自动机","permalink":"http://yoursite.com/tags/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"author":"小凡"},{"title":"HDU - 6763 Total Eclipse","slug":"hdu6763","date":"2020-08-02T08:21:10.000Z","updated":"2020-08-02T08:26:36.233Z","comments":true,"path":"2020/08/02/hdu6763/","link":"","permalink":"http://yoursite.com/2020/08/02/hdu6763/","excerpt":"","text":"传送门：HDU - 6763 思路分析从小到大复杂度太高了，考虑从大到小考虑，每遇到一个点，就加上这个点的贡献，然后遍历他的邻边，如果存在之前已经访问过的点，并且不在同一个集合，那么减去这个点的贡献 AC代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e6+10; int f[N],vis[N]; struct node{ int id,w; }a[N]; vector&lt;int>e[N]; int find(int x){ return x==f[x]?x:f[x]=find(f[x]); } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; read(t); while(t--){ int n,m; read(n,m); for(int i=1;i&lt;=n;i++) { f[i]=i; vis[i]=0; e[i].clear(); read(a[i].w); a[i].id=i; } while(m--){ int u,v; read(u,v); e[u].pb(v); e[v].pb(u); } sort(a+1,a+1+n,[](node x,node y){ return x.w>y.w; }); ll ans=0; for(int i=1;i&lt;=n;i++){ int u=a[i].id; ans+=a[i].w; vis[u]=1; for(auto v:e[u]){ if(vis[v]){ int fv=find(v); if(u!=fv){ f[fv]=u; ans-=a[i].w; } } } } printf(\"%lld\\n\",ans); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}],"author":"小凡"},{"title":"HDU - 6767 New Equipments","slug":"hdu6767","date":"2020-08-02T07:15:08.000Z","updated":"2020-08-02T07:18:21.094Z","comments":true,"path":"2020/08/02/hdu6767/","link":"","permalink":"http://yoursite.com/2020/08/02/hdu6767/","excerpt":"","text":"传送门：HDU - 6767 思路分析实际上只需要找对每个点贡献最小的n个设备就行了，因为是二次函数形式，所以找对称轴附近的n个点就行了，每次spfa得到的就是答案 AC代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); #define int long long const int INF = 0x3f3f3f3f; const int N=3e4+10; const int M=1e6+10; struct node { int v,flow,w,next; } e[M]; int head[N],cnt; int n,m,s,t,k,maxflow,mincost,path[N],pre[N]; int dis[N],vis[N]; map&lt;int,int>MP; int tot; inline void ade(int u,int v,int f,int w) { e[++cnt].v=v; e[cnt].flow=f; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt; } inline void add(int u,int v,int f,int w) { ade(u,v,f,w); ade(v,u,0,-w); } inline bool spfa() { mem(dis,INF); mem(vis,0); mem(pre,-1); dis[s]=0; vis[s]=1; queue&lt;int>q; q.push(s); while(!q.empty()) { int u=q.front(); vis[u]=0; q.pop(); for(int i=head[u]; i; i=e[i].next) { int v=e[i].v; int w=e[i].w; if(e[i].flow &amp;&amp; dis[v]>dis[u]+w) { dis[v]=dis[u]+w; pre[v]=u; path[v]=i; if(!vis[v]) { q.push(v); vis[v]=1; } } } } return pre[t]!=-1; } vector&lt;int>ans; inline void EK() { while(spfa()) { int mi=INF; for(int i=t; i!=s; i=pre[i]) mi=min(mi,e[path[i]].flow); for(int i=t; i!=s; i=pre[i]) { e[path[i]].flow-=mi; e[path[i]^1].flow+=mi; } maxflow+=mi; mincost+=dis[t]*mi; ans.pb(mincost); } } inline get(int x){ if(!MP[x]) MP[x]=++tot; return MP[x]; } signed main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int T; read(T); while(T--){ read(n,m); cnt=1; tot=n+1; mem(head,0); MP.clear(); s=N-1; t=N-2; mincost = maxflow = 0; for(int i=1;i&lt;=n;i++){ int a,b,c; read(a,b,c); int mid = (-b)/(2*a); int now=max(mid-n-2,1LL); for(int j=1;j&lt;=2*n+2;j++){ int x=now+j-1; add(i,get(x),1,a*x*x+b*x+c); } add(s,i,1,0); } ans.clear(); for(auto i:MP) add(i.se,t,1,0); EK(); for(int i=0;i&lt;n;i++) printf(\"%lld%c\",ans[i],i==n-1?'\\n':' '); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"费用流","slug":"费用流","permalink":"http://yoursite.com/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"}],"author":"小凡"},{"title":"牛客 - All with Pairs","slug":"nk5667a","date":"2020-08-01T16:01:18.000Z","updated":"2020-08-01T16:06:51.463Z","comments":true,"path":"2020/08/02/nk5667a/","link":"","permalink":"http://yoursite.com/2020/08/02/nk5667a/","excerpt":"","text":"传送门：牛客 - All with Pairs 思路分析先把每一个后缀的hash值存起来，然后枚举$s[i]$的每一个前缀，记录有多少个后缀能够匹配，但是不能直接计算贡献，因为同一个字符串可能匹配到多个前缀，所以要进行去重比如 $aba$就会同时计算$a$和$aba$，实际上只取最长的那个，可以通过next数组进行去重，$cnt[next[i]]-=cnt[i]$ AC代码 #include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e6+10; const int P = 998244353; const ll base = 1331; typedef unsigned long long ull; int nex[N]; map&lt;ull,int>cnt; ll sum[N]; string s[N]; void ins(string x) { ull hash=0,ba=1; int len=sz(x); for(int i=len-1; i>=0; i--) { hash=x[i]*ba + hash; ba=ba*base; cnt[hash]++; } } void getnext(string x) { int j=nex[0]=-1; int len=sz(x); for(int i=1; i&lt;len; i++) { while(j>-1 &amp;&amp; x[i]!=x[j+1]) j=nex[j]; if(x[i]==x[j+1]) j++; nex[i]=j; } } signed main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=1; i&lt;=n; i++) { cin>>s[i]; ins(s[i]); } ll ans=0; for(int i=1; i&lt;=n; i++) { getnext(s[i]); ull hash=0; int len=s[i].size(); for(int j=0; j&lt;len; j++) { hash=hash*base+s[i][j]; sum[j]=cnt[hash]; } for(int j=0; j&lt;len; j++) { if(nex[j]==-1) continue; sum[nex[j]]-=sum[j]; } for(int j=0; j&lt;len; j++) ans=(ans + 1LL*sum[j]*(j+1)*(j+1)%P) %P; } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"},{"name":"kmp","slug":"kmp","permalink":"http://yoursite.com/tags/kmp/"}],"author":"小凡"},{"title":"洛谷 - P3375 KMP字符串匹配","slug":"luogu3375","date":"2020-08-01T14:24:33.000Z","updated":"2020-08-01T14:26:01.158Z","comments":true,"path":"2020/08/01/luogu3375/","link":"","permalink":"http://yoursite.com/2020/08/01/luogu3375/","excerpt":"","text":"传送门：洛谷 - P3375 思路分析kmp模板 AC代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e6+10; char s[N],t[N]; int lens,lent; int nex[N]; void getnext(){ int j=0; nex[j]=0; for(int i=2;i&lt;=lent;i++){ while(j &amp;&amp; t[i]!=t[j+1]) j=nex[j]; if(t[i]==t[j+1]) j++; nex[i]=j; } } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>s+1; cin>>t+1; lens=strlen(s+1); lent=strlen(t+1); getnext(); for(int i=1,j=0;i&lt;=lens;i++){ while(j &amp;&amp; s[i]!=t[j+1]) j=nex[j]; if(s[i]==t[j+1]) j++; if(j==lent){ j=nex[j]; cout&lt;&lt;i-lent+1&lt;&lt;endl; } } for(int i=1;i&lt;=lent;i++) cout&lt;&lt;nex[i]&lt;&lt;\" \"; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"kmp","slug":"kmp","permalink":"http://yoursite.com/tags/kmp/"}],"author":"小凡"},{"title":"HDU - 6804 Contest of Rope Pulling","slug":"hdu6804","date":"2020-08-01T13:58:41.000Z","updated":"2020-08-01T14:01:34.816Z","comments":true,"path":"2020/08/01/hdu6804/","link":"","permalink":"http://yoursite.com/2020/08/01/hdu6804/","excerpt":"","text":"传送门：HDU - 6804 思路分析将B组的重量改为相反数，问题就转化为01背包问题，答案是重量为0的最大价值因为值域可能会很大，考虑将数组随机，值域就会减小 AC代码#pragma GCC optimize(\"Ofast,no-stack-protector\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\") #include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int base=1e6; const int ch=150000; ll dp[base+ch*3]; struct node{ int w,v; }a[3000]; #define re register int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int T; read(T); while(T--){ int n,m; read(n,m); for(re int i=1;i&lt;=n+m;++i){ read(a[i].v,a[i].w); if(i>n) a[i].v=-a[i].v; } n+=m; for(re int i=base-ch;i&lt;=base+ch;++i) dp[i]=-1e18; random_shuffle(a+1,a+1+n); random_shuffle(a+1,a+1+n); dp[base]=0; for(re int i=1;i&lt;=n;i++){ if(a[i].v>=0){ for(int j=base+ch;j>=base-ch+a[i].v;j--) dp[j]=max(dp[j],dp[j-a[i].v]+a[i].w); }else{ for(int j=base-ch;j&lt;=base+ch-a[i].v;j++) dp[j]=max(dp[j],dp[j-a[i].v]+a[i].w); } } printf(\"%lld\\n\",dp[base]); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"背包DP","slug":"背包DP","permalink":"http://yoursite.com/tags/%E8%83%8C%E5%8C%85DP/"}],"author":"小凡"},{"title":"HDU - 6797 Tokitsukaze and Rescue","slug":"hdu6797","date":"2020-07-29T07:26:38.000Z","updated":"2020-07-29T07:28:56.115Z","comments":true,"path":"2020/07/29/hdu6797/","link":"","permalink":"http://yoursite.com/2020/07/29/hdu6797/","excerpt":"","text":"传送门：HDU - 6797 思路分析因为边权随机，所以最短路的边很少，直接爆搜就行了，注意pre数组一定不要开全局 AC代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; int n,k,ans; int e[55][55],dis[55],vis[55]; void spfa(int pre[]){ mem(dis,INF); mem(vis,0); mem(pre,0); dis[1]=0; queue&lt;int>q; q.push(1); while(!q.empty()) { int u=q.front(); q.pop(); vis[u]=0; for(int v=1; v&lt;=n; v++) { int w=e[u][v]; if(dis[v]>dis[u]+w) { dis[v]=dis[u]+w; pre[v]=u; if(!vis[v]) { q.push(v); vis[v]=1; } } } } } void dfs(int x) { int pre[55]; if(x==k+1) { spfa(pre); ans=max(ans,dis[n]); return ; } spfa(pre); int u=pre[n]; int v=n; while(u) { int w=e[u][v]; e[u][v]=e[v][u]=INF; dfs(x+1); e[u][v]=e[v][u]=w; v=u; u=pre[v]; } } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int T; read(T); mem(e,INF); while(T--) { read(n,k); ans=0; int m=(n-1)*n/2; while(m--) { int u,v,w; read(u,v,w); e[u][v]=e[v][u]=w; } dfs(1); printf(\"%d\\n\",ans); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}],"author":"小凡"},{"title":"2020牛客多校第六场 - H Harmony Pairs","slug":"nk5671h","date":"2020-07-28T12:18:32.000Z","updated":"2020-07-28T12:22:08.703Z","comments":true,"path":"2020/07/28/nk5671h/","link":"","permalink":"http://yoursite.com/2020/07/28/nk5671h/","excerpt":"","text":"传送门：2020牛客多校第六场 - H Harmony Pairs 思路分析$dp[pos][sum][lima][limb]$ 表示搜索到第$pos$位，差为$sum$，$a$，$b$有无限制的方案数$sum$初始值1000防止负数溢出 AC代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int mod = 1e9+7; ll dp[1111][2222][2][2]; char s[1111]; ll dfs(int pos,int sum,int lima,int limb) { if(s[pos]=='\\0') { return (sum>1000); } if(dp[pos][sum][lima][limb] !=-1) return dp[pos][sum][lima][limb]; ll ans=0; int upb=limb?s[pos]-'0':9; for(int i=0; i&lt;=upb; i++) { int upa=lima?i:9; for(int j=0; j&lt;=upa; j++) { ans=(ans + dfs(pos+1,sum+j-i,lima&amp;&amp;j==i,limb&amp;&amp;i==upb))%mod; } } return dp[pos][sum][lima][limb]=ans; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif mem(dp,-1); scanf(\"%s\",s+1); printf(\"%lld\\n\",dfs(1,1000,1,1)); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数位DP","slug":"数位DP","permalink":"http://yoursite.com/tags/%E6%95%B0%E4%BD%8DDP/"}],"author":"小凡"},{"title":"HDU - 6756 Finding a MEX","slug":"hdu6756","date":"2020-07-22T09:59:04.000Z","updated":"2020-07-22T10:04:45.509Z","comments":true,"path":"2020/07/22/hdu6756/","link":"","permalink":"http://yoursite.com/2020/07/22/hdu6756/","excerpt":"","text":"传送门：HDU - 6756 思路分析对度数进行分块，度数大于根号$\\sqrt{n}$的点用树状数组求mex，小于的暴力 AC代码 #include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e5+10; int w[N],a[N],b[N],in[N],vis[N]; vector&lt;int>e[N],g[N],bit[N],live[N]; void add(int id,int x,int k){ if(x==0){ bit[id][0]+=k; return ; } for(int i=x;i&lt;=in[id];i+=lowbit(i)) bit[id][i]+=k; } int get(int id,int x){ int ans=0; for(int i=x;i;i-=lowbit(i)) ans+=bit[id][i]; return ans; } int cal(int x) { for(int i=0;i&lt;=in[x];i++) vis[i]=0; for(int v:e[x]) { if(w[v]&lt;=in[v]) vis[w[v]]=1; } for(int i=0;i&lt;=in[x];i++) if(!vis[i]) return i; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int T; read(T); while(T--) { int n,m; read(n,m); int M = sqrt(n); for(int i=1; i&lt;=n; i++) { read(w[i]); e[i].clear(); in[i]=0; g[i].clear(); } for(int i=1; i&lt;=m; i++) { read(a[i],b[i]); int u=a[i]; int v=b[i]; e[u].pb(v); e[v].pb(u); in[u]++; in[v]++; } for(int i=1; i&lt;=n; i++) { if(in[i]>M){ bit[i].resize(in[i]+2); live[i].resize(in[i]+2); for(int j=0;j&lt;in[i]+2;j++) bit[i][j]=live[i][j]=0; for(auto v:e[i]){ if(w[v]&lt;=in[i]){ live[i][w[v]]++; if(live[i][w[v]]==1) add(i,w[v],1); } } } for(auto v:e[i]) if(in[v]>M) g[i].pb(v); } int q; read(q); for(int i=1; i&lt;=q; i++) { int op,x,y; read(op,x); if(op==1) { read(y); if(w[x]==y) continue; for(auto v:g[x]){ if(w[x]&lt;=in[v]){ live[v][w[x]]--; if(live[v][w[x]]==0) add(v,w[x],-1); } if(y&lt;=in[v]){ live[v][y]++; if(live[v][y]==1) add(v,y,1); } } w[x]=y; } else { if(in[x]>M){ if(!bit[x][0]) { puts(\"0\"); continue; } int l=1,r=in[x]; int ans=-1; while(r>=l){ int mid=l+r>>1; if(get(x,mid)&lt;mid){ r=mid-1; ans=mid; }else{ l=mid+1; } } printf(\"%d\\n\",ans); }else { printf(\"%d\\n\",cal(x)); } } } for(int i=1;i&lt;=n;i++) { if(in[i]>M){ bit[i].clear(); live[i].clear(); } } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"分块","slug":"分块","permalink":"http://yoursite.com/tags/%E5%88%86%E5%9D%97/"}],"author":"小凡"},{"title":"牛客 - Greater and Greater","slug":"nk5667G","date":"2020-07-14T08:59:35.000Z","updated":"2020-07-14T09:06:13.595Z","comments":true,"path":"2020/07/14/nk5667G/","link":"","permalink":"http://yoursite.com/2020/07/14/nk5667G/","excerpt":"","text":"传送门：牛客 - Greater and Greater 思路分析开两个$biset$，$ans$用来维护那一位可以作为子段的开头，tmp维护$A$中哪些可以对应当前$B_i$由$tmp$可以推出目前哪些位置可以作为子段的开头（$tmp&gt;&gt;B_i-&gt;pos$）可以将数组从大到小排序，这样每次$tmp$就可以直接继承之前的了 AC代码 #include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 150010; bitset&lt;N>ans,tmp; pair&lt;int,int>a[N],b[N]; int cmp(pair&lt;int,int>x,pair&lt;int,int>y){ return x.fi>y.fi; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,m; cin>>n>>m; for(int i=1;i&lt;=n;i++){ cin>>a[i].fi; a[i].se=i; } for(int i=1;i&lt;=m;i++){ cin>>b[i].fi; b[i].se=i; } sort(a+1,a+1+n,cmp); sort(b+1,b+1+n,cmp); ans.set(); tmp.reset(); for(int i=1,j=1;i&lt;=m;i++){ while(j&lt;=n &amp;&amp; a[j].fi>=b[i].fi){ tmp.set(a[j].se); j++; } ans &amp;= tmp>>b[i].se; } cout&lt;&lt;ans.count()&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"bitset","slug":"bitset","permalink":"http://yoursite.com/tags/bitset/"}],"author":"小凡"},{"title":"牛客 - Minimum-cost Flow","slug":"nk209437","date":"2020-07-14T05:56:47.000Z","updated":"2020-07-14T06:00:32.248Z","comments":true,"path":"2020/07/14/nk209437/","link":"","permalink":"http://yoursite.com/2020/07/14/nk209437/","excerpt":"","text":"传送门：牛客 - Minimum-cost 思路分析先求出容量为1的时候的最小费用最大流，记录每一次增广路的权值，对于询问只需要看需要几条增广路，前缀和处理一下就行了 AC代码 #include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 55; const int M = 333; #define int long long struct node { int v,flow,w,next; } e[M]; int head[N],cnt; int n,m,s,t,k,maxflow,mincost,path[N],pre[N]; int dis[N],vis[N],ss[333]; vector&lt;int>ans; inline void ade(int u,int v,int f,int w) { e[++cnt].v=v; e[cnt].flow=f; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt; } inline void add(int u,int v,int f,int w) { ade(u,v,f,w); ade(v,u,0,-w); } inline bool spfa() { mem(dis,INF); mem(vis,0); mem(pre,-1); dis[s]=0; vis[s]=1; queue&lt;int>q; q.push(s); while(!q.empty()) { int u=q.front(); vis[u]=0; q.pop(); for(int i=head[u]; i; i=e[i].next) { int v=e[i].v; int w=e[i].w; if(e[i].flow &amp;&amp; dis[v]>dis[u]+w) { dis[v]=dis[u]+w; pre[v]=u; path[v]=i; if(!vis[v]) { q.push(v); vis[v]=1; } } } } return pre[t]!=-1; } inline void EK() { while(spfa()) { ans.pb(dis[t]); int mi=INF; for(int i=t; i!=s; i=pre[i]) mi=min(mi,e[path[i]].flow); for(int i=t; i!=s; i=pre[i]) { e[path[i]].flow-=mi; e[path[i]^1].flow+=mi; } maxflow+=mi; mincost+=dis[t]*mi; } } signed main() { while(read(n,m)){ s=1,t=n; mem(head,0); cnt=1; ans.clear(); for(int i=1;i&lt;=m;i++){ int u,v,w; read(u,v,w); add(u,v,1,w); } EK(); int q; read(q); int len=sz(ans); for(int i=0;i&lt;len;i++) ss[i+1]=ss[i]+ans[i]; while(q--){ int u,v; read(u,v); if(u*len&lt;v) { puts(\"NaN\"); continue; } int k=v/u; int w=ss[k]; int z=v-k*u; w=w*u+ans[k]*z; int g=__gcd(w,v); printf(\"%lld/%lld\\n\",w/g,v/g); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"费用流","slug":"费用流","permalink":"http://yoursite.com/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"}],"author":"小凡"},{"title":"牛客 - Fake Maxpooling （二维单调队列）","slug":"nk207140","date":"2020-07-13T10:51:23.000Z","updated":"2020-07-13T10:55:03.645Z","comments":true,"path":"2020/07/13/nk207140/","link":"","permalink":"http://yoursite.com/2020/07/13/nk207140/","excerpt":"","text":"传送门：牛客 - Fake Maxpooling 思路分析先将每一行每k个数的最大值用单调队列求出来，然后再求每一个长度为k往下k列的最大值，也可以用单调队列实现 AC代码 #include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 5050; int a[N][N]; vector&lt;int>v[N]; pair&lt;int,int>que[N]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,m,k; cin>>n>>m>>k; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ if(!a[i][j]) a[i][j]=a[j][i]=i*j/__gcd(i,j); } } ll ans=0; int l,r; for(int i=1;i&lt;=n;i++){ l=1,r=1; que[l]=mp(0,0); for(int j=1;j&lt;=m;j++){ while(r>=l &amp;&amp; que[r].fi &lt; a[i][j]) r--; r++; que[r]=mp(a[i][j],j); while(r>=l &amp;&amp; que[l].se + k -1 &lt; j) l++; if(j>=k) v[i].pb(que[l].fi); } } for(int j=0;j&lt;m-k+1;j++){ l=1,r=1; que[l]=mp(0,0); for(int i=1;i&lt;=n;i++){ while(r>=l &amp;&amp; que[r].fi &lt; v[i][j]) r--; r++; que[r]=mp(v[i][j],i); while(r>=l &amp;&amp; que[l].se + k -1 &lt;i) l++; if(i>=k) ans+=que[l].fi; } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"单调队列","slug":"单调队列","permalink":"http://yoursite.com/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"}],"author":"小凡"},{"title":"Poweroj - 2883 病毒侵染 （标记割边）","slug":"power2883","date":"2020-07-12T08:00:58.000Z","updated":"2020-07-12T08:03:49.475Z","comments":true,"path":"2020/07/12/power2883/","link":"","permalink":"http://yoursite.com/2020/07/12/power2883/","excerpt":"","text":"传送门：Poweroj - 2883 思路分析答案是乘积形式，可以转换为对数，就变成了普通的网络流了，最后找割边计算答案就行了 AC代码 #include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1005,M=100005; const ll mod=1e9+7; struct node { double w; int u,v,cost,next; } e[M]; int head[N],dep[N],cnt=1,vis[N]; int n,m; void add(int u,int v,double w,int cost) { e[++cnt].v=v; e[cnt].w=w; e[cnt].u=u; e[cnt].next=head[u]; e[cnt].cost=cost; head[u]=cnt; } bool bfs(int s,int t) { queue&lt;int>q; mem(dep,0); dep[s]=1; q.push(s); while(!q.empty()) { int u=q.front(); q.pop(); for(int i=head[u]; i ; i=e[i].next) { int v=e[i].v; double w=e[i].w; if(w>0 &amp;&amp; !dep[v]) { dep[v]=dep[u]+1; q.push(v); } } } return dep[t]; } double dfs(int u,double f,int t) { double fl=0; if(u==t) return f; for(int i=head[u]; i &amp;&amp; f ; i=e[i].next) { int v=e[i].v; if(dep[v]==dep[u]+1 &amp;&amp; e[i].w) { double nx=dfs(v,min(f,e[i].w),t); e[i].w-=nx; e[i^1].w+=nx; f-=nx; fl+=nx; } } if(!fl) dep[u]=-2; return fl; } double dinic(int s,int t) { double ans=0; while(bfs(s,t)) ans+=dfs(s,1000000000,t); return ans; } void DFS(int u){ vis[u]=1; for(int i=head[u];i;i=e[i].next){ int v=e[i].v; double w=e[i].w; if(!vis[v] &amp;&amp; w) DFS(v); } } int main() { cnt=1; mem(head,0); read(n,m); for(int i=0; i&lt;m; i++) { int u,v,cost; read(u,v,cost); double w=log2(cost); add(u,v,w,cost); add(v,u,w,cost); } double s=dinic(1,n); ll ans=1; int flag=0; DFS(1); for(int i=2;i&lt;=cnt;i+=2){ int u=e[i].u; int v=e[i].v; if(vis[u]+vis[v]==1) { flag=1; ans=ans*e[i].cost%mod; } } if(!flag) ans=0; cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"author":"小凡"},{"title":"牛客 - 骚区间","slug":"nk205352","date":"2020-06-27T07:18:55.000Z","updated":"2020-06-27T07:42:29.161Z","comments":true,"path":"2020/06/27/nk205352/","link":"","permalink":"http://yoursite.com/2020/06/27/nk205352/","excerpt":"","text":"传送门：牛客 - 骚区间 思路分析预处理出每个点为左端点的右端点区间，这个区间是它右边第一个和第二个大于它的中间部分，可以通过set进行二分，右端点同理论然后枚举每个点为右端点，在树状数组中有多少点的右端点可以是这个点，一个$[L,R]$区间，在枚举到L时候加入到树状数组中，R的时候删除 AC代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e6+10; int a[N],pos[N],bit[N],ql[N],qr[N]; void add(int x,int k){ for(int i=x;i&lt;N;i+=lowbit(i)) bit[i]+=k; } ll get(int x){ ll ans=0; for(int i=x;i;i-=lowbit(i)) ans+=bit[i]; return ans; } ll query(int l,int r){ return get(r)-get(l-1); } vector&lt;int>ins[N],del[N]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=1;i&lt;=n;i++){ cin>>a[i]; pos[a[i]]=i; } set&lt;int>s; for(int i=1;i&lt;=n;i++){ int now=pos[i]; auto x=s.upper_bound(now); s.insert(now); if(x==s.end()) continue; ins[*x].pb(now); ++x; if(x!=s.end()) del[(*x)-1].pb(now); } s.clear(); for(int i=n;i>=1;i--){ int now=pos[i]; auto x=s.upper_bound(-now); s.insert(-now); if(x==s.end()) continue; qr[now]=-(*x); ++x; if(x==s.end()) ql[now]=1; else ql[now]=-(*x)+1; } ll ans=0; for(int i=1;i&lt;=n;i++){ for(auto x:ins[i]) add(x,1); if(ql[i] &amp;&amp; qr[i]) ans+=query(ql[i],qr[i]); for(auto x:del[i]) add(x,-1); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"},{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}],"author":"小凡"},{"title":"CodeForces-960E Alternating Tree","slug":"CF960E","date":"2020-06-23T05:38:27.000Z","updated":"2020-06-23T05:47:29.642Z","comments":true,"path":"2020/06/23/CF960E/","link":"","permalink":"http://yoursite.com/2020/06/23/CF960E/","excerpt":"","text":"传送门：CodeForces-960E 思路分析考虑进行树DP，显然偶数路径的总权值是0，因为来回抵消了，所以统计答案的时候只需要计算奇数路径$siz[u][0/1]$记录u的子树中，以u结尾的偶/奇路径个数$dis[u][0/1]$记录u的子树中，以u结尾的偶/奇路径权值和 最后答案*2，因为双向都要算一遍，再加上单个点的贡献 AC代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 2e5+10; const int mod= 1e9+7; #define int long long vector&lt;int>e[N]; int dis[N][2],siz[N][2],n,ans,w[N]; void dfs(int u,int fa){ siz[u][1]=1; dis[u][1]=(w[u]+mod)%mod; for(auto v:e[u]){ if(v==fa) continue; dfs(v,u); ans=(ans+dis[u][0]*siz[v][1]%mod+dis[v][1]*siz[u][0]%mod)%mod; ans=(ans+dis[u][1]*siz[v][0]%mod+dis[v][0]*siz[u][1]%mod)%mod; siz[u][0]+=siz[v][1]; siz[u][1]+=siz[v][0]; dis[u][0]=(dis[u][0]+dis[v][1]-w[u]*siz[v][1]%mod+mod)%mod; dis[u][1]=(dis[u][1]+dis[v][0]+w[u]*siz[v][0]%mod+mod)%mod; } } signed main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif read(n); for(int i=1;i&lt;=n;i++) read(w[i]); for(int i=1;i&lt;n;i++){ int u,v; read(u,v); e[u].pb(v); e[v].pb(u); } dfs(1,1); ans*=2; ans%=mod; for(int i=1;i&lt;=n;i++) ans=(ans+w[i]+mod)%mod; cout&lt;&lt;ans&lt;&lt;endl; return 0; } ? document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"小凡"},{"title":"ZOJ - 3988 Prome Set","slug":"ZOJ3988","date":"2020-06-22T09:41:02.000Z","updated":"2020-06-22T09:45:56.956Z","comments":true,"path":"2020/06/22/ZOJ3988/","link":"","permalink":"http://yoursite.com/2020/06/22/ZOJ3988/","excerpt":"","text":"传送门：ZOJ - 3988 思路分析很显然求最大匹配，先用筛法预处理素数，然后将能够配对的进行连边得到最大匹配数为$sum$，如果$sum&gt;k$，那么直接输出$2×k$,否则统计剩下存在边但是没有进行匹配的个数，这些点通过与已经进行匹配的点再进行匹配，对配对数造成+1的贡献，对答案造成+1的贡献所以答案就是$min(k-sum,cnt)$ AC代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 3e3+10; const int M = 2e6+10; vector&lt;int>e[N]; int use[N],link[N],a[N]; int n,k; bool prim[M]; void solve(){ mem(prim,true); for(int i=2;i&lt;M;i++){ if(prim[i]){ for(int j=2*i;j&lt;M;j+=i) prim[j]=false; } } } bool dfs(int u){ use[u]=1; for(auto v:e[u]){ if(!use[v]){ use[v]=1; if(link[v]==-1 || dfs(link[v])){ link[u]=v; link[v]=u; return true; } } } return false; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif solve(); int T; cin>>T; while(T--){ cin>>n>>k; mem(link,0); for(int i=1;i&lt;=n;i++){ cin>>a[i]; e[i].clear(); } for(int i=1;i&lt;=n;i++){ for(int j=i+1;j&lt;=n;j++){ if(prim[a[i]+a[j]]){ link[i]=link[j]=-1; e[i].pb(j); e[j].pb(i); } } } int sum=0; for(int i=1;i&lt;=n;i++){ if(link[i]==-1){ mem(use,0); if(dfs(i)) sum++; } } int cnt=0; for(int i=1;i&lt;=n;i++) if(link[i]==-1) cnt++; if(sum>=k) cout&lt;&lt;k+k&lt;&lt;endl; else cout&lt;&lt;sum*2+min(k-sum,cnt)&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二分图","slug":"二分图","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"}],"author":"小凡"},{"title":"HDU - 6268 Master of Subgraph","slug":"HDU6268","date":"2020-06-22T09:31:02.000Z","updated":"2020-06-22T09:36:42.012Z","comments":true,"path":"2020/06/22/HDU6268/","link":"","permalink":"http://yoursite.com/2020/06/22/HDU6268/","excerpt":"","text":"传送门：HDU - 6268 思路分析考虑点分治，计算包含根节点的所有子图存在的权值和，可以用bitset维护，儿子的状态可以由父亲的状态加上儿子的权值进行转移，加上权值的话就相当于s&lt;&lt;w AC代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int M = 1e5+10; const int N = 3030; vector&lt;int>e[N]; bitset&lt;M>s[N],ans; int n,m,siz[N],root,maxp[N],w[N],tot,vis[N]; void getroot(int u,int fa) { siz[u]=1; maxp[u]=0; for(auto v:e[u]) { if(v==fa || vis[v]) continue; getroot(v,u); siz[u]+=siz[v]; maxp[u]=max(maxp[u],siz[v]); } maxp[u]=max(tot-siz[u],maxp[u]); if(maxp[u]&lt;maxp[root]) root=u; } void calc(int u,int fa) { for(auto v:e[u]) { if(v==fa || vis[v]) continue; s[v]=(s[u]&lt;&lt;w[v]); calc(v,u); s[u]|=s[v]; } } void div(int u) { vis[u]=1; s[u].reset(); s[u][w[u]]=1; calc(u,u); ans|=s[u]; for(auto v:e[u]) { if(vis[v]) continue; tot=siz[v]; root=0; getroot(v,v); div(root); } } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int T; cin>>T; while(T--) { cin>>n>>m; tot=n; ans.reset(); for(int i=1; i&lt;=n; i++) { e[i].clear(); maxp[i]=0; vis[i]=0; } root=0; maxp[root]=tot; for(int i=1; i&lt;n; i++) { int u,v; cin>>u>>v; e[u].pb(v); e[v].pb(u); } for(int i=1; i&lt;=n; i++) cin>>w[i]; getroot(1,1); div(root); for(int i=1;i&lt;=m;i++) cout&lt;&lt;ans[i]; cout&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"点分治","slug":"点分治","permalink":"http://yoursite.com/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"}],"author":"小凡"},{"title":"CodeForces-981D Bookshelves","slug":"CF981D","date":"2020-06-22T03:10:52.000Z","updated":"2020-06-22T03:13:17.227Z","comments":true,"path":"2020/06/22/CF981D/","link":"","permalink":"http://yoursite.com/2020/06/22/CF981D/","excerpt":"","text":"传送门：CoderForces - 981D 思路分析按位进行贪心，每一位进行dp，要满足之前所产生的答案，dp[i][j]表示前i个能否分成j组 AC代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; #define int long long int dp[55][55],s[55]; int n,m,ans; int solve(int x) { mem(dp,0); int now=(ans|(1LL&lt;&lt;x)); dp[0][0]=1; for(int i=1; i&lt;=n; i++) { for(int j=0; j&lt;i; j++) { for(int k=1; k&lt;=i; k++) { int sum=s[i]-s[j]; if((sum&amp;now)>=now) dp[i][k]|=dp[j][k-1]; } } } return dp[n][m]; } signed main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n>>m; for(int i=1; i&lt;=n; i++) { int x; cin>>x; s[i]=s[i-1]+x; } for(int i=61; i>=0; i--) if(solve(i)) ans|=(1LL&lt;&lt;i); cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"CodeForces-1216D Wi-Fi","slug":"CF1216F","date":"2020-06-21T14:20:04.000Z","updated":"2020-06-21T14:21:49.467Z","comments":true,"path":"2020/06/21/CF1216F/","link":"","permalink":"http://yoursite.com/2020/06/21/CF1216F/","excerpt":"","text":"传送门：CodeForces-1216D 思路分析DP方程不难想，转移过程是区间最值，所以可以用线段树优化 AC代码 #include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); #define int long long const int INF = 1e18; const int N = 2e5+10; struct node{ struct Node{ int l,r,mid,mi; }tree[N&lt;&lt;2]; #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 void pp(int x){ tree[x].mi=min(tree[ls].mi,tree[rs].mi); } void build(int x,int l,int r){ tree[x]={l,r,l+r>>1,INF}; if(l==r) return ; int mid=tree[x].mid; build(ls,l,mid); build(rs,mid+1,r); pp(x); } void modify(int x,int pos,int k){ if(tree[x].l==pos &amp;&amp; tree[x].r==pos){ tree[x].mi=min(tree[x].mi,k); return ; } int mid=tree[x].mid; if(pos&lt;=mid) modify(ls,pos,k); else modify(rs,pos,k); pp(x); } int query(int x,int l,int r){ if(l&lt;=tree[x].l &amp;&amp; tree[x].r&lt;=r ){ return tree[x].mi; } int ans=INF; int mid=tree[x].mid; if(l&lt;=mid) ans=min(ans,query(ls,l,r)); if(r>mid) ans=min(ans,query(rs,l,r)); return ans; } #undef ls #undef rs }t0,t1; int dp[N][2]; char s[N]; signed main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,k; cin>>n>>k; cin>>s+1; for(int i=1;i&lt;=n;i++) dp[i][0]=dp[i][1]=1e18; dp[0][0]=0; t0.build(1,0,n); t1.build(1,0,n); t0.modify(1,0,0); for(int i=1;i&lt;=n;i++){ dp[i][0]=min(dp[i-1][0]+i,t1.query(1,max(0LL,i-k),i-1)); if(s[i]=='1') dp[i][1]=min(t0.query(1,max(0LL,i-k-1),i-1),t1.query(1,max(0LL,i-k-1),i-1))+i; t0.modify(1,i,dp[i][0]); t1.modify(1,i,dp[i][1]); } cout&lt;&lt;min(dp[n][0],dp[n][1])&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"CodeForces-1363F Rotaing Substrings","slug":"CF1363F","date":"2020-06-20T02:25:03.000Z","updated":"2020-06-20T02:41:23.682Z","comments":true,"path":"2020/06/20/CF1363F/","link":"","permalink":"http://yoursite.com/2020/06/20/CF1363F/","excerpt":"","text":"传送门：CodeForces-1363F 思路分析可以将操作理解为把一个位置拿出来，插入到左边的某个位置上去那么可以进行dp,设dp[i][j]表示前i个s串和前j个t串能匹配的最长公共子序列这个子序列有限制，i之后的字符集一定要大于等于j之后的，因为他只能从右边拿到左边，不能从左边拿到右边 AC代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 2020; char s[N],t[N]; int suf_s[30][N],suf_t[30][N],dp[N][N]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int T; cin>>T; while(T--){ int n; cin>>n; cin>>s+1>>t+1; for(int i=0;i&lt;26;i++) suf_s[i][n+1]=suf_t[i][n+1]=0; for(int i=n;i>=1;i--){ for(int j=0;j&lt;26;j++) { suf_s[j][i]=suf_s[j][i+1]; suf_t[j][i]=suf_t[j][i+1]; } suf_s[s[i]-'a'][i]++; suf_t[t[i]-'a'][i]++; } int flag=0; for(int i=0;i&lt;26;i++) if(suf_s[i][1] != suf_t[i][1]) flag=1; if(flag){ cout&lt;&lt;-1&lt;&lt;endl; continue; } dp[0][0]=0; for(int i=1;i&lt;=n;i++) dp[i][0]=dp[0][i]=0; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ dp[i][j]=max(dp[i-1][j],dp[i][j-1]); if(s[i]==t[j]){ int ok=1; for(int k=0;k&lt;26;k++) if(suf_s[k][i+1]&lt;suf_t[k][j+1]) ok=0; if(ok) dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1); } } } cout&lt;&lt;n-dp[n][n]&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"EOJ - 3338 双塔问题","slug":"EOJ3338","date":"2020-06-16T09:52:47.000Z","updated":"2020-06-16T12:18:11.781Z","comments":true,"path":"2020/06/16/EOJ3338/","link":"","permalink":"http://yoursite.com/2020/06/16/EOJ3338/","excerpt":"","text":"传送门：EOJ - 3338 思路分析发现值域很小，所以可以枚举值域进行DP设dp[i][j][k]，表示用前i个积木，高的积木比低的多j，第i个积木的放法的最大然后考虑每一种放法的转移就可以了 AC代码 #include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e4+10; int dp[110][N][3],a[110]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; int sum=0; for(int i=1;i&lt;=n;i++) cin>>a[i],sum+=a[i]; mem(dp,-INF); dp[0][0][1]=dp[0][0][2]=dp[0][0][0]=0; for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=sum;j++) { for(int k=0;k&lt;3;k++) dp[i][j][0]=max(dp[i][j][0],dp[i-1][j][k]); if(j-a[i]>=0) for(int k=0;k&lt;3;k++) dp[i][j][1]=max(dp[i][j][1],dp[i-1][j-a[i]][k]+a[i]); if(a[i]>=j) for(int k=0;k&lt;3;k++) dp[i][j][2]=max(dp[i][j][2],dp[i-1][a[i]-j][k]+j); for(int k=0;k&lt;3;k++) dp[i][j][2]=max(dp[i][j][2],dp[i-1][j+a[i]][k]); } } int ans=0; for(int k=0;k&lt;3;k++) ans=max(ans,dp[n][0][k]); cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"CodeForces-1364D Ehab's last Corollary （dfs树）","slug":"CF1364D","date":"2020-06-16T07:48:14.000Z","updated":"2020-06-16T07:52:12.720Z","comments":true,"path":"2020/06/16/CF1364D/","link":"","permalink":"http://yoursite.com/2020/06/16/CF1364D/","excerpt":"","text":"传送门：CodeForces-1364D 思路分析dfs树有一个性质：每条非树边都连向子树中的某一个点那么，这条非树边与中间的链就形成了一个环，可以用一个环存当前链对于独立集，按深度大到小选就能选到最多的了 AC代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e5+10; int n,m,k; vector&lt;int>e[N],ans; int dep[N],vis[N]; void dfs(int u,int fa){ ans.pb(u); dep[u]=sz(ans); for(auto v:e[u]){ if(!dep[v]) dfs(v,u); else if(dep[u]-dep[v]+1&lt;=k &amp;&amp; dep[u]-dep[v]+1>=3){ cout&lt;&lt;2&lt;&lt;endl; cout&lt;&lt;dep[u]-dep[v]+1&lt;&lt;endl; for(int i=dep[v]-1;i&lt;dep[u];i++) cout&lt;&lt;ans[i]&lt;&lt;\" \"; exit(0); } } if(!vis[u]){ for(auto v:e[u]) vis[v]=1; } ans.pop_back(); } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif read(n,m,k); while(m--){ int u,v; read(u,v); e[u].pb(v); e[v].pb(u); } dfs(1,1); cout&lt;&lt;1&lt;&lt;endl; k=(k+1)/2; for(int i=1;i&lt;=n &amp;&amp; k;i++){ if(!vis[i]){ cout&lt;&lt;i&lt;&lt;\" \"; k--; } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"author":"小凡"},{"title":"HDU - 5306 Gorgeous Sequence","slug":"HDU5306","date":"2020-06-15T12:27:36.000Z","updated":"2020-06-15T12:39:20.045Z","comments":true,"path":"2020/06/15/HDU5306/","link":"","permalink":"http://yoursite.com/2020/06/15/HDU5306/","excerpt":"","text":"传送门：HDU - 5306 思路分析记录一下区间最大值，最大值数量，次大值如果当前区间的最大值小于val，就直接返回如果val大于次大值的话，只有最大值会受到影响剩下的直接暴力递归下去查询的时候也要pushdown，因为之前存在区间被修改 AC代码 #include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e6+10; struct node { int l,r,mid,ma,cnt,sema; ll sum; } tree[N&lt;&lt;2]; int a[N]; #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 void pp(int x) { tree[x].sum=tree[ls].sum+tree[rs].sum; tree[x].ma=max(tree[ls].ma,tree[rs].ma); tree[x].sema=max(tree[ls].sema,tree[rs].sema); tree[x].cnt=0; if(tree[ls].ma!=tree[rs].ma) tree[x].sema=max(tree[x].sema,min(tree[ls].ma,tree[rs].ma)); if(tree[x].ma==tree[ls].ma) tree[x].cnt+=tree[ls].cnt; if(tree[x].ma==tree[rs].ma) tree[x].cnt+=tree[rs].cnt; } void build(int x,int l,int r) { int mid=l+r>>1; tree[x]= {l,r,mid}; if(l==r) { tree[x].cnt=1; tree[x].ma=a[l]; tree[x].sum=a[l]; tree[x].sema=-INF; return ; } build(ls,l,mid); build(rs,mid+1,r); pp(x); } void solve(int x,int val) { if(val&lt;tree[x].ma) { tree[x].sum-=1LL*(tree[x].ma-val)*tree[x].cnt; tree[x].ma=val; } } void pd(int x) { solve(ls,tree[x].ma); solve(rs,tree[x].ma); } void modify(int x,int l,int r,int val) { if(val>=tree[x].ma) return ; if(l&lt;=tree[x].l &amp;&amp; tree[x].r&lt;=r &amp;&amp; val > tree[x].sema) { solve(x,val); return ; } pd(x); int mid=tree[x].mid; if(l&lt;=mid) modify(ls,l,r,val); if(r>mid) modify(rs,l,r,val); pp(x); } int getmax(int x,int l,int r) { if(l&lt;=tree[x].l &amp;&amp; tree[x].r&lt;=r) { return tree[x].ma; } pd(x); int mid=tree[x].mid; int ans=-INF; if(l&lt;=mid) ans=max(ans,getmax(ls,l,r)); if(r>mid) ans=max(ans,getmax(rs,l,r)); return ans; } ll getsum(int x,int l,int r) { if(l&lt;=tree[x].l &amp;&amp; tree[x].r&lt;=r) { return tree[x].sum; } pd(x); ll ans=0; int mid=tree[x].mid; if(l&lt;=mid) ans+=getsum(ls,l,r); if(r>mid) ans+=getsum(rs,l,r); return ans; } #undef ls #undef rs int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int T; read(T); while(T--) { int n,m; read(n,m); for(int i=1; i&lt;=n; i++) read(a[i]); build(1,1,n); while(m--) { int op,l,r,x; read(op,l,r); if(op==0) { read(x); modify(1,l,r,x); } if(op==1) printf(\"%d\\n\",getmax(1,l,r)); if(op==2) printf(\"%lld\\n\",getsum(1,l,r)); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"势能线段树","slug":"势能线段树","permalink":"http://yoursite.com/tags/%E5%8A%BF%E8%83%BD%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"author":"小凡"},{"title":"洛谷 - P3332 [ZJOI2013] K大数查询","slug":"luogu3332","date":"2020-06-03T10:44:55.000Z","updated":"2020-06-03T10:52:32.520Z","comments":true,"path":"2020/06/03/luogu3332/","link":"","permalink":"http://yoursite.com/2020/06/03/luogu3332/","excerpt":"","text":"传送门：洛谷 - P3332 思路分析一般查询第K大数这类问题，可以在值域线段树上快速解决，所以这道题外层为值域线段树，内层套下标线段树因为涉及到区间修改，动态开点的话pushdown的时候要新建，所以采用标记永久化，这样就不用pushdown了 AC代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) #define int long long namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 5e4+10; int n,q; //下标 struct node1{ ll sum; int tag,ls,rs; }xtree[N * 400]; int cntx; #define ls xtree[x].ls #define rs xtree[x].rs void change(int &amp;x,int l,int r,int L,int R){ if(!x) x=++cntx; xtree[x].sum+=R-L+1; if(l==L &amp;&amp; r==R){ xtree[x].tag++; return ; } int mid=l+r>>1; if(R&lt;=mid) change(ls,l,mid,L,R); else if(L>mid) change(rs,mid+1,r,L,R); else{ change(ls,l,mid,L,mid); change(rs,mid+1,r,mid+1,R); } return ; } ll query(int &amp;x,int l,int r,int L,int R,int tag){ if(!x) return 1LL*tag*(R-L+1); if(l==L &amp;&amp; r==R){ return xtree[x].sum+1LL*tag*(R-L+1); } int mid=l+r>>1; tag+=xtree[x].tag; if(R&lt;=mid) return query(ls,l,mid,L,R,tag); else if(L>mid) return query(rs,mid+1,r,L,R,tag); else return query(ls,l,mid,L,mid,tag) + query(rs,mid+1,r,mid+1,R,tag); } #undef ls #undef rs //值域 struct node2{ int root,l,r,ls,rs; }vtree[N * 4]; int root,cntv; #define ls vtree[x].ls #define rs vtree[x].rs void build(int &amp;x,int l,int r){ if(!x) x=++cntv; vtree[x].l=l; vtree[x].r=r; if(l==r) return ; int mid=l+r>>1; build(ls,l,mid); build(rs,mid+1,r); } void modify(int x,int L,int R,int pos){ change(vtree[x].root,1,n,L,R); if(vtree[x].l == vtree[x].r){ return ; } int mid=vtree[x].l+vtree[x].r>>1; if(pos&lt;=mid) modify(ls,L,R,pos); else modify(rs,L,R,pos); } int ask(int x,int L,int R,int k){ if(vtree[x].l==vtree[x].r) return vtree[x].l; int tmp=query(vtree[rs].root,1,n,L,R,0); if(k&lt;=tmp) return ask(rs,L,R,k); else return ask(ls,L,R,k-tmp); } #undef ls #undef rs signed main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif read(n,q); build(root,-n,n); while(q--){ int op,l,r; ll x; read(op,l,r,x); if(op==1) modify(root,l,r,x); else printf(\"%lld\\n\",ask(root,l,r,x)); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树套树","slug":"树套树","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%A5%97%E6%A0%91/"}],"author":"小凡"},{"title":"洛谷 - P3810 陌上花开","slug":"luogu3810","date":"2020-06-03T10:13:02.000Z","updated":"2020-06-03T10:24:58.370Z","comments":true,"path":"2020/06/03/luogu3810/","link":"","permalink":"http://yoursite.com/2020/06/03/luogu3810/","excerpt":"","text":"传送门：洛谷 - P3810 思路分析先对一维进行排序，然后对二维进行归并的时候计算贡献因为只计算左边对右边的贡献，所以要进行去重 AC代码 #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 2e5+10; struct node{ int a,b,c,val,sum; }s[N],t[N]; int b[N],ans[N],n,m,cnt; void add(int x,int k){ for(int i=x;i&lt;N;i+=lowbit(i)) b[i]+=k; } int query(int x){ int ans=0; for(int i=x;i;i-=lowbit(i)) ans+=b[i]; return ans; } void cdq(int l,int r){ if(l==r) return ; int mid=l+r>>1; cdq(l,mid); cdq(mid+1,r); int i=l,j=mid+1,k=l; while(i&lt;=mid &amp;&amp; j&lt;=r){ if(s[i].b&lt;=s[j].b){ add(s[i].c,s[i].sum); t[k++]=s[i++]; }else{ s[j].val+=query(s[j].c); t[k++]=s[j++]; } } while(i&lt;=mid) { add(s[i].c,s[i].sum); t[k++]=s[i++]; } while(j&lt;=r){ s[j].val+=query(s[j].c); t[k++]=s[j++]; } for(int i=l;i&lt;=mid;i++) add(s[i].c,-s[i].sum); for(int i=l;i&lt;=r;i++) s[i]=t[i]; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif read(n,m); for(int i=1;i&lt;=n;i++){ read(s[i].a,s[i].b,s[i].c); s[i].sum=1; } sort(s+1,s+1+n,[](node x,node y){ if(x.a==y.a){ if(x.b==y.b) return x.c&lt;y.c; else return x.b&lt;y.b; }else return x.a&lt;y.a; }); cnt=1; for(int i=2;i&lt;=n;i++){ if(s[i].a==s[cnt].a &amp;&amp; s[i].b==s[cnt].b &amp;&amp; s[i].c==s[cnt].c) s[cnt].sum++; else s[++cnt]=s[i]; } cdq(1,cnt); for(int i=1;i&lt;=cnt;i++) ans[s[i].val+s[i].sum-1]+=s[i].sum; for(int i=0;i&lt;n;i++) printf(\"%d\\n\",ans[i]); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CDQ分治","slug":"CDQ分治","permalink":"http://yoursite.com/tags/CDQ%E5%88%86%E6%B2%BB/"}],"author":"小凡"},{"title":"牛客 - 点对最大值","slug":"nk207420","date":"2020-06-03T10:08:51.000Z","updated":"2020-06-03T10:11:02.381Z","comments":true,"path":"2020/06/03/nk207420/","link":"","permalink":"http://yoursite.com/2020/06/03/nk207420/","excerpt":"","text":"传送门：牛客 - 点对最大值 思路分析显然可以进行DP，$dp[u]$表示以$u$为起点向下权值最大的链 AC代码 #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e6+10; vector&lt;pair&lt;int,int>>e[N]; int a[N],dp[N],ans; void dfs(int u){ dp[u]=a[u]; for(auto x:e[u]){ int v=x.fi; int w=x.se; dfs(v); ans=max(ans,dp[v]+dp[u]+w); dp[u]=max(dp[u],dp[v]+w); } } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; while(t--){ int n; cin>>n; for(int i=2;i&lt;=n;i++){ int x,y; cin>>x>>y; e[x].pb(mp(i,y)); } ans=-INF; for(int i=1;i&lt;=n;i++) cin>>a[i]; dfs(1); cout&lt;&lt;ans&lt;&lt;endl; for(int i=1;i&lt;=n;i++) e[i].clear(); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"小凡"},{"title":"CodeForces-1009F Dominant Indeces","slug":"CF1009F","date":"2020-05-30T11:36:38.000Z","updated":"2020-05-30T11:43:32.395Z","comments":true,"path":"2020/05/30/CF1009F/","link":"","permalink":"http://yoursite.com/2020/05/30/CF1009F/","excerpt":"","text":"传送门：CodeForces-1009F 思路分析线段树合并的话要注意空间，开一个栈存没用的点，然后搞搞就行了 树上启发式合并代码 #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e6+10; vector&lt;int>e[N]; int siz[N],dep[N],son[N],ans[N],sum[N]; void dfs1(int u,int fa) { dep[u]=dep[fa]+1; siz[u]=1; int maxlen=0; for(auto v:e[u]) { if(v==fa) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]>siz[son[u]]) son[u]=v; } } int ma,res; void add(int u,int fa) { sum[dep[u]]++; if(sum[dep[u]]==ma) res=min(res,dep[u]); if(sum[dep[u]]>ma){ ma=sum[dep[u]]; res=dep[u]; } for(auto v:e[u]) if(v!=fa) add(v,u); } void del(int u,int fa) { sum[dep[u]]--; for(auto v:e[u]) if(v!=fa) del(v,u); } void dfs2(int u,int fa) { for(auto v:e[u]) { if(v==fa || v==son[u]) continue; dfs2(v,u); del(v,u); ma=-1; } if(son[u]) dfs2(son[u],u); for(auto v:e[u]) { if(v==son[u] || v==fa) continue; add(v,u); } sum[dep[u]]++; if(sum[dep[u]]==ma) res=min(res,dep[u]); if(sum[dep[u]]>ma){ ma=sum[dep[u]]; res=dep[u]; } ans[u]=res-dep[u]; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; read(n); for(int i=1; i&lt;n; i++) { int u,v; read(u,v); e[u].pb(v); e[v].pb(u); } dfs1(1,0); dfs2(1,0); for(int i=1; i&lt;=n; i++) printf(\"%d\\n\",ans[i]); return 0; } 线段树合并代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e6+10; struct node { int ls,rs,ma,id; void clear() { ls=0; rs=0; ma=0; id=0; } } tree[N * 10]; int ans[N],dep[N]; int root[N],cnt,st[N * 10],top; vector&lt;int>e[N]; void pp(int x) { int ls=tree[x].ls; int rs=tree[x].rs; if(tree[ls].ma>=tree[rs].ma) { tree[x].id=tree[ls].id; tree[x].ma=tree[ls].ma; return ; } else { tree[x].id=tree[rs].id; tree[x].ma=tree[rs].ma; return ; } } int newnode() { if(top) return st[top--]; else return ++cnt; } void ins(int &amp;x,int l,int r,int pos) { if(!x) x=newnode(); if(l==r) { tree[x].ma++; tree[x].id=l; return ; } int mid=l+r>>1; if(pos&lt;=mid) ins(tree[x].ls,l,mid,pos); else ins(tree[x].rs,mid+1,r,pos); pp(x); } int merge(int x,int y,int l,int r) { if( !x || !y) return x?x:y; if(l==r) { tree[x].ma+=tree[y].ma; st[++top]=y; tree[y].clear(); return x; } int mid=l+r>>1; tree[x].ls=merge(tree[x].ls,tree[y].ls,l,mid); tree[x].rs=merge(tree[x].rs,tree[y].rs,mid+1,r); pp(x); tree[y].clear(); st[++top]=y; return x; } void dfs(int u,int f) { dep[u]=dep[f]+1; root[u]=++cnt; for(auto v:e[u]) { if(v==f) continue; dfs(v,u); root[u]=merge(root[u],root[v],1,N); } ins(root[u],1,N,dep[u]); ans[u]=tree[root[u]].id-dep[u]; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; read(n); for(int i=1; i&lt;n; i++) { int u,v; read(u,v); e[u].pb(v); e[v].pb(u); } dfs(1,0); for(int i=1; i&lt;=n; i++) printf(\"%d\\n\",ans[i]); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树上启发式合并","slug":"树上启发式合并","permalink":"http://yoursite.com/tags/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"},{"name":"线段树合并","slug":"线段树合并","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"}],"author":"小凡"},{"title":"洛谷 - P4556 雨天的尾巴 （树上差分）","slug":"luogu4556","date":"2020-05-29T14:02:14.000Z","updated":"2020-05-29T14:05:34.085Z","comments":true,"path":"2020/05/29/luogu4556/","link":"","permalink":"http://yoursite.com/2020/05/29/luogu4556/","excerpt":"","text":"传送门：洛谷 - P4556 思路分析利用树上差分的性质，将路径修改单点查询转化为单点修改子树查询 u++ v++ lca– fa[lca]– AC代码 #include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 2e5+10; struct node{ int ls,rs,ma,id; }tree[N * 40]; vector&lt;int>e[N]; int root[N],cnt,ans[N]; int dep[N],fa[N],top[N],siz[N],son[N]; void dfs1(int u,int f){ dep[u]=dep[f]+1; fa[u]=f; siz[u]=1; for(auto v:e[u]){ if(v==f) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]>siz[son[u]]) son[u]=v; } } void dfs2(int u,int t){ top[u]=t; if(!son[u]) return ; dfs2(son[u],t); for(auto v:e[u]){ if(v==son[u] || v==fa[u]) continue; dfs2(v,v); } } int lca(int x,int y){ while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; } return dep[x]>dep[y]?y:x; } void pp(int x){ int ls=tree[x].ls; int rs=tree[x].rs; if(tree[ls].ma>=tree[rs].ma){ tree[x].id=tree[ls].id; tree[x].ma=tree[ls].ma; return ; }else{ tree[x].id=tree[rs].id; tree[x].ma=tree[rs].ma; return ; } } void ins(int &amp;x,int l,int r,int pos){ if(!x) x=++cnt; if(l==r){ tree[x].ma++; tree[x].id=l; return ; } int mid=l+r>>1; if(pos&lt;=mid) ins(tree[x].ls,l,mid,pos); else ins(tree[x].rs,mid+1,r,pos); pp(x); } void del(int &amp;x,int l,int r,int pos){ if(!x) x=++cnt; if(l==r){ tree[x].ma--; tree[x].id=l; return ; } int mid=l+r>>1; if(pos&lt;=mid) del(tree[x].ls,l,mid,pos); else del(tree[x].rs,mid+1,r,pos); pp(x); } int merge(int x,int y,int l,int r){ if( !x || !y) return x?x:y; if(l==r){ tree[x].ma+=tree[y].ma; tree[x].id=l; return x; } int mid=l+r>>1; tree[x].ls=merge(tree[x].ls,tree[y].ls,l,mid); tree[x].rs=merge(tree[x].rs,tree[y].rs,mid+1,r); pp(x); return x; } void dfs(int u,int f){ for(auto v:e[u]){ if(v==f) continue; dfs(v,u); root[u]=merge(root[u],root[v],1,N); } if(tree[root[u]].ma>0) ans[u]=tree[root[u]].id; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,m; read(n,m); for(int i=1;i&lt;n;i++){ int u,v; read(u,v); e[u].pb(v); e[v].pb(u); } dfs1(1,0); dfs2(1,1); while(m--){ int a,b,c; read(a,b,c); int lc=lca(a,b); ins(root[a],1,N,c); ins(root[b],1,N,c); del(root[lc],1,N,c); if(fa[lc]) del(root[fa[lc]],1,N,c); } dfs(1,0); for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树合并","slug":"线段树合并","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"}],"author":"小凡"},{"title":"洛谷 - P1456 Monkey King","slug":"luogu1456","date":"2020-05-26T11:50:51.000Z","updated":"2020-05-26T11:52:45.381Z","comments":true,"path":"2020/05/26/luogu1456/","link":"","permalink":"http://yoursite.com/2020/05/26/luogu1456/","excerpt":"","text":"传送门：洛谷 - P1456 思路分析每次打架就合并两个线段树，用并查集维护集合关系 AC代码 #include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e5+10; struct node{ int sum,ls,rs; }tree[N * 40]; int root[N],cnt,f[N]; int find(int x){ return f[x]==x?x:f[x]=find(f[x]); } int newnode(){ int x=++cnt; tree[x].ls=0; tree[x].rs=0; tree[x].sum=0; return x; } void ins(int &amp;x,int l,int r,int pos){ if(!x) x=newnode(); tree[x].sum++; if(l==r) return ; int mid=l+r>>1; if(pos&lt;=mid) ins(tree[x].ls,l,mid,pos); else ins(tree[x].rs,mid+1,r,pos); } void del(int x,int l,int r,int pos){ tree[x].sum--; if(l==r) return ; int mid=l+r>>1; if(pos&lt;=mid) del(tree[x].ls,l,mid,pos); else del(tree[x].rs,mid+1,r,pos); } int merge(int x,int y){ if( !x || !y ) return x?x:y; tree[x].sum=tree[x].sum+tree[y].sum; tree[x].ls=merge(tree[x].ls,tree[y].ls); tree[x].rs=merge(tree[x].rs,tree[y].rs); return x; } int query(int x,int l,int r){ if(l==r) return l; int mid=l+r>>1; if(tree[tree[x].rs].sum) return query(tree[x].rs,mid+1,r); else return query(tree[x].ls,l,mid); } int tot=32768; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; while(read(n)){ cnt=0; mem(root,0); for(int i=0;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=n;i++){ int x; read(x); ins(root[i],1,tot,x); } int m; read(m); while(m--){ int x,y; read(x,y); int fx=find(x); int fy=find(y); if(fx==fy){ puts(\"-1\"); continue; } int a=query(root[fx],1,tot); int b=query(root[fy],1,tot); del(root[fx],1,tot,a); del(root[fy],1,tot,b); ins(root[fx],1,tot,a/2); ins(root[fy],1,tot,b/2); f[fx]=fy; root[fy]=merge(root[fx],root[fy]); printf(\"%d\\n\",query(root[fy],1,tot)); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树合并","slug":"线段树合并","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"}],"author":"小凡"},{"title":"CodeForces-992E King-Shamans","slug":"CF992E","date":"2020-05-26T05:45:49.000Z","updated":"2020-05-26T05:50:37.384Z","comments":true,"path":"2020/05/26/CF992E/","link":"","permalink":"http://yoursite.com/2020/05/26/CF992E/","excerpt":"","text":"传送门：CodeForces-992E 思路分析用线段树维护$a_i-sum_{i-1}$，修改的时候区间修改，记录区间最大值和最小值要找等于0的位置，就看区间是否可能包含0，减掉不可能的区间，复杂度还是很玄学的（跑挺快的） AC代码#include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) #define int long long namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 2e5+10; struct node{ int l,r,mid,len; ll ma,mi,lazy; }tree[N&lt;&lt;2]; int a[N]; ll ss[N]; void pp(int x){ tree[x].mi=min(tree[ls].mi,tree[rs].mi); tree[x].ma=max(tree[ls].ma,tree[rs].ma); } void build(int x,int l,int r){ tree[x]={l,r,l+r>>1,r-l+1,-INF,INF,0}; if(l==r){ tree[x].ma=tree[x].mi=a[l]-ss[l-1]; return ; } int mid=tree[x].mid; build(ls,l,mid); build(rs,mid+1,r); pp(x); } void pd(int x){ if(tree[x].lazy){ int s=tree[x].lazy; tree[rs].lazy+=s; tree[ls].lazy+=s; tree[rs].ma+=s; tree[ls].ma+=s; tree[rs].mi+=s; tree[ls].mi+=s; tree[x].lazy=0; } } void modify(int x,int l,int r,int k){ if(l&lt;=tree[x].l &amp;&amp; tree[x].r&lt;=r){ tree[x].ma+=k; tree[x].mi+=k; tree[x].lazy+=k; return ; } pd(x); int mid=tree[x].mid; if(l&lt;=mid) modify(ls,l,r,k); if(r>mid) modify(rs,l,r,k); pp(x); } int ans; void query(int x){ if(ans!=-1) return ; if(tree[x].l==tree[x].r){ if(tree[x].ma==0) ans=tree[x].l; return ; } pd(x); if(tree[ls].ma>=0 &amp;&amp; tree[ls].mi&lt;=0) query(ls); if(tree[rs].ma>=0 &amp;&amp; tree[rs].mi&lt;=0) query(rs); pp(x); } signed main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,m; read(n,m); for(int i=1;i&lt;=n;i++){ read(a[i]); ss[i]=ss[i-1]+a[i]; } build(1,1,n); while(m--){ ans=-1; int p,x; read(p,x); int k=x-a[p]; a[p]=x; modify(1,p,p,k); if(p&lt;n) modify(1,p+1,n,-k); query(1); printf(\"%lld\\n\",ans); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"author":"小凡"},{"title":"CodeForces-765F Souvenirs","slug":"CF765F","date":"2020-05-26T02:06:10.000Z","updated":"2020-05-26T02:16:41.042Z","comments":true,"path":"2020/05/26/CF765F/","link":"","permalink":"http://yoursite.com/2020/05/26/CF765F/","excerpt":"","text":"传送门：CodeForces-765F 思路分析考虑离线做法，按右端点排序，每次右移的时候更新贡献用线段树维护$[1,R]$的贡献，区间查询最小值，每次右移的时候，有一部分的贡献会受影响，不能直接暴力更新，考虑如何优化不难证明，一段区间的贡献可以由每一个区间后缀的贡献得到，所以每次更新的时候，设新右端点的值是x，优先更新右儿子，然后记录下x对右儿子的贡献$mi$，在更新左儿子的时候，二分找到x在这个区间内的前驱和后继计算出x对这个点的贡献$temp$，如果$temp&gt;=mi$，就没必要更新下去了，因为已经无法对区间最小值造成影响了，直接返回，这样的话可以省略很多时间 AC代码#include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e5+10; struct node{ int l,r,mid,res; }tree[N&lt;&lt;2]; int a[N],mi; set&lt;int>s[N&lt;&lt;2]; void pp(int x){ tree[x].res=min(tree[rs].res,tree[ls].res); } void build(int x,int l,int r){ tree[x]={l,r,l+r>>1,INF}; for(int i=l;i&lt;=r;i++) s[x].insert(a[i]); if(l==r) return ; int mid=tree[x].mid; build(ls,l,mid); build(rs,mid+1,r); } void modify(int x,int pos,int k){ if(tree[x].l==tree[x].r){ tree[x].res=min(tree[x].res,abs(k-a[tree[x].l])); mi=min(mi,tree[x].res); return ; } if(tree[x].r&lt;=pos){ auto it=s[x].lower_bound(k); int now=abs(*it-k); if(it!=s[x].begin()) now=min(now,abs(*(--it)-k)); if(now>=mi){ tree[x].res=min(tree[x].res,mi); mi=min(mi,tree[x].res); return ; } } int mid=tree[x].mid; if(pos>mid) modify(rs,pos,k); modify(ls,pos,k); pp(x); } int query(int x,int l,int r){ if(l&lt;=tree[x].l &amp;&amp; tree[x].r&lt;=r){ return tree[x].res; } int ans=INF; int mid=tree[x].mid; if(l&lt;=mid) ans=min(ans,query(ls,l,r)); if(r>mid) ans=min(ans,query(rs,l,r)); return ans; } struct que{ int id,l,r; }q[N*3]; int ans[N*3]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=1;i&lt;=n;i++) read(a[i]); int m; read(m); for(int i=1;i&lt;=m;i++) read(q[i].l,q[i].r),q[i].id=i; sort(q+1,q+1+m,[](que x,que y){ return x.r&lt;y.r; }); build(1,1,n); int r=2; for(int i=1;i&lt;=m;i++){ while(r&lt;=q[i].r){ mi=INF; modify(1,r-1,a[r]); r++; } ans[q[i].id]=query(1,q[i].l,q[i].r); } for(int i=1;i&lt;=m;i++) cout&lt;&lt;ans[i]&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"author":"小凡"},{"title":"CoderForces-1354F Summoning Minions","slug":"CF1354F","date":"2020-05-24T06:54:15.000Z","updated":"2020-05-24T07:04:07.240Z","comments":true,"path":"2020/05/24/CF1354F/","link":"","permalink":"http://yoursite.com/2020/05/24/CF1354F/","excerpt":"","text":"传送门：CoderForces-1354F 思路分析要使价值最大，每一个都要用上，先确定k-1个人，然后重复使用第k个位置，直到最后一个人，这样肯定是最优的，我们可以发现，在确定的人里面，他们的$b_i$是单调递增的，所以可以按$b_i$从小到大排序，然后进行DP，$dp[i][j]$表示前$i$个人确定了$j$个人的最大价值 因为数据范围很小，所以这道题还可以通过费用流求解： 超级源点–&gt;每个人 流量为1，费用为0 每个人–&gt;每个位置，流量为1，费用分情况讨论 每个位置–&gt;超级汇点，流量为1，费用为0 因为这里需要的是最大费用最大流，所以将费用变为负的，求出来的就是最大费用了记录路径的话，就看边的流量剩余情况就行了 DP代码 #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 80; struct node{ int a,b,id; }a[N]; int dp[N][N]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; while(t--){ int n,k; read(n,k); mem(dp,-INF); dp[0][0]=0; for(int i=1;i&lt;=n;i++) read(a[i].a,a[i].b),a[i].id=i; sort(a+1,a+1+n,[](node x,node y){ return x.b&lt;y.b; }); for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=k;j++){ dp[i][j]=max(dp[i][j],dp[i-1][j]+a[i].b*(k-1)); if(j) dp[i][j]=max(dp[i][j],dp[i-1][j-1]+a[i].a+a[i].b*(j-1)); } } vector&lt;int>ins,del; printf(\"%d\\n\",k+(n-k)*2); int now=dp[n][k],cnt=k; for(int i=n;i>=1;i--){ if(dp[i-1][cnt]+a[i].b*(k-1)==dp[i][cnt]){ del.pb(a[i].id); now=dp[i-1][cnt]; }else{ ins.pb(a[i].id); cnt--; now=dp[i-1][cnt]; } } reverse(all(ins)); for(int i=0;i&lt;sz(ins)-1;i++) cout&lt;&lt;ins[i]&lt;&lt;\" \"; for(auto x:del) cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;-x&lt;&lt;\" \"; cout&lt;&lt;ins[sz(ins)-1]&lt;&lt;endl; } return 0; } 费用流代码#include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 222; const int M = N*N; struct node { int v,flow,w,next; } e[M]; int head[N],cnt; int n,m,s,t,k,maxflow,mincost,path[N],pre[N]; int dis[N],vis[N]; inline void ade(int u,int v,int f,int w) { e[++cnt].v=v; e[cnt].flow=f; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt; } inline void add(int u,int v,int f,int w) { ade(u,v,f,w); ade(v,u,0,-w); } inline bool spfa() { mem(dis,INF); mem(vis,0); mem(pre,-1); dis[s]=0; vis[s]=1; queue&lt;int>q; q.push(s); while(!q.empty()) { int u=q.front(); vis[u]=0; q.pop(); for(int i=head[u]; i; i=e[i].next) { int v=e[i].v; int w=e[i].w; if(e[i].flow>0 &amp;&amp; dis[v]>dis[u]+w) { dis[v]=dis[u]+w; pre[v]=u; path[v]=i; if(!vis[v]) { q.push(v); vis[v]=1; } } } } return pre[t]!=-1; } inline void EK() { while(spfa()) { int mi=INF; for(int i=t; i!=s; i=pre[i]) mi=min(mi,e[path[i]].flow); for(int i=t; i!=s; i=pre[i]) { e[path[i]].flow-=mi; e[path[i]^1].flow+=mi; } maxflow+=mi; mincost+=dis[t]*mi; } } inline init() { mem(head,0); cnt=1; s=N-1; t=N-2; maxflow=0; mincost=0; } int a[N],b[N],ans[N]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int cas; read(cas); while(cas--) { read(n,k); init(); for(int i=1; i&lt;=n; i++) read(a[i],b[i]); for(int i=1; i&lt;=n; i++) { add(s,i,1,0); add(i+n,t,1,0); } for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { if(j&lt;=k-1) add(i,j+n,1,-(a[i]+b[i]*(j-1))); else if(j==n) add(i,j+n,1,-(a[i]+b[i]*(k-1))); else add(i,j+n,1,-(b[i]*(k-1))); } } EK(); for(int i=1; i&lt;=n; i++) { for(int j=head[i]; j; j=e[j].next) { int v=e[j].v; int flow=e[j].flow; if(flow==0 &amp;&amp; v>n &amp;&amp; v&lt;=2*n) ans[v-n]=i; } } printf(\"%d\\n\",k+(n-k)*2); for(int i=1; i&lt;=n; i++) { printf(\"%d \",ans[i]); if(i>k-1 &amp;&amp; i!=n) printf(\"%d \",-ans[i]); } puts(\"\"); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"费用流","slug":"费用流","permalink":"http://yoursite.com/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"}],"author":"小凡"},{"title":"CoderForces-1005F The Shortest paths","slug":"CF1005F","date":"2020-05-20T08:55:49.000Z","updated":"2020-05-20T09:00:24.709Z","comments":true,"path":"2020/05/20/CF1005F/","link":"","permalink":"http://yoursite.com/2020/05/20/CF1005F/","excerpt":"","text":"传送门：CoderForces-1005F 思路分析先跑一遍最短路，然后记录每个点所有的最短路前驱边，最后每一个选其中一条前驱边就行了，连通性是肯定的距离为1的点，选的边一定是与s相连的，距离为2的点，选的前驱一定是距离为1的，这样保证最后形成的图连通 样例输入4 4 3 1 2 2 3 1 4 4 3 样例输出2 1110 1011 AC代码 #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N= 1e6+10; struct node{ int v,next,id; }e[N]; int n,m,k,cnt,head[N]; int dis[N],vis[N]; vector&lt;int>pre[N]; vector&lt;string>ans; string s; void add(int u,int v,int id){ e[++cnt].v=v; e[cnt].id=id; e[cnt].next=head[u]; head[u]=cnt; } void bfs(){ mem(dis,INF); dis[1]=0; queue&lt;int>q; q.push(1); while(!q.empty()){ int u=q.front(); q.pop(); for(int i=head[u];i;i=e[i].next){ int v=e[i].v; if(dis[v]>dis[u]+1 &amp;&amp; !vis[v]){ vis[v]=1; dis[v]=dis[u]+1; q.push(v); } } } } void dfs(int u){ if(ans.size()>=k) return ; if(u>=n+1){ ans.push_back(s); return ; } for(auto v:pre[u]){ s[v]='1'; dfs(u+1); s[v]='0'; } } int main(){ #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif read(n,m,k); for(int i=0;i&lt;m;i++){ s+=\"0\"; int u,v; read(u,v); add(u,v,i); add(v,u,i); } bfs(); for(int i=2;i&lt;=n;i++){ for(int j=head[i];j;j=e[j].next){ int v=e[j].v; if(dis[i]==dis[v]+1) pre[i].push_back(e[j].id); } } dfs(2); cout&lt;&lt;ans.size()&lt;&lt;endl; for(auto x:ans) cout&lt;&lt;x&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"author":"小凡"},{"title":"CoderForces-1005E2 Median on Segments","slug":"CF1005E","date":"2020-05-20T08:49:41.000Z","updated":"2020-05-20T08:54:38.986Z","comments":true,"path":"2020/05/20/CF1005E/","link":"","permalink":"http://yoursite.com/2020/05/20/CF1005E/","excerpt":"","text":"传送门：CoderForces-1005E2 思路分析计算中位数为m的区间个数，可以通过计算大于等于m的答案-大于等于m+1的答案怎么计算中位数大于等于x的区间个数呢，如果一个区间的中位数是大于等于x的，那么这个区间内大于等于x-小于x一定大于等于1，所以可以利用前缀和差分的性质计算出答案。 样例输入15 2 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 样例输出97AC代码#include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) #define int long long namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 2e5+10; int a[N],b[N&lt;&lt;1],n,m; void add(int x){ for(int i=x;i&lt;N*2;i+=lowbit(i)) b[i]++; } int get(int x){ int ans=0; for(int i=x;i;i-=lowbit(i)) ans+=b[i]; return ans; } ll solve(int x){ mem(b,0); int sum=n+1; ll ans=0; add(sum); for(int i=1;i&lt;=n;i++){ if(a[i]>=x) sum++; else sum--; ans+=get(sum-1); add(sum); } return ans; } signed main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n>>m; for(int i=1;i&lt;=n;i++) cin>>a[i]; cout&lt;&lt;solve(m)-solve(m+1)&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"}],"author":"小凡"},{"title":"CodeForces-1009E Intercity Travelling","slug":"CF1009E","date":"2020-05-19T13:35:21.000Z","updated":"2020-05-19T13:59:53.391Z","comments":true,"path":"2020/05/19/CF1009E/","link":"","permalink":"http://yoursite.com/2020/05/19/CF1009E/","excerpt":"","text":"传送门：CodeForces-1009E 思路分析ont总共有$2^{n-1}$总情况，分别统计每种情况中$a[i]$出现的次数$cnt[i]$那么所有情况的期望之和 $sum=$$\\frac{\\sum a[i]*cnt[i]}{2^{n-1}}$ 所以最后的答案就是 $sum=$$\\frac{\\sum a[i]*cnt[i]}{2^{n-1}}$ 下面是$cnt[i]$的推导过程（$i=2$的情况）： 0–&gt;2 存在$a[2]$的话，1不能休息，其余各点随意 –&gt; $2^{n-2}$ 1–&gt;3 存在$a[2]$的话，1必须休息，2不能休息，其余随意 –&gt; $2^{n-3}$ 2–&gt;4 存在$a[2]$的话，2必须休息，3不能休息，其余随意 –&gt; $2^{n-3}$ n-2–&gt;n，存在$a[2]$的话，n-2必须休息，n-1不能休息，其余随意 –&gt; $2^{n-3}$ 同理可得$cnt[i]=2^{n-i}+(n-i)*2^{n-i-1}$ 样例输入4 1 3 3 7 样例输出60AC代码#include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e6+10; const int mod = 998244353; ll a[N],p[N]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; read(n); for(int i=1;i&lt;=n;i++) read(a[i]); p[0]=1; for(int i=1;i&lt;=n;i++) p[i]=p[i-1]*2%mod; ll ans=0; for(int i=1;i&lt;=n;i++){ ll cnt=(p[n-i]+(n-i)*p[n-i-1]%mod)%mod; ans=(ans+a[i]*cnt%mod)%mod; } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"author":"小凡"},{"title":"CodeForces-1006F Path 双向DFS","slug":"CF1006F","date":"2020-05-18T13:30:12.000Z","updated":"2020-05-18T13:32:25.662Z","comments":true,"path":"2020/05/18/CF1006F/","link":"","permalink":"http://yoursite.com/2020/05/18/CF1006F/","excerpt":"","text":"传送门：CodeForces-1006F 思路分析一次DFS的复杂度是$2^40$，两次的话是$2*2^20$从头和从尾开始，跑到相同点的时候统计答案 样例输入3 3 11 2 1 5 7 10 0 12 6 4 样例输出3AC代码 #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; int n,m; ll a[22][22]; map&lt;ll,ll>dp[22][22]; void dfs1(int x,int y,ll s){ if(x>n||x&lt;1||y>m||y&lt;1) return ; s^=a[x][y]; if(x+y==(n+m)/2+1) { dp[x][y][s]++; return ; } dfs1(x+1,y,s); dfs1(x,y+1,s); } ll dfs2(int x,int y,ll s){ if(x>n||x&lt;1||y>m||y&lt;1) return 0; if(x+y==(n+m)/2+1) return dp[x][y][s]; s^=a[x][y]; return dfs2(x-1,y,s)+dfs2(x,y-1,s); } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif ll k; read(n,m,k); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) read(a[i][j]); dfs1(1,1,0); cout&lt;&lt;dfs2(n,m,k)&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}],"author":"小凡"},{"title":"CodeForces-1354E Graph Coloring","slug":"CF1354E","date":"2020-05-18T11:11:52.000Z","updated":"2020-05-18T11:19:12.570Z","comments":true,"path":"2020/05/18/CF1354E/","link":"","permalink":"http://yoursite.com/2020/05/18/CF1354E/","excerpt":"","text":"传送门：CodeForces-1354E 思路分析2只能和1或3连边，1和3不能连边那么很显然是二分图，将每个连通块的点划分为两个集合，集合内的互相无边，集合间有连边将其中一个集合染成2，剩下的部分1或者3随意，那么问题就是如果确定是否有方案能够满足2的数量为$n_2$设$dp[i][j]$表示用了前$i$个连通块，能否组成数量为$j$，假设$dp[cnt][n_2]$成立，那么我们倒着来$dp$，如果最后$dp[0][0]=1$说明存在满足条件的方案，之后再从头开始标记答案就行了 样例输入6 3 2 2 2 3 1 5 4 2 5 样例输出YES 112323 AC代码 #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 5e3+10; int dp[N][N],ans[N],col[N]; int cnt,n,m,n1,n2,n3; vector&lt;int>e[N],s[N][2]; void dfs(int u,int x){ col[u]=x; s[cnt][x==1].pb(u); for(auto v:e[u]){ if(col[v]==0) dfs(v,-x); else if(col[v]==col[u]){ cout&lt;&lt;\"NO\"&lt;&lt;endl; exit(0); } } } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif read(n,m,n1,n2,n3); for(int i=1;i&lt;=m;i++){ int u,v; read(u,v); e[u].pb(v); e[v].pb(u); } for(int i=1;i&lt;=n;i++){ if(col[i]==0){ ++cnt; dfs(i,1); } } dp[cnt][n2]=1; for(int i=cnt;i>=1;i--){ int x=s[i][0].size(); int y=s[i][1].size(); for(int j=0;j&lt;=n;j++){ if(j>=x) dp[i-1][j-x]|=dp[i][j]; if(j>=y) dp[i-1][j-y]|=dp[i][j]; } } if(dp[0][0]==0) return cout&lt;&lt;\"NO\",0; cout&lt;&lt;\"YES\"&lt;&lt;endl; int now=0; for(int i=1;i&lt;=cnt;i++){ int y=s[i][1].size(); int cur=dp[i][now+y]; for(auto v:s[i][cur]) ans[v]=2,now++; for(auto v:s[i][cur^1]) { if(n1) ans[v]=1,n1--; else ans[v]=3; } } for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"二分图","slug":"二分图","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"}],"author":"小凡"},{"title":"CodeForces-1011F Mars rover","slug":"CF1011F","date":"2020-05-18T08:42:08.000Z","updated":"2020-05-18T08:50:47.086Z","comments":true,"path":"2020/05/18/CF1011F/","link":"","permalink":"http://yoursite.com/2020/05/18/CF1011F/","excerpt":"","text":"传送门：CodeForces-1011F 思路分析先一遍DFS求出初始答案$ans[i]$表示更改当前节点改变，会不会对根节点造成影响如果当前节点没影响，那么他的儿子也都没有影响，直接标记上如果判断每个节点有无影响呢，用AND举个例子： 如果该点的左儿子本来的权值是0，那么右儿子改不改变都不会影响当前节点，否则右儿子就会影响。其他的操作同理可得 样例输入10 AND 9 4 IN 1 IN 1 XOR 6 5 AND 3 7 IN 0 NOT 10 IN 1 IN 1 AND 2 8 样例输出10110AC代码#include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e6+10; struct node{ int l,r; string x; }a[N]; int ans[N],val[N]; int dfs1(int u){ if(a[u].x==\"IN\") return val[u]; if(a[u].x==\"NOT\") return (val[u]=!(dfs1(a[u].l))); if(a[u].x==\"OR\") return (val[u]=( dfs1(a[u].l)) | (dfs1(a[u].r)) ); if(a[u].x==\"AND\") return (val[u]=( dfs1(a[u].l)) &amp; (dfs1(a[u].r)) ); if(a[u].x==\"XOR\") return (val[u]=( dfs1(a[u].l)) ^ (dfs1(a[u].r)) ); } void dfs2(int u){ if(ans[u]==0){ ans[a[u].l]=0; ans[a[u].r]=0; }else{ if(a[u].x==\"NOT\") ans[a[u].l]=1; if(a[u].x==\"OR\"){ if(val[a[u].l]) ans[a[u].r]=0; else ans[a[u].r]=1; if(val[a[u].r]) ans[a[u].l]=0; else ans[a[u].l]=1; } if(a[u].x==\"AND\"){ if(val[a[u].l]==0) ans[a[u].r]=0; else ans[a[u].r]=1; if(val[a[u].r]==0) ans[a[u].l]=0; else ans[a[u].l]=1; } if(a[u].x==\"XOR\") ans[a[u].l]=ans[a[u].r]=1; } if(a[u].l) dfs2(a[u].l); if(a[u].r) dfs2(a[u].r); } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=1;i&lt;=n;i++){ cin>>a[i].x; string s=a[i].x; if(s==\"IN\") cin>>val[i]; else if(s==\"NOT\") cin>>a[i].l; else cin>>a[i].l>>a[i].r; ans[i]=1; } dfs1(1); dfs2(1); for(int i=1;i&lt;=n;i++) if(a[i].x==\"IN\") cout&lt;&lt;(val[1]^ans[i]); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}],"author":"小凡"},{"title":"牛客 - 小V和gcd树","slug":"nk205044","date":"2020-05-16T10:52:40.000Z","updated":"2020-05-16T10:58:42.032Z","comments":true,"path":"2020/05/16/nk205044/","link":"","permalink":"http://yoursite.com/2020/05/16/nk205044/","excerpt":"","text":"传送门：牛客 - 小V和gcd树 思路分析将每个点的贡献设为他与他父亲的边权对于修改操作，只修改其重儿子的边权对于查询操作，先跳到顶端处，加上这个点和他父亲的边权，再跳到他的父亲 样例输入6 5 3 6 4 9 9 9 2 1 3 2 4 2 5 4 6 5 2 4 2 2 2 1 3 5 1 3 4 2 3 6 3 2 2 3 4 样例输出0 2 2 1 AC代码#include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e5+10; int a[N],w[N]; vector&lt;int>e[N]; int siz[N],son[N],fa[N],top[N],dep[N],dfn[N],cnt; void dfs1(int u,int f){ fa[u]=f; dep[u]=dep[f]+1; siz[u]=1; for(auto v:e[u]){ if(v==f) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]>siz[son[u]]) son[u]=v; } } void dfs2(int u,int t){ top[u]=t; dfn[u]=++cnt; w[cnt]=__gcd(a[u],a[fa[u]]); if(!son[u]) return ; dfs2(son[u],t); for(auto v:e[u]){ if(v==son[u]|v==fa[u]) continue; dfs2(v,v); } } int getsum(int l,int r,int k){ int ans=0; for(int i=l;i&lt;=r;i++) ans+=(w[i]&lt;=k); return ans; } int query(int x,int y,int k){ int ans=0; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); ans+=getsum(dfn[top[x]]+1,dfn[x],k); x=top[x]; ans+=(__gcd(a[x],a[fa[x]])&lt;=k); x=fa[x]; } if(dep[x]>dep[y]) swap(x,y); ans+=getsum(dfn[x]+1,dfn[y],k); return ans; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,q; read(n,q); for(int i=1;i&lt;=n;i++) read(a[i]); for(int i=1;i&lt;n;i++){ int u,v; read(u,v); e[u].pb(v); e[v].pb(u); } dfs1(1,1); dfs2(1,1); while(q--){ int op,u,v,k; read(op,u,v); if(op==1){ a[u]=v; w[dfn[u]]=__gcd(a[u],a[fa[u]]); if(son[u]) w[dfn[son[u]]]=__gcd(a[son[u]],a[u]); }else{ read(k); printf(\"%d\\n\",query(u,v,k)); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"http://yoursite.com/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}],"author":"小凡"},{"title":"HDU - 4417 Super Mario 区间值域个数","slug":"HDU4417","date":"2020-05-16T10:48:22.000Z","updated":"2020-05-16T10:50:40.463Z","comments":true,"path":"2020/05/16/HDU4417/","link":"","permalink":"http://yoursite.com/2020/05/16/HDU4417/","excerpt":"","text":"传送门：HDU - 4417 思路分析区间小于等于K的个数，直接主席树就行了 样例输入1 10 10 0 5 2 7 5 4 3 8 7 7 2 8 6 3 5 0 1 3 1 1 9 4 0 1 0 3 5 5 5 5 1 4 6 3 1 5 7 5 7 3 样例输出Case 1: 4 0 0 3 1 2 0 1 5 1 AC代码#include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e5+10; struct node{ int l,r,sum; }tree[N * 40]; int cnt,root[N],a[N]; void ins(int l,int r,int pre,int &amp;now,int pos){ tree[++cnt]=tree[pre]; now=cnt; tree[now].sum++; if(l==r) return ; int mid=l+r>>1; if(pos&lt;=mid) ins(l,mid,tree[pre].l,tree[now].l,pos); else ins(mid+1,r,tree[pre].r,tree[now].r,pos); } int query(int l,int r,int L,int R,int x,int y){ if(l>=x &amp;&amp; r&lt;=y) return tree[R].sum-tree[L].sum; int mid=l+r>>1; int ans=0; if(x&lt;=mid) ans+=query(l,mid,tree[L].l,tree[R].l,x,y); if(y>mid) ans+=query(mid+1,r,tree[L].r,tree[R].r,x,y); return ans; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; read(t); int time=0; while(t--){ int n,m; read(n,m); cnt=0; vector&lt;int>x; for(int i=1;i&lt;=n;i++) read(a[i]),x.pb(a[i]); sort(all(x)); x.erase(unique(all(x)),x.end()); for(int i=1;i&lt;=n;i++) a[i]=lower_bound(all(x),a[i])-x.begin()+1; int tot=sz(x); for(int i=1;i&lt;=n;i++) ins(1,tot,root[i-1],root[i],a[i]); printf(\"Case %d:\\n\",++time); while(m--){ int l,r,k; read(l,r,k); l++; r++; k=upper_bound(all(x),k)-x.begin(); if(!k) cout&lt;&lt;0&lt;&lt;endl; else printf(\"%d\\n\",query(1,tot,root[l-1],root[r],1,k)); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"主席树","slug":"主席树","permalink":"http://yoursite.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}],"author":"小凡"},{"title":"CodeForces-1353F Decreasing Heights","slug":"CF1353F","date":"2020-05-15T07:10:18.000Z","updated":"2020-05-15T07:14:01.925Z","comments":true,"path":"2020/05/15/CF1353F/","link":"","permalink":"http://yoursite.com/2020/05/15/CF1353F/","excerpt":"","text":"传送门：CodeForces-1353F 思路分析对于每一条路径，一定有一个点作为基准，这个点的值不会改变，通过改变其他的值来使这条路径满足，这个可以通过反证法得到。那么枚举每一个点作为基准时的最下花费进行DP，可以先把每个点的值减去到起点的曼哈顿距离方便计算 样例输入5 3 4 1 2 3 4 5 6 7 8 9 10 11 12 5 5 2 5 4 8 3 9 10 11 5 1 12 8 4 2 5 2 2 5 4 1 6 8 2 4 2 2 2 100 10 10 1 1 2 123456789876543 987654321234567 1 1 42 样例输出9 49 111 864197531358023 0 AC代码#include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; int n,m; ll a[111][111],dp[111][111]; ll gao(ll x){ for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=m;j++) dp[i][j]=1e18; dp[1][1]=a[1][1]-x; if(dp[1][1]&lt;0) return 1e18; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ if(i==1&amp;&amp;j==1) continue; if(a[i][j]>=x) dp[i][j]=min(dp[i-1][j],dp[i][j-1])+a[i][j]-x; } } return dp[n][m]; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; read(t); while(t--){ read(n,m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) read(a[i][j]),a[i][j]-=i+j; ll ans=1e18; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) ans=min(ans,gao(a[i][j])); printf(\"%lld\\n\",ans); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"CodeForces-1342E Placing Rooks","slug":"CF1342E","date":"2020-05-14T08:08:29.000Z","updated":"2020-05-14T08:13:23.154Z","comments":true,"path":"2020/05/14/CF1342E/","link":"","permalink":"http://yoursite.com/2020/05/14/CF1342E/","excerpt":"","text":"传送门：CodeForces-1342E 思路分析要攻击全部格子，所以每一行都至少有一个，要有k对互相攻击，也就是放在n-k列里面那么这样就转化为第二类斯特林数的问题，但是盒子是不同的，所以要乘上全排列，行列如果不同可以互换 样例输入1337 42样例输出807905441AC代码#include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int mod = 998244353; const int N = 2e5+10; ll fac[N],invfac[N]; ll qpow(ll x, int n) { ll res = 1; while(n) { if(n&amp;1) res = res * x % mod; x = x * x % mod; n /= 2; } return res; } void init() { fac[0]=invfac[0]=1; for(int i=1; i&lt;N; i++) { fac[i]=fac[i-1]*i%mod; invfac[i]=qpow(fac[i],mod-2); } } ll comb(int n,int m) { if(m>n) return 0; return fac[n]*invfac[m]%mod*invfac[n-m]%mod; } ll sestl(int n,int m){ ll ans=0; for(int i=0;i&lt;=m;i++) ans=(ans+(i%2?-1:1)*comb(m,i)*qpow(m-i,n)%mod+mod)%mod; ans=ans*invfac[m]%mod; return ans; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif ll n,k; read(n,k); ll ans=0; if(k&lt;n) { init(); k=n-k; ans=sestl(n,k)*fac[k]%mod; if(n!=k) ans=2*ans*comb(n,k)%mod; } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"author":"小凡"},{"title":"组合数学模板","slug":"combmath","date":"2020-05-14T07:35:50.000Z","updated":"2020-05-31T08:06:33.467Z","comments":true,"path":"2020/05/14/combmath/","link":"","permalink":"http://yoursite.com/2020/05/14/combmath/","excerpt":"","text":"快速幂ll qpow(ll x, int n) { ll res = 1; while(n) { if(n&amp;1) res = res * x % mod; x = x * x % mod; n /= 2; } return res; } 组合数void getC(int maxn) { C[0][0] = 1; for(int i=1; i&lt;=maxn; i++) { C[i][0] = 1; for(int j=1; j&lt;=i; j++) C[i][j] = C[i-1][j]+C[i-1][j-1]; } } ll comb(int n,int m) { if(m>n) return 0; return fac[n]*invfac[m]%mod*invfac[n-m]%mod; } 阶乘和逆元 void init(int maxn) { fac[0]=invfac[0]=1; for(int i=1; i&lt;=maxn; i++) fac[i]=fac[i-1]*i%mod; invfac[maxn]=qpow(fac[maxn],mod-2)%mod; for(int i=maxn-1;i>=0;i--) invfac[i]=invfac[i+1]*(i+1)%mod; inv[1]=1; for(int i=2;i&lt;=maxn;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod; } 第一类斯特林数 把$n$个不同的元素构成$m$个圆排列的方案数，写作$s(n,m)$递推式： $s(n,m)=s(n-1,m-1)+s(n-1,m)*(n-1)$ 第二类斯特林数 把$n$个不同的球，放进$m$个不同的盒子，不能有空盒子的方案数，写作$S(n,m)$递推式：$S(n,m)=S(n-1,m-1)+S(n-1,m)*m$ 容斥原理快速求单项 ll sestl(int n,int m){ ll ans=0; for(int i=0;i&lt;=m;i++) ans=(ans+(i%2?-1:1)*comb(m,i)*qpow(m-i,n)%mod+mod)%mod; ans=ans*invfac[m]%mod; return ans; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"author":"小凡"},{"title":"CodeForces-1350E Orac and Game of Life","slug":"CF1350E","date":"2020-05-13T09:12:55.000Z","updated":"2020-05-13T09:15:08.082Z","comments":true,"path":"2020/05/13/CF1350E/","link":"","permalink":"http://yoursite.com/2020/05/13/CF1350E/","excerpt":"","text":"传送门：CodeForces-1350E 思路分析每一个好的点，不会变坏，坏的点变好之后也不会变坏了所以用bfs预处理出每一个点变好的时间，然后根据时间差来判断就行了 样例输入3 3 3 000 111 000 1 1 1 2 2 2 3 3 3 样例输出1 1 1AC代码#include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) #define int long long namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1010; int n,m,k; int a[N][N],dis[N][N],vis[N][N]; int dx[4]= {0,0,1,-1},dy[4]= {1,-1,0,0}; bool judge(int x,int y) { for(int i=0; i&lt;4; i++) { int nx=x+dx[i]; int ny=y+dy[i]; if(nx&lt;1||ny&lt;1||nx>n||ny>m) continue; if(a[nx][ny]==a[x][y]) return true; } return false; } signed main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n>>m>>k; for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=m; j++) { char x; cin>>x; a[i][j]=x-'0'; } } queue&lt;pair&lt;int,int>>q; for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=m; j++) { if(judge(i,j)) { q.push(mp(i,j)); dis[i][j]=0; vis[i][j]=1; } } } while(!q.empty()) { auto u=q.front(); q.pop(); int x=u.fi; int y=u.se; for(int i=0; i&lt;4; i++) { int nx=x+dx[i]; int ny=y+dy[i]; if(nx&lt;1||ny&lt;1||nx>n||ny>m||vis[nx][ny]) continue; dis[nx][ny]=dis[x][y]+1; vis[nx][ny]=1; q.push(mp(nx,ny)); } } while(k--){ int x,y,p; cin>>x>>y>>p; if(vis[x][y]){ if(p&lt;=dis[x][y] || (p-dis[x][y])%2==0) cout&lt;&lt;a[x][y]&lt;&lt;endl; else cout&lt;&lt;(a[x][y]^1)&lt;&lt;endl; }else{ cout&lt;&lt;a[x][y]&lt;&lt;endl; } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"http://yoursite.com/tags/BFS/"}],"author":"小凡"},{"title":"牛客 - 杀树","slug":"nk205037","date":"2020-05-04T14:58:06.000Z","updated":"2020-05-04T15:13:48.491Z","comments":true,"path":"2020/05/04/nk205037/","link":"","permalink":"http://yoursite.com/2020/05/04/nk205037/","excerpt":"","text":"传送门：牛客 - 杀树 思路分析设$dp[i][j]$表示以$i$为根的子树中链长不超过$j$的最小代价那么$dp[i][0]$表示删除该节点状态转移： $dp[u][0]=$$\\sum_{v=son_u}$ $dp[v][k-1]$，保证其子树也一定满足条件 考虑保留这个点，对于一个树的最长链，可能又一颗子树的最长链+根+另一个子树的最长链，我们可以枚举$j$，那么我们可以得出只能有一个子树可以为$j-1$，其余的子树必须取$min(j-1,k-j-1)$以保证不会超过$k$，枚举那一棵子树选$j-1$来转移 样例输入5 2 1 2 3 4 2 1 3 2 3 3 4 4 5 样例输出5AC代码 #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 5050; int dp[N][N],a[N],tmp[N],n,k; vector&lt;int>e[N]; void dfs(int u,int fa){ dp[u][0]=a[u]; for(auto v:e[u]){ if(v==fa) continue; dfs(v,u); dp[u][0]+=dp[v][k-1]; } for(int i=1;i&lt;k;i++){ int tmp=0; for(auto v:e[u]) if(v!=fa) tmp+=dp[v][min(i-1,k-i-1)]; dp[u][i]=tmp; for(auto v:e[u]) if(v!=fa) dp[u][i]=min(dp[u][i],tmp-dp[v][min(i-1,k-i-1)]+dp[v][i-1]); dp[u][i]=min(dp[u][i-1],dp[u][i]); } } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif read(n,k); for(int i=1;i&lt;=n;i++) read(a[i]); for(int i=1;i&lt;n;i++){ int u,v; read(u,v); e[u].pb(v); e[v].pb(u); } dfs(1,1); cout&lt;&lt;dp[1][k-1]&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"小凡"},{"title":"CodeForces-1348E Phoenix and Berries","slug":"CF1348E","date":"2020-05-04T09:39:47.000Z","updated":"2020-05-04T09:55:58.583Z","comments":true,"path":"2020/05/04/CF1348E/","link":"","permalink":"http://yoursite.com/2020/05/04/CF1348E/","excerpt":"","text":"传送门：CodeForces-1348E 思路分析设dp[i][j]表示到第i棵树，剩了j个红色的最大筐数，蓝色的数量可以通过红色计算出来枚举dp[i-1][j]来更新状态，对于当前树有两种情况： 选择放进同树筐内，枚举s表示放s个红色 不放同树筐 具体转移见代码部分 这题比较毒瘤卡了ll取模 样例输入2 5 2 1 1 3样例输出0AC代码 #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 555; ll dp[N][N],a[N],b[N]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,k; read(n,k); for(int i=1;i&lt;=n;i++) read(a[i],b[i]); mem(dp,-1); dp[0][0]=0; ll sum=0; for(int i=1;i&lt;=n;i++){ sum+=a[i]+b[i]; for(int j=0;j&lt;k;j++){ if(dp[i-1][j]&lt;0) continue; for(int s=1;s&lt;k&amp;&amp;s&lt;=a[i];s++){ if(k-s>b[i]) continue; int sum1=j+a[i]-s; int sum2=sum-dp[i-1][j]*k-k-sum1; dp[i][sum1%k]=max(dp[i][sum1%k],dp[i-1][j]+sum1/k+sum2/k+1); } int sum1=j+a[i]; int sum2=sum-dp[i-1][j]*k-sum1; dp[i][sum1%k]=max(dp[i][sum1%k],dp[i-1][j]+sum1/k+sum2/k); } } ll ans=0; for(int j=0;j&lt;k;j++) ans=max(dp[n][j],ans); cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"牛客 - 王国","slug":"nk205899","date":"2020-05-04T06:06:54.000Z","updated":"2020-05-04T06:13:19.974Z","comments":true,"path":"2020/05/04/nk205899/","link":"","permalink":"http://yoursite.com/2020/05/04/nk205899/","excerpt":"","text":"传送门：牛客 - 王国 思路分析直接算每种势力的最大贡献不难发现，距离最长的两个点，其中一个一定是深度最大的 样例输入7 1 1 2 3 3 3 1 1 2 1 3 2 4 2 5 3 6 1 7 样例输出16AC代码#include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e5+10; int a[N]; vector&lt;int>e[N],v[N]; int fa[N],dep[N],son[N],siz[N],top[N]; void dfs1(int u,int f){ dep[u]=dep[f]+1; fa[u]=f; siz[u]=1; int maxsize=-1; for(auto v:e[u]){ if(v==f) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]>maxsize){ son[u]=v; maxsize=siz[v]; } } } void dfs2(int u,int t){ top[u]=t; if(!son[u]) return ; dfs2(son[u],t); for(auto v:e[u]){ if(v==son[u]||v==fa[u]) continue; dfs2(v,v); } } int lca(int x,int y){ while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; } return dep[x]>dep[y]?y:x; } int dis(int x,int y){ return dep[x]+dep[y]-2*dep[lca(x,y)]; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; read(n); for(int i=1;i&lt;=n;i++) read(a[i]),v[a[i]].pb(i); for(int i=1;i&lt;n;i++){ int u,v; read(u,v); e[u].pb(v); e[v].pb(u); } dfs1(1,1); dfs2(1,1); int ans=0; for(int i=1;i&lt;=n;i++){ if(sz(v[i])>1){ sort(all(v[i]),[](int a,int b){ return dep[a]>dep[b]; }); for(int j=1;j&lt;sz(v[i]);j++) ans=max(ans,dis(v[i][0],v[i][j])); } } cout&lt;&lt;ans*ans*1LL&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"http://yoursite.com/tags/LCA/"}],"author":"小凡"},{"title":"牛客 - 智乃与无意义的题目","slug":"nk205837","date":"2020-05-03T08:16:09.000Z","updated":"2020-05-03T08:17:54.445Z","comments":true,"path":"2020/05/03/nk205837/","link":"","permalink":"http://yoursite.com/2020/05/03/nk205837/","excerpt":"","text":"传送门：牛客 - 智乃与无意义的题目 思路分析只需要维护区间积中素数因子的个数就行了代码写的有点丑 样例输入5 3 1 2 3 4 5 2 1 5 1 1 2 2 1 5 样例输出16 20 AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); #define int long long using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int mod=998244353; const int N=1e5+5; int a[N]; struct node { int l,r,mid,sum; vector&lt;int>pr; } tree[N&lt;&lt;2]; void pp(int x) { for(int i=0; i&lt;8; i++) { if(tree[ls].pr[i]==0 || tree[rs].pr[i]==0) tree[x].pr[i]=max(tree[ls].pr[i],tree[rs].pr[i])%mod; else tree[x].pr[i]=(tree[ls].pr[i]+tree[rs].pr[i])%mod; } } void build(int x,int l,int r) { tree[x].l=l; for(int i=0; i&lt;8; i++) tree[x].pr.push_back(0); tree[x].r=r; tree[x].mid=l+r>>1; if(l==r) { int temp=a[l]; while(temp%2==0) { tree[x].pr[2]++; temp/=2; } while(temp%3==0) { tree[x].pr[3]++; temp/=3; } while(temp%5==0) { tree[x].pr[5]++; temp/=5; } while(temp%7==0) { tree[x].pr[7]++; temp/=7; } if(temp>1) tree[x].pr[temp]++; return ; } int mid=tree[x].mid; build(ls,l,mid); build(rs,mid+1,r); pp(x); } void update(int x,int val,int pos) { if(tree[x].l==pos &amp;&amp; tree[x].r==pos) { int temp=val; for(int i=0; i&lt;8; i++) tree[x].pr[i]=0; while(temp%2==0) { tree[x].pr[2]++; temp/=2; } while(temp%3==0) { tree[x].pr[3]++; temp/=3; } while(temp%5==0) { tree[x].pr[5]++; temp/=5; } while(temp%7==0) { tree[x].pr[7]++; temp/=7; } if(temp>1) tree[x].pr[temp]++; return ; } int mid=tree[x].mid; if(pos&lt;=mid) update(ls,val,pos); if(pos>mid) update(rs,val,pos); pp(x); } node query(int x,int l,int r) { if(l&lt;=tree[x].l&amp;&amp;tree[x].r&lt;=r) return tree[x]; int mid=tree[x].mid; if(r&lt;=mid) return query(ls,l,r); if(l>mid) return query(rs,l,r); else if(l&lt;=mid &amp;&amp; r>mid) { node lson=query(ls,l,r); node rson=query(rs,l,r); node ans; ans.sum=lson.sum*rson.sum%mod; vector&lt;int>now; for(int i=0; i&lt;8; i++) now.push_back(0); for(int i=0; i&lt;8; i++) { if(lson.pr[i]==0 || rson.pr[i]==0) now[i]=max(lson.pr[i],rson.pr[i])%mod; else now[i]=(lson.pr[i]+rson.pr[i])%mod; } ans.pr=now; return ans; } } signed main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,q; scanf(\"%lld%lld\",&amp;n,&amp;q); for(int i=1; i&lt;=n; i++) scanf(\"%lld\",&amp;a[i]); build(1,1,n); while(q--) { int op; int l,r; scanf(\"%lld%lld%lld\",&amp;op,&amp;l,&amp;r); if(op==1) { update(1,r,l); } else { node now=query(1,l,r); ll ans=1; for(int i=0;i&lt;8;i++) ans=(ans*(now.pr[i]+1))%mod; printf(\"%lld\\n\",ans); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"author":"小凡"},{"title":"Atcoder - 165F Lis on Tree","slug":"atc165F","date":"2020-05-03T08:12:00.000Z","updated":"2020-05-03T08:14:32.780Z","comments":true,"path":"2020/05/03/atc165F/","link":"","permalink":"http://yoursite.com/2020/05/03/atc165F/","excerpt":"","text":"传送门：Atcoder - 165F 思路分析回溯的时候删除该点的贡献就行了，然后就是用线段树优化lis的过程了 样例输入10 1 2 5 3 4 6 7 3 2 4 1 2 2 3 3 4 4 5 3 6 6 7 1 8 8 9 9 10 样例输出1 2 3 3 4 4 5 2 2 3 AC代码#include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 2e5+10; struct node { int l,r,mid,ma; } tree[N&lt;&lt;2]; int a[N],ans[N]; vector&lt;int>e[N]; int n; void pp(int x) { tree[x].ma=max(tree[ls].ma,tree[rs].ma); } void build(int x,int l,int r) { tree[x]= {l,r,l+r>>1,0}; if(l==r) { return ; } int mid=tree[x].mid; build(ls,l,mid); build(rs,mid+1,r); } void modify(int x,int pos,int k) { if(tree[x].l==pos &amp;&amp; tree[x].r==pos) { tree[x].ma=k; return ; } int mid=tree[x].mid; if(pos&lt;=mid) modify(ls,pos,k); if(pos>mid) modify(rs,pos,k); pp(x); } int query(int x,int l,int r) { if(l&lt;=tree[x].l&amp;&amp;tree[x].r&lt;=r) { return tree[x].ma; } int mid=tree[x].mid; int res=0; if(l&lt;=mid) res=max(res,query(ls,l,r)); if(r>mid) res=max(res,query(rs,l,r)); return res; } void dfs(int u,int fa) { int now=a[u]; int sum=query(1,1,now-1)+1; int pre=query(1,now,now); modify(1,now,max(sum,pre)); ans[u]=query(1,1,n+5); for(auto v:e[u]) { if(v==fa) continue; dfs(v,u); } modify(1,now,pre); } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif read(n); vector&lt;int>b; for(int i=1; i&lt;=n; i++) { read(a[i]); b.pb(a[i]); } sort(all(b)); b.erase(unique(all(b)),b.end()); for(int i=1; i&lt;=n; i++) a[i]=lower_bound(all(b),a[i])-b.begin()+2; for(int i=1; i&lt;n; i++) { int u,v; read(u,v); e[u].pb(v); e[v].pb(u); } build(1,1,n+5); dfs(1,1); for(int i=1; i&lt;=n; i++) cout&lt;&lt;ans[i]&lt;&lt;\"\\n\"; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"author":"小凡"},{"title":"CodeForces-1016C Vasya And The Mushrooms","slug":"CF1016C","date":"2020-05-01T07:19:48.000Z","updated":"2020-05-01T07:24:45.505Z","comments":true,"path":"2020/05/01/CF1016C/","link":"","permalink":"http://yoursite.com/2020/05/01/CF1016C/","excerpt":"","text":"传送门：CodeForces-1016C 思路分析实际上路径只会是一段上下+顺时针或逆时针转一圈预处理出每列开始顺时针逆时针的贡献，然后枚举上下走的部分 样例输入3 1 2 3 6 5 4 样例输出70AC代码#include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 3e5+10; ll a[2][N],suf[2][N],s[N]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; read(n); for(int i=0; i&lt;2; i++) for(int j=1; j&lt;=n; j++) read(a[i][j]); for(int i=n; i>=1; i--) s[i]=s[i+1]+a[0][i]+a[1][i]; int ch=n; for(int i=n; i>=1; i--) { suf[0][i]=suf[0][i+1]+a[0][i]*(i-1)+a[1][i]*ch; ch++; } ch=n; for(int i=n; i>=2; i--) { suf[1][i]=suf[1][i+1]+a[1][i]*i+a[0][i]*(ch+1); ch++; } ll sum=0; ll ans=0; ll cnt=0; for(int i=1; i&lt;=n; i++) { if(i&amp;1) ans=max(ans,sum+suf[0][i]+s[i]*(i-1)); else ans=max(ans,sum+suf[1][i]+s[i]*(i-2)); sum+=a[(i+1)%2][i]*cnt; cnt++; sum+=a[i%2][i]*cnt; cnt++; } ans=max(ans,sum); cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"}],"author":"小凡"},{"title":"CodeForces-1248C Ivan the Fool","slug":"CF1248C","date":"2020-04-30T12:15:16.000Z","updated":"2020-04-30T12:19:56.480Z","comments":true,"path":"2020/04/30/CF1248C/","link":"","permalink":"http://yoursite.com/2020/04/30/CF1248C/","excerpt":"","text":"传送门：CodeForces-1248C 思路分析只考虑$1×m$的情况，很容易推出$dp[i]=dp[i-1]+dp[i-2]$有两种情况： 如果一行里有一对相邻了，那么第二行的状态一定与第一行完全相反，所以只要确定第一行，就能确定所有，这个状态的贡献为$dp[m]-2$，减去的两个贡献是010101和101010这种黑白相间的 黑白相间的情况，很容易推出，第二行要么完全相同，要么完全不同，所以对于这种情况只需要看每一行第一个是什么，也就是$dp[n]$ 所以最后的答案就是$dp[n]+dp[m]-2$ 样例输入2 3 样例输出8AC代码 #include &lt;ext/pb_ds/assoc_container.hpp> #include &lt;ext/pb_ds/tree_policy.hpp> #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; using namespace __gnu_pbds; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); typedef tree&lt;int, null_type, less&lt;int>, rb_tree_tag, tree_order_statistics_node_update> rbtree; const int INF = 0x3f3f3f3f; const int mod= 1e9+7; const int N = 1e5+10; ll dp[N]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif dp[1]=2; dp[2]=4; int n,m; read(n,m); for(int i=3;i&lt;N;i++) dp[i]=(dp[i-1]+dp[i-2])%mod; cout&lt;&lt;(dp[n]+dp[m]-2+mod)%mod&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"计数DP","slug":"计数DP","permalink":"http://yoursite.com/tags/%E8%AE%A1%E6%95%B0DP/"}],"author":"小凡"},{"title":"CodeForces-1251D Salary Changing","slug":"CF1251D","date":"2020-04-30T09:24:44.000Z","updated":"2020-04-30T09:27:21.698Z","comments":true,"path":"2020/04/30/CF1251D/","link":"","permalink":"http://yoursite.com/2020/04/30/CF1251D/","excerpt":"","text":"传送门：CodeForces-1251D 思路分析二分中位数是哪个将所有人按l排序，从最后开始枚举，贪心的分发工资 样例输入3 3 26 10 12 1 4 10 11 1 1337 1 1000000000 5 26 4 4 2 4 6 8 5 6 2 7 样例输出11 1337 6AC代码#include &lt;ext/pb_ds/assoc_container.hpp> #include &lt;ext/pb_ds/tree_policy.hpp> #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) #define int long long namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; using namespace __gnu_pbds; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); typedef tree&lt;int, null_type, less&lt;int>, rb_tree_tag, tree_order_statistics_node_update> rbtree; const int INF = 0x3f3f3f3f; const int N=2e5+10; pair&lt;int,int>a[N]; signed main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; read(t); while(t--){ int n,s; read(n,s); for(int i=1;i&lt;=n;i++) read(a[i].first,a[i].second); sort(a+1,a+1+n); int l=0,r=s+1; int ans; while(r>=l){ int mid=l+r>>1; int cnt=0; int sum=0; for(int i=n;i>=1;i--){ if(a[i].second>=mid &amp;&amp; cnt&lt;(n+1)/2){ cnt++; sum+=max(mid,a[i].first); }else{ sum+=a[i].first; } } if(cnt==(n+1)/2 &amp;&amp; sum&lt;=s) { ans=mid; l=mid+1; }else{ r=mid-1; } } printf(\"%lld\\n\",ans); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"}],"author":"小凡"},{"title":"CodeForces-1343F Restore the Permutation","slug":"CF1343F","date":"2020-04-29T15:40:08.000Z","updated":"2020-04-29T15:48:12.180Z","comments":true,"path":"2020/04/29/CF1343F/","link":"","permalink":"http://yoursite.com/2020/04/29/CF1343F/","excerpt":"","text":"传送门：CodeForces-1343F 思路分析枚举以每一个数字为开头的可能情况确定首数字之后，第二个也就能确定了，这样就逐渐确定了所有的最后$n^2$枚举所有可能集合，判断时候合法 样例输入5 6 3 2 5 6 2 4 6 3 1 3 4 2 1 3 4 1 2 4 6 5 2 2 3 2 1 2 2 1 4 2 4 5 7 3 1 2 6 4 1 3 5 6 2 1 2 3 4 5 7 6 1 2 3 4 5 6 3 1 3 6 2 2 1 2 5 2 2 5 3 2 3 5 4 2 3 4 5 5 1 2 3 4 5 样例输出3 1 4 6 2 5 3 2 1 4 5 2 1 6 3 5 4 7 1 2 2 5 3 4 1 AC代码#include &lt;ext/pb_ds/assoc_container.hpp> #include &lt;ext/pb_ds/tree_policy.hpp> #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; using namespace __gnu_pbds; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); typedef tree&lt;int, null_type, less&lt;int>, rb_tree_tag, tree_order_statistics_node_update> rbtree; const int INF = 0x3f3f3f3f; int n; vector&lt;set&lt;int>>s,tmp; bool judge(vector&lt;int>x) { set&lt;set&lt;int> > all; for(auto x:s) all.insert(x); for(int r=1; r&lt;n; r++) { set&lt;int>now; for(int l=r; l>=0; l--) { now.insert(x[l]); if(all.count(now)) { all.erase(now); break; } } } if(!all.empty()) return false; else return true; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; read(t); while(t--) { read(n); s.clear(); for(int i=1; i&lt;=n-1; i++) { set&lt;int>w; int m; read(m); while(m--) { int x; read(x); w.insert(x); } s.push_back(w); } vector&lt;int>ans; for(int i=1; i&lt;=n; i++) { int now=i; int ok=1; tmp=s; while(ans.size()&lt;n) { int cnt=0; ans.push_back(now); for(int j=0; j&lt;n-1; j++) if(tmp[j].count(now)) tmp[j].erase(now); for(int j=0; j&lt;n-1; j++) if(tmp[j].size()==1) cnt++; if(cnt!=1) { ok=0; break; } for(int j=0; j&lt;n-1; j++) if(tmp[j].size()==1) now=*tmp[j].begin(); } if(ans.size()==n &amp;&amp; judge(ans)) break; if(!ok) ans.clear(); } for(auto x:ans) cout&lt;&lt;x&lt;&lt;\" \"; cout&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"}],"author":"小凡"},{"title":"CodeForces-1245D Shichikuji and Power Grid","slug":"CF1245D","date":"2020-04-29T10:48:00.000Z","updated":"2020-04-29T10:50:36.294Z","comments":true,"path":"2020/04/29/CF1245D/","link":"","permalink":"http://yoursite.com/2020/04/29/CF1245D/","excerpt":"","text":"传送门：CodeForces-1245D 思路分析建立超级点与每个点连边，边权为$c_i$每个点两两连边，跑一遍最小生成树就行了 样例输入3 2 3 1 1 3 2 3 2 3 3 2 3 样例输出8 3 1 2 3 0 AC代码#include &lt;ext/pb_ds/assoc_container.hpp> #include &lt;ext/pb_ds/tree_policy.hpp> #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) #define int long long namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; using namespace __gnu_pbds; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); typedef tree&lt;int, null_type, less&lt;int>, rb_tree_tag, tree_order_statistics_node_update> rbtree; const int INF = 0x3f3f3f3f; const int N = 2010; struct node{ int x,y,k,c; }a[N]; struct edge{ int u,v,w; }e[N*N*2]; int f[N]; int find(int x){ return f[x]==x?x:f[x]=find(f[x]); } int dis(int x,int y){ return abs(a[x].x-a[y].x)+abs(a[x].y-a[y].y); } int cmp(edge x,edge y){ return x.w&lt;y.w; } signed main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; read(n); int cnt=0; for(int i=1;i&lt;=n;i++) read(a[i].x,a[i].y); for(int i=0;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=n;i++) { read(a[i].c); e[++cnt]={0,i,a[i].c}; } for(int i=1;i&lt;=n;i++) read(a[i].k); for(int i=1;i&lt;=n;i++){ for(int j=i+1;j&lt;=n;j++){ e[++cnt]={i,j,(a[i].k+a[j].k)*dis(i,j)}; } } sort(e+1,e+1+cnt,cmp); int use=0,sum=0; vector&lt;int>dian; vector&lt;pair&lt;int,int>>road; for(int i=1;i&lt;=cnt;i++){ int u=e[i].u; int v=e[i].v; int w=e[i].w; int t1=find(u); int t2=find(v); if(t1!=t2){ f[t2]=t1; sum+=w; use++; if(u==0) dian.push_back(v); else road.push_back(mp(u,v)); if(use==n) break; } } cout&lt;&lt;sum&lt;&lt;endl; cout&lt;&lt;dian.size()&lt;&lt;endl; for(auto x:dian) cout&lt;&lt;x&lt;&lt;\" \"; cout&lt;&lt;endl; cout&lt;&lt;road.size()&lt;&lt;endl; for(auto x:road) cout&lt;&lt;x.fi&lt;&lt;\" \"&lt;&lt;x.se&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}],"author":"小凡"},{"title":"CodeForces-1256F Equalizing Two Strings","slug":"CF1256F","date":"2020-04-29T08:40:35.000Z","updated":"2020-04-29T08:44:36.674Z","comments":true,"path":"2020/04/29/CF1256F/","link":"","permalink":"http://yoursite.com/2020/04/29/CF1256F/","excerpt":"","text":"传送门：CodeForces-1256F 思路分析如果两个串字符集不同那么一定不行如果两个串能变成一样的，都变成有序肯定一样接下来就看冒泡排序的次数了，如果其中一个串有一个字符大于2个，就不用看次数了，因为他可以一直翻转自身来增加次数否则的话就看次数的奇偶性了 样例输入4 4 abcd abdc 5 ababa baaba 4 asdf asdg 4 abcd badc 样例输出NO YES NO YESAC代码#include &lt;ext/pb_ds/assoc_container.hpp> #include &lt;ext/pb_ds/tree_policy.hpp> #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; using namespace __gnu_pbds; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); typedef tree&lt;int, null_type, less&lt;int>, rb_tree_tag, tree_order_statistics_node_update> rbtree; const int INF = 0x3f3f3f3f; int n; string s,t; map&lt;int,int>a,b; bool solve(){ a.clear(); b.clear(); for(auto i:s) a[i-'a']++; for(auto i:t) b[i-'a']++; for(int i=0;i&lt;26;i++) if(a[i]!=b[i]) return false; for(int i=0;i&lt;26;i++) if(a[i]>1||b[i]>1) return true; int cnt1=0,cnt2=0; for(int i=0;i&lt;n;i++){ for(int j=i+1;j&lt;n;j++){ if(s[j]>s[i]) cnt1++,swap(s[j],s[i]); if(t[j]>t[i]) cnt2++,swap(t[j],t[i]); } } if(cnt1%2==cnt2%2) return true; else return false; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int T; cin>>T; while(T--){ cin>>n; cin>>s>>t; cout&lt;&lt;(solve()?\"YES\":\"NO\")&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"}],"author":"小凡"},{"title":"CodeForces-1256E Yet Another Division","slug":"CF1256E","date":"2020-04-29T08:06:10.000Z","updated":"2020-04-29T08:10:28.402Z","comments":true,"path":"2020/04/29/CF1256E/","link":"","permalink":"http://yoursite.com/2020/04/29/CF1256E/","excerpt":"","text":"传送门：CodeForces-1256E 思路分析要使极差最小，肯定相近的在一个队，先对数组排序每个队伍的人数至少3个最多5个，因为6个以上可以分为两个队伍设dp[i]表示前i个人的最小代价枚举每一个左端点，以及队伍长度，如果能更新答案，则将左端点的位置记录在右端点上 样例输入6 1 5 12 13 2 15 样例输出7 2 2 2 1 1 2 1 AC代码#include &lt;ext/pb_ds/assoc_container.hpp> #include &lt;ext/pb_ds/tree_policy.hpp> #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; using namespace __gnu_pbds; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); typedef tree&lt;int, null_type, less&lt;int>, rb_tree_tag, tree_order_statistics_node_update> rbtree; const int INF = 0x3f3f3f3f; const int N= 2e5+10; int dp[N],l[N],ans[N]; pair&lt;int,int>a[N]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; read(n); for(int i=1; i&lt;=n; i++) read(a[i].fi),a[i].se=i; mem(dp,INF); dp[0]=0; sort(a+1,a+1+n); for(int i=1; i&lt;=n; i++) { for(int j=3; j&lt;=5 &amp;&amp; j+i-1&lt;=n; j++) { int cost=dp[i-1]+a[i+j-1].fi-a[i].fi; if(cost&lt;dp[i+j-1]) { dp[i+j-1]=cost; l[i+j-1]=i; } } } int now=n; int cnt=0; while(now) { ++cnt; for(int i=l[now]; i&lt;=now; i++) ans[a[i].se]=cnt; now=l[now]-1; } printf(\"%d %d\\n\",dp[n],cnt); for(int i=1; i&lt;=n; i++) printf(\"%d \",ans[i]); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"CodeForces-1243D 0 - 1 MST","slug":"CF1243D","date":"2020-04-29T06:16:48.000Z","updated":"2020-04-29T06:30:10.771Z","comments":true,"path":"2020/04/29/CF1243D/","link":"","permalink":"http://yoursite.com/2020/04/29/CF1243D/","excerpt":"","text":"传送门：CodeForces-1243D 思路分析显然，答案为补图中连通块的数量-1用一个set维护补图中剩余未连通的点遍历所有点，如果在set中，说明连通块数量+1然后计算包含这个点$u$的补图连通块如果set中的点$v$与$u$之间没有连边，说明在补图里他们是连通的在set里面删去这个点，最后再计算包含$v$的连通块 样例输入6 11 1 3 1 4 1 5 1 6 2 3 2 4 2 5 2 6 3 4 3 5 3 6 样例输出2 AC代码#include &lt;ext/pb_ds/assoc_container.hpp> #include &lt;ext/pb_ds/tree_policy.hpp> #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; using namespace __gnu_pbds; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); typedef tree&lt;int, null_type, less&lt;int>, rb_tree_tag, tree_order_statistics_node_update> rbtree; const int INF = 0x3f3f3f3f; const int N= 1e5+10; set&lt;int>s,e[N]; void dfs(int u){ vector&lt;int>temp; for(auto v:s) if(!e[u].count(v)) temp.push_back(v); for(auto v:temp) s.erase(v); for(auto v:temp) dfs(v); } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,m; read(n,m); for(int i=1;i&lt;=m;i++){ int u,v; read(u,v); e[u].insert(v); e[v].insert(u); } for(int i=1;i&lt;=n;i++) s.insert(i); int ans=0; for(int i=1;i&lt;=n;i++){ if(s.count(i)){ ans++; dfs(i); } } cout&lt;&lt;ans-1&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"author":"小凡"},{"title":"CodeForces-1257E The Contest","slug":"CF1257E","date":"2020-04-28T14:27:38.000Z","updated":"2020-04-28T14:39:16.241Z","comments":true,"path":"2020/04/28/CF1257E/","link":"","permalink":"http://yoursite.com/2020/04/28/CF1257E/","excerpt":"","text":"传送门：CodeForces-1257E 思路分析将每个数所在的堆标记设$dp[i][j]$表示将$i$放进第$j$堆里的最小花费 $dp[i][1]=dp[i-1][1]+1$ 因为把$i$放进第一堆的话，满足前缀，那么$i-1$肯定也在第一堆 $dp[i][2]$$=$$min(dp[i-1][1],dp[i-1][2])$$+1$ 这里没有$i-1$在第三堆，如果$i-1$在第三堆，要满足后缀，$i$必须在第三堆 $dp[i][3]$$=$$min(dp[i-1][1],$min(dp[i-1][2],dp[i-1][3])$)$$+1$ 这个就没有限制了 最后$dp[i][pos]–$，$pos$是$i$本来的位置 样例输入2 1 2 3 1 4 2 5 样例输出1 AC代码#include &lt;ext/pb_ds/assoc_container.hpp> #include &lt;ext/pb_ds/tree_policy.hpp> #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; using namespace __gnu_pbds; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); typedef tree&lt;int, null_type, less&lt;int>, rb_tree_tag, tree_order_statistics_node_update> rbtree; const int INF = 0x3f3f3f3f; const int N= 2e5+10; int dp[N][4],pos[N],a[4]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif for(int i=1; i&lt;=3; i++) read(a[i]); for(int i=1; i&lt;=3; i++) { for(int j=1; j&lt;=a[i];j++) { int x; read(x); pos[x]=i; } } int n=a[1]+a[2]+a[3]; dp[1][1]=dp[1][2]=dp[1][3]=1; dp[1][pos[1]]--; for(int i=2; i&lt;=n; i++) { dp[i][1]=dp[i-1][1]+1; dp[i][2]=min(dp[i-1][1],dp[i-1][2])+1; dp[i][3]=min(dp[i-1][1],min(dp[i-1][2],dp[i-1][3]))+1; dp[i][pos[i]]--; } cout&lt;&lt;min(dp[n][1],min(dp[n][2],dp[n][3]))&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"洛谷 - P1020 导弹拦截 （LIS）","slug":"luogu1020","date":"2020-04-28T13:34:20.000Z","updated":"2020-04-28T13:39:02.086Z","comments":true,"path":"2020/04/28/luogu1020/","link":"","permalink":"http://yoursite.com/2020/04/28/luogu1020/","excerpt":"","text":"传送门：洛谷 - P1020 思路分析第一问求最长不降序列第二问求最长严格单升序列其实把第一问反过来就是求最长上升子序列了 样例输入389 207 155 300 299 170 158 65 样例输出6 2 AC代码 #include &lt;ext/pb_ds/assoc_container.hpp> #include &lt;ext/pb_ds/tree_policy.hpp> #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; using namespace __gnu_pbds; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); typedef tree&lt;int, null_type, less&lt;int>, rb_tree_tag, tree_order_statistics_node_update> rbtree; const int INF = 0x3f3f3f3f; const int N = 1e5+10; int a[N],b[N],cnt; void add(int x,int val){ for(int i=x;i&lt;N;i+=lowbit(i)) b[i]=max(b[i],val); } int query(int x){ int ans=0; for(int i=x;i;i-=lowbit(i)) ans=max(ans,b[i]); return ans; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int x; while(read(x)) a[++cnt]=x; int ans1=0; for(int i=cnt;i>=1;i--){ int sum=query(a[i])+1; ans1=max(ans1,sum); add(a[i],sum); } mem(b,0); int ans2=0; for(int i=1;i&lt;=cnt;i++){ int sum=query(a[i]-1)+1; ans2=max(sum,ans2); add(a[i],sum); } printf(\"%d\\n%d\\n\",ans1,ans2); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"CodeForces-1257D Monster Killing Problem","slug":"CF1257D","date":"2020-04-28T12:54:47.000Z","updated":"2020-04-28T12:57:10.427Z","comments":true,"path":"2020/04/28/CF1257D/","link":"","permalink":"http://yoursite.com/2020/04/28/CF1257D/","excerpt":"","text":"传送门：CodeForces-1257D 思路分析肯定优先选择耐力值大且能力值大的设mx[i]表示耐力值大于等于i的最大能力值 样例输入2 6 2 3 11 14 1 8 2 3 2 100 1 5 3 5 100 2 3 2 30 5 90 1 样例输出5 -1AC代码#include &lt;ext/pb_ds/assoc_container.hpp> #include &lt;ext/pb_ds/tree_policy.hpp> #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; using namespace __gnu_pbds; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); typedef tree&lt;int, null_type, less&lt;int>, rb_tree_tag, tree_order_statistics_node_update> rbtree; const int INF = 0x3f3f3f3f; const int N = 2e5+10; int mx[N],a[N]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; read(t); while(t--){ int n; read(n); for(int i=1;i&lt;=n;i++) read(a[i]),mx[i]=0; int m; read(m); for(int i=1;i&lt;=m;i++){ int p,s; read(p,s); mx[s]=max(mx[s],p); } for(int i=n-1;i>=0;i--) mx[i]=max(mx[i],mx[i+1]); int ok=1; int pos=1,ans=0; while(pos&lt;=n){ ans++; int temp=pos; int ma=0; while(1){ ma=max(ma,a[temp]); if(ma>mx[temp-pos+1]) break; ++temp; } if(temp==pos) { ok=0; break; } pos=temp; } printf(\"%d\\n\",ok?ans:-1); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"}],"author":"小凡"},{"title":"CodeForces-1253E Antenna Coverage","slug":"CF1253E","date":"2020-04-28T09:44:58.000Z","updated":"2020-04-28T09:51:24.457Z","comments":true,"path":"2020/04/28/CF1253E/","link":"","permalink":"http://yoursite.com/2020/04/28/CF1253E/","excerpt":"","text":"传送门：CodeForces-1253E 思路分析设$dp[i]$表示前$1-i$已经覆盖，要覆盖$i+1$到$m$的最小花费,边界$dp[m]=0$从后往前枚举，如果$i+1$已经被覆盖，$dp[i]=dp[i+1]$，可以直接继承如果一条i小于某条线段的左端点，那么可以转移这条线段，覆盖$i-l$的代价为$cost$那么转移就是$dp[i]=$$min$$(dp[i],dp[r+cost]+cost)$ 样例输入3 595 43 2 300 4 554 10 样例输出281AC代码 #include &lt;ext/pb_ds/assoc_container.hpp> #include &lt;ext/pb_ds/tree_policy.hpp> #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; using namespace __gnu_pbds; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); typedef tree&lt;int, null_type, less&lt;int>, rb_tree_tag, tree_order_statistics_node_update> rbtree; const int INF = 0x3f3f3f3f; const int N = 1e5+10; int dp[N]; pair&lt;int,int>a[100]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,m; read(n,m); for(int i=1;i&lt;=n;i++){ int x,s; read(x,s); a[i].fi=max(0,x-s); a[i].se=min(m,x+s); } dp[m]=0; for(int i=m-1;i>=0;i--){ dp[i]=m-i; for(int j=1;j&lt;=n;j++){ int l=a[j].fi,r=a[j].se; if(i+1>=l &amp;&amp; i+1&lt;=r) { dp[i]=dp[i+1]; break; } if(i&lt;l){ int cost=(l-i-1); int rr=min(m,r+cost); dp[i]=min(dp[i],dp[rr]+cost); } } } cout&lt;&lt;dp[0]&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"CodeForces-1253D Harmonious Graph","slug":"CF1253D","date":"2020-04-28T08:10:10.000Z","updated":"2020-04-28T08:12:58.416Z","comments":true,"path":"2020/04/28/CF1253D/","link":"","permalink":"http://yoursite.com/2020/04/28/CF1253D/","excerpt":"","text":"传送门：CodeForces-1253D 思路分析如果存在l-r的路径，那么说明l-[l,r]这个区间所有点都有路径用并查集维护每一个连通块，父亲为连通块内最大的节点依次遍历点属于哪个连通块就行了 样例输入14 8 1 2 2 7 3 4 6 3 5 7 3 8 6 8 11 12 样例输出1 AC代码#include &lt;ext/pb_ds/assoc_container.hpp> #include &lt;ext/pb_ds/tree_policy.hpp> #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; using namespace __gnu_pbds; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); typedef tree&lt;int, null_type, less&lt;int>, rb_tree_tag, tree_order_statistics_node_update> rbtree; const int INF = 0x3f3f3f3f; const int N = 2e5+10; int f[N]; int find(int x){ return f[x]==x?x:f[x]=find(f[x]); } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,m; read(n,m); for(int i=1;i&lt;=n;i++) f[i]=i; while(m--){ int u,v; read(u,v); int ma=find(u); int mi=find(v); if(ma&lt;mi) swap(ma,mi); if(ma!=mi) f[mi]=ma; } int ans=0; for(int i=1;i&lt;=n;i++){ int ma=find(i); for(int j=i;j&lt;ma;j++){ int mi=find(j); if(ma&lt;mi) swap(ma,mi); if(ma!=mi){ ans++; f[mi]=ma; } i++; } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}],"author":"小凡"},{"title":"pb_ds 一个强大的黑科技","slug":"pbds","date":"2020-04-27T13:30:00.000Z","updated":"2020-04-27T13:31:50.716Z","comments":true,"path":"2020/04/27/pbds/","link":"","permalink":"http://yoursite.com/2020/04/27/pbds/","excerpt":"","text":"代码#include &lt;ext/pb_ds/tree_policy.hpp> #include &lt;ext/pb_ds/assoc_container.hpp> #include &lt;bits/stdc++.h> using namespace __gnu_pbds; using namespace std; typedef tree&lt;int, null_type, less&lt;int>, rb_tree_tag, tree_order_statistics_node_update> rbtree; /// int类型 /// null_type为映射类型, 低版本g++为 null_mapped_type /// less&lt;int>, greater&lt;int> 比较器 /// rb_tree_tag 和 splay_tree_tag 选择树的类型 /// tree_order_statistics_node_update 结点更新 /// insert, erase /// order_of_key rank /// find_by_order() kth 查询的时候要-1 /// lower_bound() 前继， >=x 最小的迭代器 /// upper_bound() 后继 >x 最小的迭代器 /// a.join(b) b并入a，前提是两颗树的取值范围不相交 /// a.split(v, b) key &lt;= v的属于a，其他属于 /// 注意，插入的元素会去重，如set document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"author":"小凡"},{"title":"CodeForces-1262D Optimal Subsequences","slug":"CF1262D","date":"2020-04-27T13:19:28.000Z","updated":"2020-04-27T13:27:10.258Z","comments":true,"path":"2020/04/27/CF1262D/","link":"","permalink":"http://yoursite.com/2020/04/27/CF1262D/","excerpt":"","text":"传送门：CodeForces-1262D 思路分析将数组按权值和ID排序题意就可以转化为取前$k$个数，在原数组上第$pos$个数是哪个将询问按k从小到大排序，前k个一定是一样的将前k个数的ID放进树状数组里，二分查找到第一个前缀和等于$pos$的位置就是答案还有一个黑科技，用红黑树维护Kth值 样例输入3 10 20 10 6 1 1 2 1 2 2 3 1 3 2 3 3 样例输出20 10 20 10 20 10 AC代码 #include &lt;ext/pb_ds/assoc_container.hpp> #include &lt;ext/pb_ds/tree_policy.hpp> #include &lt;bits/stdc++.h> #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; using namespace __gnu_pbds; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); typedef tree&lt;int, null_type, less&lt;int>, rb_tree_tag, tree_order_statistics_node_update> rbtree; const int INF = 0x3f3f3f3f; const int N = 2e5+10; int a[N],bit[N],ans[N]; rbtree Tree; struct date { int x,id; } t[N]; struct node { int k,pos,id; } q[N]; void add(int x) { for(int i=x; i&lt;N; i+=lowbit(i)) bit[i]+=1; } int query(int x) { int sum=0; for(int i=x; i; i-=lowbit(i)) sum+=bit[i]; return sum; } int cmp1(date x,date y) { if(x.x==y.x) return x.id&lt;y.id; else return x.x>y.x; } int cmp2(node x,node y) { return x.k&lt;y.k; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; read(n); for(int i=1; i&lt;=n; i++) { int x; read(x); a[i]=x; t[i].x=x; t[i].id=i; } int m; read(m); for(int i=1; i&lt;=m; i++) { read(q[i].k,q[i].pos); q[i].id=i; } sort(t+1,t+1+n,cmp1); sort(q+1,q+1+m,cmp2); int now=1; for(int i=1; i&lt;=m; i++) { //名次树 while(now&lt;=q[i].k) Tree.insert(t[now++].id); int res=*Tree.find_by_order(q[i].pos-1); ans[q[i].id]=a[res]; //二分树状数组 while(now&lt;=q[i].k) add(t[now++].id); int l=1,r=n,res=0; while(r>=l){ int mid=l+r>>1; if(query(mid)>=q[i].pos) res=mid,r=mid-1; else l=mid+1; } ans[q[i].id]=a[res]; } for(int i=1; i&lt;=m; i++) cout&lt;&lt;ans[i]&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"},{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}],"author":"小凡"},{"title":"CodeForces-1272E Nearest Opposite","slug":"CF1272E","date":"2020-04-27T07:49:36.000Z","updated":"2020-04-27T07:57:07.405Z","comments":true,"path":"2020/04/27/CF1272E/","link":"","permalink":"http://yoursite.com/2020/04/27/CF1272E/","excerpt":"","text":"传送门：CodeForces-1272E 思路分析设两个超级源点A和B将所有奇数与A连一条有向边，所有偶数与B连一条有向边，$i$和$i+a[i]$,$i-a[i]$连一条有向边那么题意可以转化为每个奇数点到达B的最短距离以及每个偶数点到达A的最短距离直接求显然不行的，所以可以建立反向边，跑两次最短路，分别以A,B为起点，就可以得到各个点到A和B的最短距离了 样例输入10 4 5 7 6 7 5 4 4 6 4 样例输出1 1 1 2 -1 1 1 3 1 1AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=2e5+10; int n; int dis[N],a[N],ans[N],vis[N]; vector&lt;int>e[N]; void spfa(int s){ mem(dis,INF); mem(vis,0); dis[s]=0; queue&lt;int>q; q.push(s); while(!q.empty()){ int u=q.front(); q.pop(); vis[u]=0; for(auto v:e[u]){ if(dis[v]>dis[u]+1 &amp;&amp; !vis[v]){ q.push(v); vis[v]=1; dis[v]=dis[u]+1; } } } } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif read(n); for(int i=1;i&lt;=n;i++) { read(a[i]); if(i-a[i]>=1) e[i-a[i]].push_back(i); if(i+a[i]&lt;=n) e[i+a[i]].push_back(i); } for(int i=1;i&lt;=n;i++) { if(a[i]&amp;1) e[0].push_back(i); else e[n+1].push_back(i); } spfa(0); for(int i=1;i&lt;=n;i++) if(a[i]%2==0) ans[i]=(dis[i]==INF?-1:dis[i]-1); spfa(n+1); for(int i=1;i&lt;=n;i++) if(a[i]&amp;1) ans[i]=(dis[i]==INF?-1:dis[i]-1); for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;\" \"; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"author":"小凡"},{"title":"CodeForces-1341E Unexpected Guest （01BFS）","slug":"CF1341E","date":"2020-04-27T06:08:10.000Z","updated":"2020-05-19T13:37:25.260Z","comments":true,"path":"2020/04/27/CF1341E/","link":"","permalink":"http://yoursite.com/2020/04/27/CF1341E/","excerpt":"","text":"传送门：CodeForces-1341E 思路分析这dis[i][j]表示表示到了第i个位置，距离上次等红灯后走了j秒所需要的最小等红绿灯次数这就是一个01BFS的问题了，如果j=g的话就需要停留，次数就要+1，将新状态放到队尾，否则将新状态放到队首没取出一个队首计算贡献，取min 样例输入15 5 0 3 7 14 15 11 11 样例输出45AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e4+10; int n,m,r,g,a[N]; int dis[N][1010],vis[N][1010]; int bfs() { int ans=INF; deque&lt;pair&lt;int,int>>q; q.push_back(mp(0,0)); vis[0][0]=1; while(!q.empty()) { auto u=q.front(); q.pop_front(); int pos=u.fi; int cost=u.se; int need=n-a[pos]+cost; if(need&lt;=g) ans=min(ans,dis[pos][cost]*(r+g)+need); if(cost==g) { if(!vis[pos][0]) { dis[pos][0]=dis[pos][g]+1; vis[pos][0]=1; q.push_back(mp(pos,0)); } continue; } if(pos>1) { int next=pos-1; int need=a[pos]-a[next]+cost; if(need&lt;=g &amp;&amp; !vis[next][need]) { dis[next][need]=dis[pos][cost]; vis[next][need]=1; q.push_front(mp(next,need)); } } if(pos&lt;m) { int next=pos+1; int need=a[next]-a[pos]+cost; if(need&lt;=g &amp;&amp; !vis[next][need]) { dis[next][need]=dis[pos][cost]; vis[next][need]=1; q.push_front(mp(next,need)); } } } return ans==INF?-1:ans; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif read(n,m); for(int i=1; i&lt;=m; i++) read(a[i]); sort(a+1,a+1+m); read(g,r); printf(\"%d\\n\",bfs()); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"http://yoursite.com/tags/BFS/"}],"author":"小凡"},{"title":"CodeForces-1341D Nastya and Scoreboard","slug":"CF1341D","date":"2020-04-26T07:15:27.000Z","updated":"2020-04-26T07:22:01.676Z","comments":true,"path":"2020/04/26/CF1341D/","link":"","permalink":"http://yoursite.com/2020/04/26/CF1341D/","excerpt":"","text":"传送门：CodeForces-1341D 思路分析当前状态可以通过加灯来转移到新的状态预处理出每个状态能转移的状态集合，可以通过枚举子集的方法实现设$dp[i][j]=0/1$表示前$i-1$个字符串加了$k$个字符能够是否组成数字倒着dp,初始dp[n+1][k]=1,如果最后dp[1][0]=0，说明不合法dp的过程其实是一个可行性背包问题$dp[i][j]|=dp[i+1][j+val]$答案贪心就行了 样例输入2 5 0010010 0010010 样例输出97AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=2e3+10; int dp[N][N]; string a[N]; int s[10]= {119,18,93,91,58,107,111,82,127,123}; vector&lt;int>ste[200]; void init() { for(int i=9; i>=0; i--) { for(int j=s[i]; j!=0; j=(j-1)&amp;s[i]) ste[j].push_back(i); ste[0].push_back(i); } } int Count(int n) { int count = 0; n=s[n]; while(n) { ++count; n = n &amp; (n - 1); } return count; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,k; cin>>n>>k; init(); for(int i=1; i&lt;=n; i++) cin>>a[i]; dp[n+1][k]=1; for(int i=n; i>=1; i--) { int sum=0,cnt=0; for(auto x:a[i]) { sum&lt;&lt;=1; sum+=x-'0'; if(x-'0'==1) cnt++; } for(auto x:ste[sum]) { int val=Count(x)-cnt; for(int j=k; j>=0; j--) dp[i][j]|=dp[i+1][j+val]; } } if(!dp[1][0]) return cout&lt;&lt;-1,0; string ans; int used=0; for(int i=1; i&lt;=n; i++) { int sum=0,cnt=0; for(auto x:a[i]) { sum&lt;&lt;=1; sum+=x-'0'; if(x-'0'==1) cnt++; } for(auto x:ste[sum]) { int val=Count(x)-cnt; if(dp[i+1][used+val]) { ans.push_back('0'+x); used+=val; break; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"背包DP","slug":"背包DP","permalink":"http://yoursite.com/tags/%E8%83%8C%E5%8C%85DP/"}],"author":"小凡"},{"title":"牛客 - 挑战赛39B 密码系统","slug":"nk5157B","date":"2020-04-26T07:01:57.000Z","updated":"2020-08-01T16:00:48.711Z","comments":true,"path":"2020/04/26/nk5157B/","link":"","permalink":"http://yoursite.com/2020/04/26/nk5157B/","excerpt":"","text":"传送门：牛客 - 挑战赛39B 思路分析处理环状问题，一般先将原串复制一倍这样每种划分方案就变成从第i个为起点后面每k个字符那么就可以处理出每一个起点所包含的字符串中字典序最大的子串判断两个字符串大小可以通过二分找到最长公共前缀来判断然后对于每一个起始位置的答案中选一个字典序最小的 样例输入4 2 baca样例输出acAC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int base= 13331; const int N=1e6+10; typedef unsigned ull; int n,k,now[N]; char s[N]; ull ha[N],ba[N]; ull get(int l,int r) { ll ans=(ha[r]-ha[l-1]*ba[r-l+1]); return ans; } int check(int x,int y){ int ans=0; int l=1,r=k; while(r>=l){ int mid=l+r>>1; if(get(x,x+mid-1)==get(y,y+mid-1)){ ans=mid; l=mid+1; }else{ r=mid-1; } } return s[x+ans]&lt;s[y+ans]; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n>>k; scanf(\"%s\",s+1); for(int i=n+1;i&lt;=n*2;i++) s[i]=s[i-n]; ba[0]=1; for(int i=1;i&lt;=n*2;i++){ ba[i]=(ba[i-1]*base); ha[i]=(ha[i-1]*base)+s[i]; } for(int i=1;i&lt;=n;i++){ if(!now[i%k]) now[i%k]=i; else if(check(now[i%k],i)) now[i%k]=i; } int ans=now[0]; for(int i=1;i&lt;k;i++) if(check(now[i],ans)) ans=now[i]; for(int i=ans;i&lt;=ans+k-1;i++) cout&lt;&lt;s[i]; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"},{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"}],"author":"小凡"},{"title":"牛客 - 练习赛62C 牛牛染颜色","slug":"nk5205C","date":"2020-04-26T06:12:39.000Z","updated":"2020-04-26T06:21:30.400Z","comments":true,"path":"2020/04/26/nk5205C/","link":"","permalink":"http://yoursite.com/2020/04/26/nk5205C/","excerpt":"","text":"传送门：牛客 - 练习赛62C 思路分析设$dp[u][0/1]$表示选不选这个节点的方案数显然 $dp[u][1]=\\prod_{v==son_u}(dp[v][0]+dp[v][1])$如果u不选的话，那么只能有一个子树能选节点每棵子树都有空集的情况，所以减去重复的空集部分显然 $dp[u][0]=1+\\sum_{v==son_u}(dp[v][1]+dp[v][0]-1)$ 样例输入4 1 2 2 3 2 4 样例输出14AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e6+10; const int mod=1e9+7; ll dp[N][2]; struct node{ int v,next; }e[N*2]; int head[N*2],cnt; void add(int u,int v){ e[++cnt].v=v; e[cnt].next=head[u]; head[u]=cnt; } void dfs(int u,int fa){ dp[u][1]=dp[u][0]=1; for(int i=head[u];i;i=e[i].next){ int v=e[i].v; if(v==fa) continue; dfs(v,u); dp[u][0]=(dp[u][0]+dp[v][0]+dp[v][1]-1)%mod; dp[u][1]=(dp[u][1]*(dp[v][1]+dp[v][0]))%mod; } } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=1;i&lt;n;i++){ int u,v; cin>>u>>v; add(u,v); add(v,u); } dfs(1,0); cout&lt;&lt;(dp[1][0]+dp[1][1])%mod&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"小凡"},{"title":"牛客 - 挑战赛39C 牛牛的等差数列","slug":"nk204829","date":"2020-04-26T05:41:02.000Z","updated":"2020-04-26T05:43:50.273Z","comments":true,"path":"2020/04/26/nk204829/","link":"","permalink":"http://yoursite.com/2020/04/26/nk204829/","excerpt":"","text":"传送门：牛客 - 挑战赛39C 思路分析一个等差数列可以分割成多个首项不同公差一样的等差数列更新的时候分段更新，下放标记的时候也是一样 样例输入4 1 1 1 1 5 1 1 1 1 0 2 1 1 3 1 1 2 1 1 2 2 2 5 2 1 2 23 样例输出2 3 6 AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); #define int long long namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=2e5+10; const int mod=3LL*5*7*11*13*17*19*23; struct node { int l,r,mid,len,lazya,lazyd,sum; } tree[N&lt;&lt;2]; int s[N]; void pp(int x) { tree[x].sum=(tree[rs].sum+tree[ls].sum)%mod; } int cal(int a,int d,int len) { return (a*len%mod+(len*(len-1)/2)*d%mod)%mod; } void build(int x,int l,int r) { tree[x]= {l,r,l+r>>1,r-l+1,0,0,0}; if(l==r) { tree[x].sum=s[l]%mod; return ; } int mid=tree[x].mid; build(ls,l,mid); build(rs,mid+1,r); pp(x); } void pd(int x) { int la=tree[x].lazya; int ld=tree[x].lazyd; if(!la &amp;&amp; !ld) return ; tree[ls].lazya=(tree[ls].lazya+la)%mod; tree[ls].lazyd=(tree[ls].lazyd+ld)%mod; int mid=tree[x].mid; tree[rs].lazya=(tree[rs].lazya+la+tree[ls].len*ld%mod)%mod; tree[rs].lazyd=(tree[rs].lazyd+ld)%mod; tree[ls].sum=(tree[ls].sum+cal(la,ld,tree[ls].len))%mod; tree[rs].sum=(tree[rs].sum+cal(la+tree[ls].len*ld%mod,ld,tree[rs].len))%mod; tree[x].lazya=0; tree[x].lazyd=0; } void modify(int x,int l,int r,int a,int d) { if(l&lt;=tree[x].l&amp;&amp;tree[x].r&lt;=r) { tree[x].sum=(tree[x].sum+cal(a,d,tree[x].len))%mod; tree[x].lazya=(tree[x].lazya+a)%mod; tree[x].lazyd=(tree[x].lazyd+d)%mod; return ; } pd(x); int mid=tree[x].mid; if(r&lt;=mid) modify(ls,l,r,a,d); else if(l>mid) { modify(rs,l,r,a,d); } else { modify(ls,l,mid,a,d); modify(rs,mid+1,r,(a+(mid-l+1)*d%mod)%mod,d); } pp(x); } int query(int x,int l,int r) { if(l&lt;=tree[x].l&amp;&amp;tree[x].r&lt;=r) { return tree[x].sum; } pd(x); int mid=tree[x].mid; int ans=0; if(l&lt;=mid) ans=(ans+query(ls,l,r))%mod; if(r>mid) ans=(ans+query(rs,l,r))%mod; return ans; } signed main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; read(n); for(int i=1; i&lt;=n; i++) read(s[i]); build(1,1,n); int q; read(q); while(q--) { int op,l,r,val,d; read(op,l,r,val); if(op==1) { read(d); modify(1,l,r,val%mod,d%mod); } else { printf(\"%lld\\n\",query(1,l,r)%val); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"author":"小凡"},{"title":"2019CCPC - Final K.Russian Dolls on the Tree","slug":"2019-CCPC-final-K","date":"2020-04-24T06:13:49.000Z","updated":"2020-04-24T06:18:16.356Z","comments":true,"path":"2020/04/24/2019-CCPC-final-K/","link":"","permalink":"http://yoursite.com/2020/04/24/2019-CCPC-final-K/","excerpt":"","text":"传送门：gym - 102431K 思路分析求子树数字集合中连续段的个数直接启发式合并就行了 样例输入1 7 1 2 2 4 2 6 1 3 3 5 3 7 样例输出Case #1: 1 3 3 1 1 1 1 AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 2e5+10; int a[N],ans[N],vis[N],sum,flag; vector&lt;int>e[N]; int siz[N],son[N]; void dfs1(int u,int fa) { siz[u]=1; for(auto v:e[u]) { if(v==fa) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]>siz[son[u]]) son[u]=v; } } void cal(int u,int fa,int keep) { vis[u]=keep; if(keep) { if(vis[u-1] &amp;&amp; vis[u+1]) sum--; else if(!vis[u-1] &amp;&amp; !vis[u+1]) sum++; } else { if(vis[u-1] &amp;&amp; vis[u+1]) sum++; else if(!vis[u-1] &amp;&amp; !vis[u+1]) sum--; } for(auto v:e[u]) if(v!=fa &amp;&amp; v!=flag) cal(v,u,keep); } void dfs2(int u,int fa,int keep) { for(auto v:e[u]) if(v!=fa &amp;&amp; v!=son[u]) dfs2(v,u,0); if(son[u]) { dfs2(son[u],u,1); flag=son[u]; } cal(u,fa,1); flag=0; ans[u]=sum; if(!keep) cal(u,fa,0); } void solve(int time) { int n; scanf(\"%d\",&amp;n); for(int i=1; i&lt;=n; i++) e[i].clear(); mem(son,0); for(int i=1; i&lt;n; i++) { int u,v; scanf(\"%d%d\",&amp;u,&amp;v); e[u].push_back(v); e[v].push_back(u); } dfs1(1,1); dfs2(1,1,0); printf(\"Case #%d: \",time); for(int i=1; i&lt;=n; i++) printf(\"%d%c\",ans[i],i==n?'\\n':' '); } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; for(int i=1; i&lt;=t; i++) solve(i); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树上启发式合并","slug":"树上启发式合并","permalink":"http://yoursite.com/tags/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"}],"author":"小凡"},{"title":"洛谷 - P2633 Count on a tree","slug":"luogu2633","date":"2020-04-23T09:06:03.000Z","updated":"2020-04-23T09:08:54.998Z","comments":true,"path":"2020/04/23/luogu2633/","link":"","permalink":"http://yoursite.com/2020/04/23/luogu2633/","excerpt":"","text":"传送门：洛谷 - P2633 思路分析跟求区间第k小一样的思路树上差分: sum[u–&gt;v] = sum[u] + sum[v] - sum[lca$(u,v)$] -sum[fa[lca$(u,v)$]] 样例输入8 5 105 2 9 3 8 5 7 7 1 2 1 3 1 4 3 5 3 6 3 7 4 8 2 5 1 0 5 2 10 5 3 11 5 4 110 8 2 样例输出2 8 9 105 7 AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e5+10; struct node { int l,r,sum; } tree[N*40]; vector&lt;int>e[N*2],b; int cnt,root[N],a[N],n,m,tot; int fa[N],dep[N],son[N],siz[N],top[N]; void ins(int l,int r,int pre,int &amp;now,int pos) { tree[++cnt]=tree[pre]; now=cnt; tree[now].sum++; if(l==r) return ; int mid=l+r>>1; if(pos&lt;=mid) ins(l,mid,tree[pre].l,tree[now].l,pos); else ins(mid+1,r,tree[pre].r,tree[now].r,pos); } int query(int l,int r,int u,int v,int l_ca,int lcafa,int k) { if(l==r) return l; int mid=l+r>>1; int temp=tree[tree[u].l].sum+tree[tree[v].l].sum-tree[tree[l_ca].l].sum-tree[tree[lcafa].l].sum; if(k&lt;=temp) return query(l,mid,tree[u].l,tree[v].l,tree[l_ca].l,tree[lcafa].l,k); else return query(mid+1,r,tree[u].r,tree[v].r,tree[l_ca].r,tree[lcafa].r,k-temp); } int getid(int x) { return lower_bound(all(b),x)-b.begin()+1; } void dfs1(int u,int f) { fa[u]=f; dep[u]=dep[f]+1; siz[u]=1; int maxsize=-1; for(auto v:e[u]) { if(v==f)continue; ins(1,tot,root[u],root[v],getid(a[v])); dfs1(v,u); siz[u]+=siz[v]; if(siz[v]>maxsize) { son[u]=v; maxsize=siz[v]; } } } void dfs2(int u,int t) { top[u]=t; if(!son[u]) return ; dfs2(son[u],t); for(auto v:e[u]) { if(v==son[u]||v==fa[u]) continue; dfs2(v,v); } } int lca(int x,int y) { while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; } return dep[x]>dep[y]?y:x; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n>>m; for(int i=1; i&lt;=n; i++) cin>>a[i],b.push_back(a[i]); for(int i=1; i&lt;n; i++) { int u,v; cin>>u>>v; e[u].push_back(v); e[v].push_back(u); } sort(all(b)); b.erase(unique(all(b)),b.end()); tot=b.size(); ins(1,tot,root[0],root[1],getid(a[1])); dfs1(1,0); dfs2(1,0); int last=0; while(m--) { int u,v,k; cin>>u>>v>>k; u^=last; int lc=lca(u,v); int ans=b[query(1,tot,root[u],root[v],root[lc],root[fa[lc]],k)-1]; cout&lt;&lt;ans&lt;&lt;endl; last=ans; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"主席树","slug":"主席树","permalink":"http://yoursite.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}],"author":"小凡"},{"title":"CodeForces-1281E Jeremy Bearimy","slug":"CF1281E","date":"2020-04-22T17:26:13.000Z","updated":"2020-04-22T17:31:02.422Z","comments":true,"path":"2020/04/23/CF1281E/","link":"","permalink":"http://yoursite.com/2020/04/23/CF1281E/","excerpt":"","text":"传送门：CodeForces-1281E 思路分析对于每条边单独计算贡献，假设u–&gt;v，u左侧有x个点，v右侧有y个点 最大：尽量让这条边用很多次，那么最多能用min$(x,y)$次 最小：让相邻的两两配对一定是最小的，如果y为奇数，那么x一定也是奇数，那么v右侧可以两两配对剩一个v，u左侧同理，所以u，v配对 样例输入2 3 1 2 3 3 2 4 2 4 3 4 5 6 5 6 5 2 1 2 1 1 3 2 1 4 3 样例输出15 33 6 6AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e6+10; vector&lt;pair&lt;ll,ll>>e[N]; ll mi,ma,n,siz[N]; void dfs(int u,int fa){ siz[u]=1; for(auto x:e[u]){ ll v=x.fi; ll w=x.se; if(v==fa) continue; dfs(v,u); siz[u]+=siz[v]; if(siz[v]&amp;1) mi+=w; ma+=min(siz[v],n-siz[v])*w; } } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; while(t--){ cin>>n; n*=2; for(int i=1;i&lt;=n;i++) e[i].clear(); for(int i=1;i&lt;n;i++){ ll u,v,w; cin>>u>>v>>w; e[u].push_back(mp(v,w)); e[v].push_back(mp(u,w)); } mi=0,ma=0; dfs(1,1); cout&lt;&lt;mi&lt;&lt;\" \"&lt;&lt;ma&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"小凡"},{"title":"CodeForces-1217D Coloring Edges （有向图判环）","slug":"CF1217D","date":"2020-04-22T11:53:45.000Z","updated":"2020-04-22T11:56:38.199Z","comments":true,"path":"2020/04/22/CF1217D/","link":"","permalink":"http://yoursite.com/2020/04/22/CF1217D/","excerpt":"","text":"传送门：CodeForces-1217D 思路分析如果没有环答案肯定是1如果有环答案一定是2因为有向图的环中，肯定存在由大指向小和由小指向大两种边所以只需要将这两种边染不同色就行了 样例输入3 3 1 2 2 3 3 1样例输出2 1 1 2AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e5+10; int a[N],b[N],in[N],n,m; vector&lt;int>e[N]; bool tp() { int cnt=0; queue&lt;int>q; for(int i=1; i&lt;=n; i++) if(in[i]==0) q.push(i); while(!q.empty()) { int u=q.front(); q.pop(); cnt++; for(auto v:e[u]) { in[v]--; if(in[v]==0) q.push(v); } } if(cnt!=n) return true; else return false; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n>>m; for(int i=1; i&lt;=m; i++) { cin>>a[i]>>b[i]; e[a[i]].push_back(b[i]); in[b[i]]++; } if(tp()) { cout&lt;&lt;2&lt;&lt;endl; for(int i=1; i&lt;=m; i++) cout&lt;&lt;(a[i]>b[i]?1:2)&lt;&lt;\" \"; } else { cout&lt;&lt;1&lt;&lt;endl; for(int i=1; i&lt;=m; i++) cout&lt;&lt;1&lt;&lt;\" \"; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://yoursite.com/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"author":"小凡"},{"title":"CodeForces-1221D Make The Fence Great","slug":"CF1221D","date":"2020-04-22T09:56:44.000Z","updated":"2020-04-22T09:59:30.435Z","comments":true,"path":"2020/04/22/CF1221D/","link":"","permalink":"http://yoursite.com/2020/04/22/CF1221D/","excerpt":"","text":"传送门：CodeForces-1221D Make The Fence Great 思路分析因为只和相邻两项比较，所以一个点最多被提升两次设dp[i][j]表示第i个位置提升j次的答案那么就可以与dp[i-1][j]来比较转移了 样例输入3 3 2 4 2 1 3 5 3 2 3 2 10 2 6 4 1 7 3 3 2 6 1000000000 2 样例输出2 9 0 AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=3e5+10; ll dp[N][3],a[N],b[N]; int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; while(t--) { int n; cin>>n; for(int i=1; i&lt;=n; i++) cin>>a[i]>>b[i]; dp[1][0]=0; dp[1][1]=b[1]; dp[1][2]=b[1]*2; for(int i=2;i&lt;=n;i++){ dp[i][0]=dp[i][1]=dp[i][2]=2e18; for(int j=0;j&lt;=2;j++){ for(int k=0;k&lt;=2;k++){ if(a[i]+k!=a[i-1]+j){ dp[i][k]=min(dp[i][k],dp[i-1][j]+k*b[i]); } } } } cout&lt;&lt;min(dp[n][0],min(dp[n][1],dp[n][2]))&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"CodeForces-1343E Weights Distributing","slug":"CF1343E","date":"2020-04-22T09:07:02.000Z","updated":"2020-04-22T09:10:40.796Z","comments":true,"path":"2020/04/22/CF1343E/","link":"","permalink":"http://yoursite.com/2020/04/22/CF1343E/","excerpt":"","text":"传送门：CodeForces-1343E 思路分析枚举中转站xa-&gt;xx-&gt;bb-&gt;xx-&gt;c 那么这样重复的部分就是x-&gt;b预处理前缀和，三次bfs计算出a，b，c到各个点的距离 样例输入2 4 3 2 3 4 1 2 3 1 2 1 3 1 4 7 9 1 5 7 2 10 4 8 5 6 7 3 3 1 2 1 3 1 4 3 2 3 5 4 2 5 6 1 7 6 7 样例输出7 12AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e6+10; vector&lt;int>e[N]; int n,m,a,b,c; ll da[N],db[N],dc[N],vis[N],val[N],s[N]; void bfs(int s,ll *dis){ for(int i=0;i&lt;=n;i++){ vis[i]=0; dis[i]=INF; } dis[s]=0; queue&lt;int>q; q.push(s); while(!q.empty()){ int u=q.front(); q.pop(); vis[u]=0; for(auto v:e[u]){ if(dis[v]>dis[u]+1 &amp;&amp; !vis[v]){ dis[v]=dis[u]+1; vis[v]=1; q.push(v); } } } } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; while(t--){ cin>>n>>m>>a>>b>>c; for(int i=1;i&lt;=n;i++) e[i].clear(); for(int i=1;i&lt;=m;i++) cin>>val[i]; for(int i=1;i&lt;=m;i++){ int u,v; cin>>u>>v; e[u].push_back(v); e[v].push_back(u); } sort(val+1,val+1+m); for(int i=1;i&lt;=m;i++) s[i]=s[i-1]+val[i]; bfs(a,da); bfs(b,db); bfs(c,dc); ll ans=2e18; for(int i=1;i&lt;=n;i++){ if(da[i]+db[i]+dc[i]>m) continue; ans=min(ans,s[db[i]]+s[da[i]+db[i]+dc[i]]); } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"author":"小凡"},{"title":"洛谷 - P1772 [ZJOI2006]物流运输","slug":"luogu1772","date":"2020-04-20T14:55:08.000Z","updated":"2020-04-20T14:57:54.680Z","comments":true,"path":"2020/04/20/luogu1772/","link":"","permalink":"http://yoursite.com/2020/04/20/luogu1772/","excerpt":"","text":"传送门：洛谷 - P1772 思路分析先预处理出f[i][j]表示第i天到j天的最短路然后就可以转移了 样例输入 5 5 10 8 1 2 1 1 3 3 1 4 2 2 3 2 2 4 4 3 4 1 3 5 2 4 5 2 4 2 2 3 3 1 1 3 3 3 4 4 5 样例输出32AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); #define int long long using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 500; struct node { int to,val,next; } e[N]; int n,m,k,s; int head[N],dis[N],vis[N],dp[N],cnt,c[N][N],cvis[N],f[N][N]; void add(int u,int v,int w) { e[++cnt].to=v; e[cnt].val=w; e[cnt].next=head[u]; head[u]=cnt; } void spfa(int s) { for(int i=0; i&lt;=m; i++) dis[i]=1e9; mem(vis,0); dis[s]=0; vis[s]=1; queue&lt;int> q; q.push(s); while(!q.empty()) { int u=q.front(); vis[u]=0; q.pop(); for(int i=head[u]; i; i=e[i].next) { int v=e[i].to; if(dis[v]>(dis[u]+e[i].val) &amp;&amp; !cvis[v]) { dis[v]=dis[u]+e[i].val; if(!vis[v]) { vis[v]=1; q.push(v); } } } } } signed main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n>>m>>k>>s; for(int i=1; i&lt;=s; i++) { int u,v,w; cin>>u>>v>>w; add(u,v,w); add(v,u,w); } int q; cin>>q; while(q--) { int x,l,r; cin>>x>>l>>r; for(int i=l; i&lt;=r; i++) c[x][i]=1; } for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { mem(cvis,0); for(int r=i; r&lt;=j; r++) { for(int x=1; x&lt;=m; x++) { if(c[x][r]) cvis[x]=1; } } spfa(1); f[i][j]=dis[m]; } } mem(dp,INF); for(int i=1; i&lt;=n; i++) { dp[i]=f[1][i]*i; for(int j=1; j&lt;=i; j++) { dp[i]=min(dp[i],dp[j-1]+(i-j+1)*f[j][i]+k); } } cout&lt;&lt;dp[n]&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"科大讯飞杯 - 动物森友会","slug":"nk5278L","date":"2020-04-20T14:07:23.000Z","updated":"2020-04-20T14:13:47.058Z","comments":true,"path":"2020/04/20/nk5278L/","link":"","permalink":"http://yoursite.com/2020/04/20/nk5278L/","excerpt":"","text":"传送门：科大讯飞杯 - 动物森友会 思路分析二分日期，然后网络流判断建图方式如下： 超级源点 -&gt; 每个任务，权值为需要次数c 每个任务 -&gt; 对应的星期几，权值INF 每个星期 -&gt; 超级汇点，权值为$day/7$+$($day%7&gt;=i$)$ 满足条件为最大流==总次数 样例输入5 2 2 4 1 3 5 7 2 3 2 4 6 2 2 1 2 2 2 3 4 2 2 5 6 样例输出5AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); #define int long long using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N= 1e3+10; struct node { int v,w,next; } e[N*N]; int head[N],dep[N],cnt,c[N]; int n,m,sum; vector&lt;int>v[N]; void add(int u,int v,int w) { e[++cnt].v=v; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt; e[++cnt].v=u; e[cnt].w=0; e[cnt].next=head[v]; head[v]=cnt; } bool bfs(int s,int t) { queue&lt;int>q; mem(dep,0); dep[s]=1; q.push(s); while(!q.empty()) { int u=q.front(); q.pop(); for(int i=head[u]; i ; i=e[i].next) { int v=e[i].v; int w=e[i].w; if(w &amp;&amp; !dep[v]) { dep[v]=dep[u]+1; q.push(v); } } } return dep[t]; } int dfs(int u,int f,int t) { int fl=0; if(u==t) return f; for(int i=head[u]; i &amp;&amp; f ; i=e[i].next) { int v=e[i].v; if(dep[v]==dep[u]+1 &amp;&amp; e[i].w) { int nx=dfs(v,min(f,e[i].w),t); e[i].w-=nx; e[i^1].w+=nx; f-=nx; fl+=nx; } } if(!fl) dep[u]=-2; return fl; } int dinic(int s,int t) { int ans=0; while(bfs(s,t)) ans+=dfs(s,INF,t); return ans; } int judge(int day){ cnt=1; mem(head,0); int s=0,t=N-1; for(int i=1;i&lt;=n;i++){ add(s,i,c[i]); for(auto x:v[i]) add(i,x+n,INF); } for(int i=1;i&lt;=7;i++) add(i+n,t,(day/7+(day%7>=i))*m); int ans=dinic(s,t); return ans>=sum; } signed main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n>>m; for(int i=1;i&lt;=n;i++){ cin>>c[i]; sum+=c[i]; int q; cin>>q; while(q--){ int x; cin>>x; v[i].push_back(x); } } int l=0,r=INF; int ans=0; while(r>=l){ int mid=l+r>>1; if(judge(mid)){ ans=mid; r=mid-1; }else{ l=mid+1; } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"author":"小凡"},{"title":"CodeForces-1337E Kaavi and Magic Spell","slug":"CF1337E","date":"2020-04-20T13:15:24.000Z","updated":"2020-04-20T13:22:21.452Z","comments":true,"path":"2020/04/20/CF1337E/","link":"","permalink":"http://yoursite.com/2020/04/20/CF1337E/","excerpt":"","text":"传送门：CodeForces-1337E 思路分析dp[l][r]表示匹配T串[l,r]区间的方案数S串依次插入，假如插入的是第i和字符那么会形成区间长度为i，枚举左右端点 s[i]=t[l],表明s[i]可以插入到[l+1,r]的左边组成[l,r] s[i]=t[r],表明s[i]可以插入到[l,r-1]的右边组成[l,r] 最后答案就是dp[1][i]$(i&gt;=m)$的和 样例输入abab ba样例输出12AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int mod=998244353; const int N=3333; char s[N],t[N]; int dp[N][N]; int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>s+1>>t+1; int n=strlen(s+1); int m=strlen(t+1); for(int i=1; i&lt;=n; i++) if(t[i]==s[1] || i>m) dp[i][i]=2; //第一个字符和大于m的字符放左放右都可以 for(int len=2;len&lt;=n;len++){ for(int l=1;l+len-1&lt;=n;l++){ int r=l+len-1; if(s[len]==t[l] || l>m) dp[l][r]=(dp[l][r]+dp[l+1][r])%mod; if(s[len]==t[r] || r>m) dp[l][r]=(dp[l][r]+dp[l][r-1])%mod; } } int ans=0; for(int i=m;i&lt;=n;i++) ans=(ans+dp[1][i])%mod; cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"区间DP","slug":"区间DP","permalink":"http://yoursite.com/tags/%E5%8C%BA%E9%97%B4DP/"}],"author":"小凡"},{"title":"Atcoder - 163F path pass i","slug":"atc163F","date":"2020-04-20T11:50:51.000Z","updated":"2020-04-20T11:59:43.785Z","comments":true,"path":"2020/04/20/atc163F/","link":"","permalink":"http://yoursite.com/2020/04/20/atc163F/","excerpt":"","text":"传送门：Atcoder - 163F 思路分析对于每一个点，经过这个点的路径数量很容易计算，但是如果路径上有颜色重复的点的话答案就会重复，考虑如果去掉重复的答案计算一个点的时候，之前的出现过的相同颜色的点的子树就是重复的答案，将这个数量删去每次计算完一颗子树后，将这个子树根颜色的被影响值加上这棵子树的大小在计算一棵子树内的答案的时候，子树根的颜色被影响值=n-子树大小，这是显然的 样例输入8 2 7 2 5 4 1 7 5 3 1 1 2 2 7 4 5 5 6 6 8 7 8 样例输出18 15 0 14 23 0 23 0 AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); #define int long long using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e6+10; int a[N],sum[N],siz[N],ans[N],n; vector&lt;int>e[N]; void dfs1(int u,int fa) { siz[u]=1; for(auto v:e[u]) { if(v==fa) continue; dfs1(v,u); siz[u]+=siz[v]; } } void dfs2(int u,int fa) { ans[a[u]]+=siz[u]*(n-siz[u]-sum[a[u]]+1); sum[a[u]]+=siz[u]; int ss=sum[a[u]]; int pre=0; for(auto v:e[u]) { if(v==fa) continue; sum[a[u]]=n-siz[v]; dfs2(v,u); ans[a[u]]+=pre*siz[v]; pre+=siz[v]; } sum[a[u]]=ss; } signed main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n; for(int i=1; i&lt;=n; i++) cin>>a[i]; for(int i=1; i&lt;n; i++) { int u,v; cin>>u>>v; e[u].push_back(v); e[v].push_back(u); } dfs1(1,1); dfs2(1,1); for(int i=1; i&lt;=n; i++) cout&lt;&lt;ans[i]&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"小凡"},{"title":"牛客 - Accumulation Degree （换根）","slug":"nk51180","date":"2020-04-20T11:39:12.000Z","updated":"2020-04-20T11:41:11.200Z","comments":true,"path":"2020/04/20/nk51180/","link":"","permalink":"http://yoursite.com/2020/04/20/nk51180/","excerpt":"","text":"传送门：牛客 - Accumulation Degree 思路分析换根的时候注意叶子节点的答案 样例输入1 5 1 2 11 1 4 13 3 4 5 4 5 10 样例输出26AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=2e5+10; vector&lt;pair&lt;int,int>>e[N]; int dp[N],f[N],in[N]; void dfs1(int u,int fa) { for(auto x:e[u]) { int v=x.fi; int w=x.se; if(v==fa) continue; dfs1(v,u); if(in[v]==1) dp[u]+=w; else dp[u]+=min(dp[v],w); } } void dfs2(int u,int fa) { f[u]=dp[u]; for(auto x:e[u]) { int v=x.fi; int w=x.se; if(v==fa) continue; int sdu=dp[u],sdv=dp[v]; if(in[u]==1) dp[v]+=w; else dp[v]+=min(dp[u]-min(w,dp[v]),w); dfs2(v,u); dp[u]=sdu; dp[v]=sdv; } } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; while(t--) { for(int i=1; i&lt;=200000; i++) e[i].clear(); mem(dp,0); mem(f,0); mem(in,0); int n; cin>>n; for(int i=1; i&lt;n; i++) { int u,v,w; cin>>u>>v>>w; e[u].push_back(mp(v,w)); e[v].push_back(mp(u,w)); in[u]++; in[v]++; } dfs1(1,1); dfs2(1,1); int ans=0; for(int i=1; i&lt;=n; i++) ans=max(ans,f[i]); cout&lt;&lt;ans&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"小凡"},{"title":"牛客 - 树学 （换根）","slug":"nk201400","date":"2020-04-20T11:33:05.000Z","updated":"2020-04-20T11:38:53.572Z","comments":true,"path":"2020/04/20/nk201400/","link":"","permalink":"http://yoursite.com/2020/04/20/nk201400/","excerpt":"","text":"传送门：牛客 - 树学 思路分析父亲与儿子之间的深度关系是+1，所以父亲的答案可以由儿子转移过来儿子对父亲的贡献为儿子的答案+儿子的节点数换根的时候先保留原始数据，然后计算新根的贡献，往下dfs，最后还原 样例输入4 1 2 1 3 1 4样例输出3AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e6+10; vector&lt;int>e[N]; int dp[N],siz[N],f[N]; void dfs1(int u,int fa){ siz[u]=1; for(auto v:e[u]){ if(v==fa) continue; dfs1(v,u); siz[u]+=siz[v]; dp[u]+=dp[v]+siz[v]; } } void dfs2(int u,int fa){ f[u]=dp[u]; for(auto v:e[u]){ if(v==fa) continue; int su=siz[u],sv=siz[v]; int sdu=dp[u],sdv=dp[v]; dp[u]-=(dp[v]+siz[v]); siz[u]-=siz[v]; siz[v]+=siz[u]; dp[v]+=dp[u]+siz[u]; dfs2(v,u); siz[u]=su; siz[v]=sv; dp[u]=sdu; dp[v]=sdv; } } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=1;i&lt;n;i++){ int u,v; cin>>u>>v; e[u].push_back(v); e[v].push_back(u); } dfs1(1,1); dfs2(1,1); int ans=INF; for(int i=1;i&lt;=n;i++) ans=min(ans,f[i]); cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"小凡"},{"title":"牛客 - 黑白树","slug":"nk13249","date":"2020-04-14T06:53:29.000Z","updated":"2020-04-14T06:57:23.136Z","comments":true,"path":"2020/04/14/nk13249/","link":"","permalink":"http://yoursite.com/2020/04/14/nk13249/","excerpt":"","text":"传送门：牛客 - 黑白树 思路分析贪心的从儿子节点往上染色设$f[i]$表示$i$节点能往上染色的最大距离（包含他自己），$f[i]$由儿子节点转移过来如果$f[i]$为0，说明儿子已经影响不到当前节点了，这个节点就必须选，$f[i]=k[i]$ 样例输入4 1 2 1 1 2 2 1样例输出3AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e5+10; vector&lt;int>e[N]; int f[N],k[N],ans; void dfs(int u){ for(auto v:e[u]){ dfs(v); f[u]=max(f[u],f[v]-1); k[u]=max(k[u],k[v]-1); } if(!f[u]){ ans++; f[u]=k[u]; } } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=2;i&lt;=n;i++){ int x; cin>>x; e[x].push_back(i); } for(int i=1;i&lt;=n;i++) cin>>k[i]; dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"小凡"},{"title":"牛客 - 树","slug":"nk13611","date":"2020-04-14T06:48:57.000Z","updated":"2020-04-14T06:52:40.236Z","comments":true,"path":"2020/04/14/nk13611/","link":"","permalink":"http://yoursite.com/2020/04/14/nk13611/","excerpt":"","text":"传送门：牛客 - 树 思路分析既然是一棵树，题意可以转化为最多给K个连通块染色，求方案数从叶子节点除法，用$dp[i][j]$表示前i个节点，用j种颜色染色的方案数 样例输入4 3 1 2 2 3 2 4 样例输出39AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int mod=1e9+7; const int N=333; ll dp[N][N]; int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,k; cin>>n>>k; dp[0][0]=1; for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=k; j++) dp[i][j]=(dp[i-1][j]+dp[i-1][j-1]*(k-(j-1)))%mod; ll ans=0; for(int i=1;i&lt;=k;i++) ans=(ans+dp[n][i])%mod; cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"牛客练习赛61 - E 相似的子串","slug":"nk5026E","date":"2020-04-11T09:49:10.000Z","updated":"2020-04-11T09:54:38.872Z","comments":true,"path":"2020/04/11/nk5026E/","link":"","permalink":"http://yoursite.com/2020/04/11/nk5026E/","excerpt":"","text":"传送门：牛客练习赛61 - E 思路分析很显然，答案具有二分性，二分前缀的长度开一个map记录hash值的上一个位置，枚举每一个长度为mid的前缀如果距离上一个map的位置，说明不想交，这个前缀的计数+1如果存在一个前缀的次数$≥k$，说明该长度成立 样例输入7 3 abcabab样例输出2AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int base= 10001659; const int mod=100000429; const int N=2e5+10; char s[N]; int n,k; ll ha[N],ba[N]; unordered_map&lt;ll,int>pos,cnt; ll get(int l,int r) { ll ans=(ha[r]-ha[l-1]*ba[r-l+1]+mod)%mod; if(ans&lt;0) ans+=mod; return ans; } int judge(int len) { pos.clear(); cnt.clear(); for(int i=len; i&lt;=n; i++) { ll x=get(i-len+1,i); if(!pos[x] || i-pos[x]>=len) { pos[x]=i; cnt[x]++; } if(cnt[x]>=k) return 1; } return 0; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n>>k>>s+1; ba[0]=1; for(int i=1; i&lt;=n; i++) { ba[i]=ba[i-1]*base%mod; ha[i]=(ha[i-1]*base)%mod+s[i]; } int l=0,r=n/k; int ans; while(r>=l){ int mid=l+r>>1; if(judge(mid)) l=mid+1,ans=mid; else r=mid-1; } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"},{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"}],"author":"小凡"},{"title":"牛客练习赛61 - D 最短路变短了","slug":"nk5026D","date":"2020-04-11T08:08:03.000Z","updated":"2020-04-11T08:20:01.006Z","comments":true,"path":"2020/04/11/nk5026D/","link":"","permalink":"http://yoursite.com/2020/04/11/nk5026D/","excerpt":"","text":"传送门：牛客练习赛61 - D 思路分析正向反向跑一次最短路得到两个数组d1，d2那么对于每次询问$u,v,w$只需要判断$d1[v]+d2[u]+w&lt;d1[n]$是否成立就行了如果还需要判断最短路是否不变的话怎么办呢？将最短路的边加入一个无向图中，通过Tarjan找出所有的桥如果是桥的话，也就是必经边，必不可能到达终点 样例输入3 4 1 2 100 2 3 100 3 1 100 2 1 1 2 1 4 样例输出NO YES AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); #define int long long using namespace std; const int INF = 1e18; const int N=1e6+10; vector&lt;pair&lt;int,int>>e1[N],e2[N]; struct node { int v,w,next; } e[N]; struct edge { int u,v,w; } s[N]; int cnt,head[N],d1[N],d2[N],vis[N],id[N],dfn[N],low[N],vistime,must[N]; int n,m; void add(int u,int v,int w,int i) { e[++cnt].v=v; e[cnt].w=w; e[cnt].next=head[u]; id[cnt]=i; head[u]=cnt; } void dij(int s,int *dis,vector&lt;pair&lt;int,int>> *edge) { for(int i=0; i&lt;=n; i++) { dis[i]=INF; vis[i]=0; } dis[s]=0; priority_queue&lt;pair&lt;int,int> > q; q.push(make_pair(-dis[s],s)); while(!q.empty()) { int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; for(auto i:edge[u]) { int v=i.fi; int w=i.se; if(!vis[v]&amp;&amp;dis[v]>dis[u]+w) { dis[v]=dis[u]+w; q.push(make_pair(-dis[v],v)); } } } } void tarjan(int u,int fa) { dfn[u]=low[u]=++vistime; for (int i=head[u]; i; i=e[i].next) { int v=e[i].v; if (!dfn[v]) { tarjan(v,u); low[u]=min(low[u],low[v]); if (low[v]>dfn[u]){ must[id[i]]=1; //桥 } } else if(v!=fa) low[u]=min(low[u],dfn[v]); } } signed main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cnt=1; mem(head,0); cin>>n>>m; for(int i=1; i&lt;=m; i++) { int u,v,w; cin>>u>>v>>w; s[i].u=u; s[i].v=v; s[i].w=w; e1[u].push_back(mp(v,w)); e2[v].push_back(mp(u,w)); } dij(1,d1,e1); dij(n,d2,e2); for(int i=1; i&lt;=m; i++) { int u=s[i].u; int v=s[i].v; int w=s[i].w; if(d1[u]+d2[v]+w==d1[n]) { add(u,v,w,i); add(v,u,w,i); } } tarjan(1,1); int q; cin>>q; while(q--) { int x; cin>>x; int u=s[x].u; int v=s[x].v; int w=s[x].w; if(d1[v]+d2[u]+w&lt;d1[n] &amp;&amp; !must[x]) cout&lt;&lt;\"YES\"&lt;&lt;endl; else cout&lt;&lt;\"NO\"&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"Tarjan","slug":"Tarjan","permalink":"http://yoursite.com/tags/Tarjan/"}],"author":"小凡"},{"title":"CodeForces-1215D Ticket Game","slug":"CF1215D","date":"2020-04-10T05:16:02.000Z","updated":"2020-04-10T05:21:24.920Z","comments":true,"path":"2020/04/10/CF1215D/","link":"","permalink":"http://yoursite.com/2020/04/10/CF1215D/","excerpt":"","text":"传送门：CodeForces-1215D 思路分析对于左右两边的问号个数，相同的部分可以忽略，因为另一方可以通过选一样的数字将上一个人的抵消掉所以只需要考虑剩下的，那么就可以分两种种情况讨论： 两边sum相等的话，如果左右？数量一样，那么B可以获胜 左边或右边sum大的，计算小的那边剩下的？数，如果差值=？×9的话，那么B可以获胜 样例输入8 ?054??0?样例输出BicarpAC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; string a=\"Bicarp\"; string b=\"Monocarp\"; string s; cin>>s; int lcnt=0,rcnt=0,lsum=0,rsum=0; for(int i=0; i&lt;n/2; i++) if(s[i]=='?')lcnt++; else lsum+=s[i]-'0'; for(int i=n/2; i&lt;n; i++) if(s[i]=='?')rcnt++; else rsum+=s[i]-'0'; if(lsum==rsum){ if(lcnt==rcnt) cout&lt;&lt;a&lt;&lt;endl; else cout&lt;&lt;b&lt;&lt;endl; } if(lsum>rsum){ int sum=lsum-rsum; int cnt=(rcnt-lcnt)/2; if(cnt*9==sum) cout&lt;&lt;a&lt;&lt;endl; else cout&lt;&lt;b&lt;&lt;endl; } if(rsum>lsum){ int sum=rsum-lsum; int cnt=(lcnt-rcnt)/2; if(cnt*9==sum) cout&lt;&lt;a&lt;&lt;endl; else cout&lt;&lt;b&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"博弈","slug":"博弈","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%BC%88/"}],"author":"小凡"},{"title":"CodeForces-1333D Challenges in school №41","slug":"CF1333D","date":"2020-04-09T13:38:43.000Z","updated":"2020-04-09T13:41:35.509Z","comments":true,"path":"2020/04/09/CF1333D/","link":"","permalink":"http://yoursite.com/2020/04/09/CF1333D/","excerpt":"","text":"传送门：CodeForces-1333D 思路分析先暴力统计出最大和最小的操作天数。如果K在这个区间内就有解，然后将答案拆成K天就行了 样例输入4 2 RLRL 样例输出2 1 3 1 2 AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=3000010; vector&lt;int>ans[N]; vector&lt;int>a[N]; char s[3030]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,k; cin>>n>>k; cin>>s+1; int cnt=0,tot=0; while(1) { int flag=0; cnt++; for(int i=1; i&lt;=n; i++) if(s[i]=='R'&amp;&amp;s[i+1]=='L') { flag=1; tot++; swap(s[i],s[i+1]); a[cnt].push_back(i); i++; } if(!flag) { cnt--; break; } } if(k&lt;cnt||k>tot){ puts(\"-1\"); return 0; } int now=1; for(int i=1;i&lt;=cnt;i++){ while(!a[i].empty() &amp;&amp; k>cnt-i+1){ printf(\"1 %d\\n\",a[i].back()); a[i].pop_back(); k--; } if(!a[i].empty()){ printf(\"%d \",a[i].size()); for(auto x:a[i]) printf(\"%d \",x); puts(\"\"); k--; } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"}],"author":"小凡"},{"title":"CodeForces-1114F Another Queries on Array?","slug":"CF1114F","date":"2020-04-09T13:32:40.000Z","updated":"2020-04-09T13:40:00.326Z","comments":true,"path":"2020/04/09/CF1114F/","link":"","permalink":"http://yoursite.com/2020/04/09/CF1114F/","excerpt":"","text":"传送门：CodeForces-1114F 思路分析如果对于每次询问都单独计算欧拉函数值肯定会超时因为都是300以下的数字，素数只有62个，所以可以通过状压的方式，统计区间内的素数个数 样例输入4 4 5 9 1 2 TOTIENT 3 3 TOTIENT 3 4 MULTIPLY 4 4 3 TOTIENT 4 4 样例输出1 1 2 AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); #define int long long using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int mod=1e9+7; const int N=1e6+5; int prim[333],ok[333],state[333],inv[333],a[N],cnt; struct node { int l,r,mid,len,sum,st,lst,mul; } tree[N&lt;&lt;2]; ll qmul(ll a, ll b) { ll res = 1; while (b) { if (b &amp; 1) res = res * a % mod; a = a * a % mod; b >>= 1; } return res; } void init(int n) { memset(ok,true,sizeof(ok)); ok[0]=ok[1]=false; for(int i=2; i&lt;=n; i++) { if(ok[i]) { prim[cnt++]=i; for(int j=i*i; j&lt;=n; j+=i) { ok[j]=false; } } } inv[1]=1; for(int i=2; i&lt;=n; i++) inv[i]=mod-mod/i*inv[mod%i]%mod; for(int i=1; i&lt;=n; i++) { for(int j=0; j&lt;cnt; j++) { if(i&lt;prim[j]) break; if(i%prim[j]==0) state[i]+=(1LL&lt;&lt;j); } } } void pp(int x) { tree[x].sum=(tree[rs].sum*tree[ls].sum)%mod; tree[x].st=tree[rs].st|tree[ls].st; } void build(int x,int l,int r) { tree[x].l=l; tree[x].r=r; tree[x].mid=l+r>>1; tree[x].len=r-l+1; tree[x].mul=1; if(l==r) { tree[x].st=state[a[l]]; tree[x].sum=a[l]; return ; } int mid=tree[x].mid; build(ls,l,mid); build(rs,mid+1,r); pp(x); } void pd(int x) { tree[rs].mul=tree[rs].mul*tree[x].mul%mod; tree[ls].mul=tree[ls].mul*tree[x].mul%mod; tree[rs].lst|=tree[x].lst; tree[ls].lst|=tree[x].lst; tree[rs].sum=tree[rs].sum*qmul(tree[x].mul,tree[rs].len)%mod; tree[ls].sum=tree[ls].sum*qmul(tree[x].mul,tree[ls].len)%mod; tree[rs].st|=tree[x].lst; tree[ls].st|=tree[x].lst; tree[x].lst=0; tree[x].mul=1; } void update(int x,int l,int r,int val) { if(l&lt;=tree[x].l &amp;&amp; tree[x].r&lt;=r) { tree[x].sum=tree[x].sum*qmul(val,tree[x].len)%mod; tree[x].mul=tree[x].mul*val%mod; tree[x].lst|=state[val]; tree[x].st|=state[val]; return ; } int mid=tree[x].mid; pd(x); if(l&lt;=mid) update(ls,l,r,val); if(r>mid) update(rs,l,r,val); pp(x); } node query(int x,int l,int r) { if(l&lt;=tree[x].l&amp;&amp;tree[x].r&lt;=r) return tree[x]; pd(x); int mid=tree[x].mid; if(r&lt;=mid) return query(ls,l,r); if(l>mid) return query(rs,l,r); else if(l&lt;=mid &amp;&amp; r>mid) { node lson=query(ls,l,r); node rson=query(rs,l,r); node ans; ans.sum=lson.sum*rson.sum%mod; ans.st=lson.st|=rson.st; return ans; } } signed main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif init(300); int n,q; cin>>n>>q; for(int i=1; i&lt;=n; i++) cin>>a[i]; build(1,1,n); while(q--) { string op; int l,r; cin>>op>>l>>r; if(op[0]=='M') { int x; cin>>x; update(1,l,r,x); } else { node now=query(1,l,r); ll ans=now.sum; for(int i=0; i&lt;cnt; i++) if(now.st&amp;(1LL&lt;&lt;i)) ans=ans*(prim[i]-1)%mod*inv[prim[i]]%mod; cout&lt;&lt;ans&lt;&lt;endl; } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"}],"author":"小凡"},{"title":"学军网络邀请赛 - B 齐心抗疫（树的直径）","slug":"xjB","date":"2020-04-05T10:17:02.000Z","updated":"2020-04-05T10:27:17.748Z","comments":true,"path":"2020/04/05/xjB/","link":"","permalink":"http://yoursite.com/2020/04/05/xjB/","excerpt":"","text":"思路分析简单说一下题意：任意选择两个点$u,v$，这两个点的贡献为$max(a_v,a_u)$$×dis(u,v)$，求最大值该问题转化一下，就变成合理选择$u,v$,最大化$a_u×dis(u,v)$先找出树的直径的两端，那么每一点，距离它最远的点一定是直径的两端所以预处理出直径两端到各个点的距离就行了 样例输入8 3 1 4 1 5 9 2 6 1 2 2 3 2 4 1 5 5 6 4 8 3 7 样例输出45AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e5+10; vector&lt;int>e[N]; int a[N],d1[N],d2[N]; int dfs(int u,int fa,int *dis) { int ans=u; for(auto v:e[u]) { if(v==fa) continue; dis[v]=dis[u]+1; int now=dfs(v,u,dis); if(dis[now]>dis[ans]) ans=now; } return ans; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=1; i&lt;=n; i++) cin>>a[i]; for(int i=1; i&lt;n; i++) { int u,v; cin>>u>>v; e[u].push_back(v); e[v].push_back(u); } int x=dfs(1,1,d1); int y=dfs(x,x,d2); mem(d1,0); x=dfs(y,y,d1); int ans=0; for(int i=1; i&lt;=n; i++) ans=max(ans,a[i]*max(d1[i],d2[i])); cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"小凡"},{"title":"牛客 - MMset2","slug":"nk14250","date":"2020-03-30T17:00:24.000Z","updated":"2020-03-30T17:04:28.364Z","comments":true,"path":"2020/03/31/nk14250/","link":"","permalink":"http://yoursite.com/2020/03/31/nk14250/","excerpt":"","text":"传送门：牛客 - MMset2 思路分析先找到点集中路径最长的两个点，那么答案一定是这条路径的中点到两端的距离（len/2）如果总长是奇数的话，取大的那边，就是向上取整 样例输入3 1 2 1 3 1 2 2 3样例输出1AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e6+10; vector&lt;int>e[N]; int fa[N],dep[N],son[N],siz[N],top[N],a[N]; void dfs1(int u,int f) { fa[u]=f; dep[u]=dep[f]+1; siz[u]=1; int maxsize=-1; for(auto v:e[u]) { if(v==f)continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]>maxsize) { son[u]=v; maxsize=siz[v]; } } } void dfs2(int u,int t) { top[u]=t; if(!son[u]) return ; dfs2(son[u],t); for(auto v:e[u]) { if(v==son[u]||v==fa[u]) continue; dfs2(v,v); } } int lca(int x,int y) { while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; } return dep[x]>dep[y]?y:x; } int dis(int u,int v){ return dep[u]+dep[v]-2*dep[lca(u,v)]; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=1;i&lt;n;i++) { int u,v; cin>>u>>v; e[u].push_back(v); e[v].push_back(u); } int q; dfs1(1,1); dfs2(1,1); cin>>q; while(q--){ int x; cin>>x; for(int i=1;i&lt;=x;i++) cin>>a[i]; int d=a[1]; for(int i=2;i&lt;=x;i++) if(dep[a[i]]>dep[d]) d=a[i]; int ma=0; for(int i=1;i&lt;=x;i++) ma=max(ma,dis(a[i],d)); cout&lt;&lt;(ma+1)/2&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"http://yoursite.com/tags/LCA/"}],"author":"小凡"},{"title":"牛客 - 城市网络","slug":"nk13331","date":"2020-03-30T16:23:48.000Z","updated":"2020-03-30T16:33:59.069Z","comments":true,"path":"2020/03/31/nk13331/","link":"","permalink":"http://yoursite.com/2020/03/31/nk13331/","excerpt":"","text":"传送门：牛客 - 城市网络 思路分析因为$v$在$u$到根节点的必经之路上，也就是说$v$是$u$的祖先所以问题就变为$u$往上跳了，可以用倍增来优化上跳的过程$dp[i][j]$表示从$i$节点开始，遇到$2^j$个比它大的第一个节点对于每一个询问，可以离线处理，将询问与$u$节点连边，方便处理 样例输入5 4 3 5 1 2 4 1 2 1 3 2 4 3 5 4 2 1 4 2 2 4 2 3 5 1 5 样例输出2 1 1 0AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e6+10; vector&lt;int>e[N]; int a[N],dp[N][20],dep[N]; struct node{ int u,v,c; }q[N]; void dfs(int u,int fa) { dep[u]=dep[fa]+1; if(a[fa]>a[u]) dp[u][0]=fa; else { int pre=fa; for(int i=19; i>=0; i--) if(dp[pre][i] &amp;&amp; a[u]>=a[dp[pre][i]]) pre=dp[pre][i]; dp[u][0]=dp[pre][0]; } for(int i=1; i&lt;=19; i++) dp[u][i]=dp[dp[u][i-1]][i-1]; for(auto v:e[u]) if(v!=fa) dfs(v,u); } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,m; cin>>n>>m; for(int i=1; i&lt;=n; i++) cin>>a[i]; for(int i=1; i&lt;n; i++) { int u,v; cin>>u>>v; e[u].push_back(v); e[v].push_back(u); } for(int i=1;i&lt;=m;i++){ cin>>q[i].u>>q[i].v>>q[i].c; e[i+n].push_back(q[i].u); e[q[i].u].push_back(i+n); a[i+n]=q[i].c; } dfs(1,1); for(int i=1;i&lt;=m;i++){ int u=n+i,v=q[i].v; int ans=0; for(int i=19;i>=0;i--){ if(dep[dp[u][i]]>=dep[v]){ u=dp[u][i]; ans+=(1&lt;&lt;i); } } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"倍增","slug":"倍增","permalink":"http://yoursite.com/tags/%E5%80%8D%E5%A2%9E/"}],"author":"小凡"},{"title":"CodeForces-600E Lomsat gelral","slug":"CF600E","date":"2020-03-30T16:14:54.000Z","updated":"2020-05-26T11:53:58.440Z","comments":true,"path":"2020/03/31/CF600E/","link":"","permalink":"http://yoursite.com/2020/03/31/CF600E/","excerpt":"","text":"传送门：CodeForces-600E 思路分析启发式合并经典题步骤为：计算轻儿子的贡献，删除轻儿子的贡献，计算重儿子的贡献，再将轻儿子的贡献合并到重儿子上去 用线段树合并做就很暴力了 树上启发式合并代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e5+10; int n,col[N],ma,flag; int siz[N],cnt[N],son[N]; vector&lt;int>e[N]; ll ans[N],sum; void dfs1(int u,int fa) { siz[u]=1; for(auto v:e[u]) { if(v==fa) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]>siz[son[u]]) son[u]=v; } } void calc(int u,int fa,int val) { cnt[col[u]]+=val; if(cnt[col[u]]>ma) { ma=cnt[col[u]]; sum=col[u]; } else if(cnt[col[u]]==ma) sum+=col[u]; for(auto v:e[u]) { if(v==fa||v==flag) continue; calc(v,u,val); } } void dfs2(int u,int fa,int keep) { for(auto v:e[u]) { if(v==fa||v==son[u]) continue; dfs2(v,u,0); } if(son[u]) { dfs2(son[u],u,1); flag=son[u]; } calc(u,fa,1); flag=0; ans[u]=sum; if(!keep){ calc(u,fa,-1); ma=sum=0; } } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=1;i&lt;=n;i++) cin>>col[i]; for(int i=1;i&lt;n;i++){ int u,v; cin>>u>>v; e[u].push_back(v); e[v].push_back(u); } dfs1(1,1); dfs2(1,1,1); for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;\" \"; return 0; } 线段树合并代码#include &lt;bits/stdc++.h> #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) (x).size() #define lowbit(x) (x)&amp;(-x) #define all(x) (x).begin(),(x).end() #define mem(a,b) memset(a,b,sizeof(a)) namespace FastIO { #define BUF_SIZE 100000 #define OUT_SIZE 100000 bool IOerror=0; inline char nc() { static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) { p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1) { IOerror=1; return -1; } } return *p1++; } inline bool blank(char ch) { return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; } template&lt;class T> inline bool read(T &amp;x) { bool sign=0; char ch=nc(); x=0; for(; blank(ch); ch=nc()); if(IOerror)return false; if(ch=='-')sign=1,ch=nc(); for(; ch>='0'&amp;&amp;ch&lt;='9'; ch=nc())x=x*10+ch-'0'; if(sign)x=-x; return true; } template&lt;class T,class... U>bool read(T&amp; h,U&amp;... t) { return read(h)&amp;&amp;read(t...); } #undef OUT_SIZE #undef BUF_SIZE }; using namespace std; using namespace FastIO; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N = 1e5+10; struct node { int ls,rs; ll sum,ma; } tree[N * 40]; int root[N],cnt,a[N]; ll ans[N]; vector&lt;int>e[N]; void pp(int x) { int ls=tree[x].ls; int rs=tree[x].rs; if(tree[ls].ma==tree[rs].ma) { tree[x].sum=tree[ls].sum+tree[rs].sum; tree[x].ma=tree[ls].ma; return ; } if(tree[ls].ma>tree[rs].ma) { tree[x].sum=tree[ls].sum; tree[x].ma=tree[ls].ma; return ; } if(tree[rs].ma>tree[ls].ma) { tree[x].sum=tree[rs].sum; tree[x].ma=tree[rs].ma; return ; } } void ins(int &amp;x,int l,int r,int pos) { if(!x) x=++cnt; if(l==r) { tree[x].ma++; tree[x].sum=l; return ; } int mid=l+r>>1; if(pos&lt;=mid) ins(tree[x].ls,l,mid,pos); else ins(tree[x].rs,mid+1,r,pos); pp(x); } int merge(int x,int y,int l,int r) { if(!x||!y) return x?x:y; if(l==r) { tree[x].ma+=tree[y].ma; return x; } int mid=l+r>>1; tree[x].ls=merge(tree[x].ls,tree[y].ls,l,mid); tree[x].rs=merge(tree[x].rs,tree[y].rs,mid+1,r); pp(x); return x; } void dfs(int u,int fa) { for(auto v:e[u]) { if(v==fa) continue; dfs(v,u); root[u]=merge(root[u],root[v],1,N); } ans[u]=tree[root[u]].sum; } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; read(n); for(int i=1; i&lt;=n; i++) { read(a[i]); ins(root[i],1,N,a[i]); } for(int i=1; i&lt;n; i++) { int u,v; read(u,v); e[u].pb(v); e[v].pb(u); } dfs(1,0); for(int i=1; i&lt;=n; i++) cout&lt;&lt;ans[i]&lt;&lt;\" \"; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树上启发式合并","slug":"树上启发式合并","permalink":"http://yoursite.com/tags/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"},{"name":"线段树合并","slug":"线段树合并","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"}],"author":"小凡"},{"title":"牛客 - 练习赛60C 操作集锦","slug":"nk4853C","date":"2020-03-29T10:07:52.000Z","updated":"2020-03-29T10:11:07.115Z","comments":true,"path":"2020/03/29/nk4853C/","link":"","permalink":"http://yoursite.com/2020/03/29/nk4853C/","excerpt":"","text":"传送门：牛客 - 练习赛60C 思路分析dp[i][j]表示用前i个字符，组成长度为k的字符串数量没有限制的话，转移就就是dp[i][j]=dp[i-1][j]+dp[i-1][j-1]这样肯定有重复的，重复的部分就是dp[s[i]-‘a’-1][j-1]，将这部分减掉就行了 样例输入3 1 abc样例输出3AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e3+10; const int mod=1e9+7; char s[N]; ll dp[N][N],pre[30]; int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,k; cin>>n>>k; cin>>s+1; dp[0][0]=1; for(int i=1;i&lt;=n;i++){ dp[i][0]=1; for(int j=1;j&lt;=i;j++){ dp[i][j]=dp[i-1][j]+dp[i-1][j-1]; if(pre[s[i]-'a']) dp[i][j]-=dp[pre[s[i]-'a']-1][j-1]; dp[i][j]%=mod; } pre[s[i]-'a']=i; } cout&lt;&lt;(dp[n][k]+mod)%mod&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"牛客 - 练习赛60E 旗鼓相当的对手","slug":"nk4853E","date":"2020-03-29T09:39:37.000Z","updated":"2020-03-29T09:43:50.469Z","comments":true,"path":"2020/03/29/nk4853E/","link":"","permalink":"http://yoursite.com/2020/03/29/nk4853E/","excerpt":"","text":"传送门：牛客 - 练习赛60E 思路分析子树问题启发式合并，保留重儿子的贡献，删除轻儿子的贡献，暴力合并轻儿子的贡献开两个map，num表示该深度的数量，sum表示该深度的点权和 样例输入3 2 1 2 3 1 2 1 3 样例输出5 0 0AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e5+10; int n,k,siz[N],son[N],dep[N]; vector&lt;int>e[N]; vector&lt;pair&lt;int,ll>>tem; ll ans[N],a[N]; map&lt;int,ll>num,sum; void dfs1(int u,int fa) { siz[u]=1; dep[u]=dep[fa]+1; for(auto v:e[u]) { if(v==fa) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]>siz[son[u]]) son[u]=v; } } void add(int u,int fa,int pos) { ans[pos]+=num[k+2*dep[pos]-dep[u]]*a[u]+sum[k+2*dep[pos]-dep[u]]; tem.push_back(mp(dep[u],a[u])); for(auto v:e[u]) if(v!=fa) add(v,u,pos); } void del(int u,int fa) { num[dep[u]]--; sum[dep[u]]-=a[u]; for(auto v:e[u]) if(v!=fa) del(v,u); } void dfs2(int u,int fa) { for(auto v:e[u]) { if(v==fa||v==son[u]) continue; dfs2(v,u); del(v,u); } if(son[u]) dfs2(son[u],u); for(auto v:e[u]) { if(v==fa||v==son[u]) continue; tem.clear(); add(v,u,u); for(auto x:tem) { num[x.fi]++; sum[x.fi]+=x.se; } } num[dep[u]]++; sum[dep[u]]+=a[u]; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n>>k; for(int i=1; i&lt;=n; i++) cin>>a[i]; for(int i=1; i&lt;n; i++) { int u,v; cin>>u>>v; e[u].push_back(v); e[v].push_back(u); } dfs1(1,1); dfs2(1,1); for(int i=1; i&lt;=n; i++) cout&lt;&lt;ans[i]&lt;&lt;\" \"; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树上启发式合并","slug":"树上启发式合并","permalink":"http://yoursite.com/tags/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://yoursite.com/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}],"author":"小凡"},{"title":"CodeForces-1328E Tree Queries","slug":"CF1328E","date":"2020-03-27T10:42:32.000Z","updated":"2020-03-27T10:51:11.427Z","comments":true,"path":"2020/03/27/CF1328E/","link":"","permalink":"http://yoursite.com/2020/03/27/CF1328E/","excerpt":"","text":"传送门：CodeForces-1328E 思路分析这条路径一定是到深度最深的节点，将节点按照深度大小排序，从深度大的开始枚举连续两个点 如果两个点深度相同，判断父亲是否一样 如果深度不同，判断两个点的LCA是不是深度小的那个点，或者为深度小的那个点的父亲 样例输入10 6 1 2 1 3 1 4 2 5 2 6 3 7 7 8 7 9 9 10 4 3 8 9 10 3 2 4 6 3 2 1 5 3 4 8 2 2 6 10 3 5 4 7 样例输出YES YES YES YES NO NO AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e6+10; vector&lt;int>e[N]; int fa[N],dep[N],son[N],siz[N],top[N]; void dfs1(int u,int f) { fa[u]=f; dep[u]=dep[f]+1; siz[u]=1; int maxsize=-1; for(auto v:e[u]) { if(v==f)continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]>maxsize) { son[u]=v; maxsize=siz[v]; } } } void dfs2(int u,int t) { top[u]=t; if(!son[u]) return ; dfs2(son[u],t); for(auto v:e[u]) { if(v==son[u]||v==fa[u]) continue; dfs2(v,v); } } int lca(int x,int y) { while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; } return dep[x]>dep[y]?y:x; } int q[N]; bool cmp(int a,int b) { return dep[a]>dep[b]; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,m; cin>>n>>m; for(int i=1; i&lt;n; i++) { int u,v; cin>>u>>v; e[u].push_back(v); e[v].push_back(u); } dfs1(1,1); dfs2(1,1); while(m--) { int t; cin>>t; for(int i=0; i&lt;t; i++) cin>>q[i]; sort(q,q+t,cmp); bool ok=true; for(int i=1; i&lt;t; i++) { if(dep[q[i]]==dep[q[i-1]]) { if(fa[q[i]]!=fa[q[i-1]]) ok=false; } else { int root=lca(q[i],q[i-1]); if(root!=fa[q[i]] &amp;&amp; root!=q[i]) ok=false; } } cout&lt;&lt;(ok?\"YES\":\"NO\")&lt;&lt;'\\n'; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"http://yoursite.com/tags/LCA/"}],"author":"小凡"},{"title":"牛客 - 13230 合并回文子串","slug":"nk13230","date":"2020-03-27T10:26:13.000Z","updated":"2020-03-27T10:37:32.419Z","comments":true,"path":"2020/03/27/nk13230/","link":"","permalink":"http://yoursite.com/2020/03/27/nk13230/","excerpt":"","text":"传送门：牛客 - 13230 思路分析考虑 $c$ 中的回文子串，既然是子串，就一定可以拆成 $a$, $b$ 两串的两个子串的 combine。不妨 设是 $a[i, j]$与 $b[k, l]$的 combine，则可以考虑动态规划的状态 $f[i][j][k][l]$表示 $a[i, j]$与 $b[k, l]$的 combine 能否组成回文子串。 则可以匹配第一个字符和最后一个字符来转移，根据第一个字符和最后一个字符分别来自 $a$ 还是 $b$ 共有四种转移: $f[i][j][k][l]&lt;-f[i+1][j-1][k][k]$ $(i&lt;j,a[i]=a[j])$ $f[i][j][k][l]&lt;-f[i+1][j][k][l-1]$ $(i&lt;=j,k&lt;=l,a[i]=b[l])$ $f[i][j][k][l]&lt;-f[i][j-1][k+1][l]$ $(i&lt;=j,k&lt;=l,a[j]=b[k])$ $f[i][j][k][l]&lt;-f[i][j][k+1][l-1]$ $(k&lt;l,b[k]=b[l])$ 注意边界情况，新串长度小于等于1的时候，为true 样例输入2 aa bb a aaaabcaa 样例输出4 5 AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; int dp[55][55][55][55]; char a[55],b[55]; int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; while(t--) { scanf(\"%s%s\",a+1,b+1); int n1=strlen(a+1); int n2=strlen(b+1); int ans=-INF; for(int len1=0; len1&lt;=n1; len1++) { for(int len2=0; len2&lt;=n2; len2++) { for(int i=1,j=len1+i-1; j&lt;=n1; i++,j++) { for(int k=1,l=len2+k-1; l&lt;=n2; k++,l++) { if(len1+len2&lt;=1) dp[i][j][k][l]=1; else { dp[i][j][k][l]=0; if(len1>1 &amp;&amp; a[i]==a[j]) dp[i][j][k][l]|=dp[i+1][j-1][k][l]; if(len2>1 &amp;&amp; b[k]==b[l]) dp[i][j][k][l]|=dp[i][j][k+1][l-1]; if(len1 &amp;&amp; len2 &amp;&amp; a[i]==b[l]) dp[i][j][k][l]|=dp[i+1][j][k][l-1]; if(len1 &amp;&amp; len2 &amp;&amp; a[j]==b[k]) dp[i][j][k][l]|=dp[i][j-1][k+1][l]; } if(dp[i][j][k][l]) ans=max(ans,j-i+1+l-k+1); } } } } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"区间DP","slug":"区间DP","permalink":"http://yoursite.com/tags/%E5%8C%BA%E9%97%B4DP/"}],"author":"小凡"},{"title":"洛谷 - P5490 扫描线","slug":"luogu5490","date":"2020-03-21T09:18:08.000Z","updated":"2020-03-21T09:19:58.108Z","comments":true,"path":"2020/03/21/luogu5490/","link":"","permalink":"http://yoursite.com/2020/03/21/luogu5490/","excerpt":"","text":"传送门：洛谷 - P5490 思路分析区间修改的时候跟普通线段树不一样 样例输入2 100 100 200 200 150 150 250 255样例输出18000AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e6+10; struct node { int l,r,mid,cover; ll len; } tree[N&lt;&lt;2]; struct Line { ll x,y1,y2,pos; bool operator &lt; (Line a) { return x&lt;a.x; } } line[N&lt;&lt;1]; ll v[N]; void build(int x,int l,int r) { tree[x].l=l; tree[x].r=r; tree[x].mid=l+r>>1; if(r-l&lt;=1) { return ; } int mid=tree[x].mid; build(ls,l,mid); build(rs,mid,r); } void pp(int x) { if(tree[x].cover) tree[x].len=v[tree[x].r]-v[tree[x].l]; else tree[x].len=tree[ls].len+tree[rs].len; } void modify(int x,int l,int r,int k) { if(l&lt;=v[tree[x].l] &amp;&amp; v[tree[x].r]&lt;=r) { tree[x].cover+=k; pp(x); return ; } if(l&lt;v[tree[ls].r]) modify(ls,l,r,k); if(r>v[tree[rs].l]) modify(rs,l,r,k); pp(x); } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=1; i&lt;=n; i++) { ll a,b,c,d; cin>>a>>b>>c>>d; v[i]=b,v[n+i]=d; line[i]= {a,b,d,1}; line[n+i]= {c,b,d,-1}; } n&lt;&lt;=1; sort(v+1,v+1+n); sort(line+1,line+1+n); int tot=unique(v+1,v+1+n)-v-1; build(1,1,tot); ll ans=0; for(int i=1; i&lt;=n; i++) { ans+=tree[1].len*(line[i].x-line[i-1].x); modify(1,line[i].y1,line[i].y2,line[i].pos); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"author":"小凡"},{"title":"CodeForces-1326D Prefix-Suffix Palindrome","slug":"CF1326D","date":"2020-03-20T13:10:47.000Z","updated":"2020-03-20T13:36:08.048Z","comments":true,"path":"2020/03/20/CF1326D/","link":"","permalink":"http://yoursite.com/2020/03/20/CF1326D/","excerpt":"","text":"传送门：CodeForces-1326D 思路分析找一个由前缀+后缀组成的最大回文串先找前后缀共同的回文部分，这样问题就变为前缀+回文+后缀了我们只需要对去除前后缀之后的字符串进行处理了设这个字符串为S，找最长前缀（后缀）回文串，接下来有三种处理方法，见代码部分 样例输入5 a abcdfdcecba abbaxyzyx codeforces acbba样例输出a abcdfdcba xyzyx c abbahash代码对S和S的反串进行hash处理，然后枚举前后缀串中最大的回文串，hash是$O(1)$判断 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int base= 10001659; const int mod=100000429; const int N=1e6+10; int n; ll ba[N],hash1[N],hash2[N]; void init(string &amp;s,ll *ha) { s=\"#\"+s; ba[0]=1; for(int i=1; i&lt;=n; i++) { ba[i]=ba[i-1]*base%mod; ha[i]=(ha[i-1]*base)%mod+s[i]; } } ll getkey(ll *ha,int l,int r) { ll ans=(ha[r]-ha[l-1]*ba[r-l+1]+mod)%mod; if(ans&lt;0) ans+=mod; return ans; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; while(t--) { string s; cin>>s; int l=0,r=s.size()-1; while(s[l]==s[r] &amp;&amp; l&lt;r) l++,r--; string t1=s.substr(0,l),t2=s.substr(r+1); s=s.substr(l,r-l+1); n=s.size(); init(s,hash1); reverse(all(s)); init(s,hash2); int pos1=0,pos2=0; for(int i=1; i&lt;=n; i++) if(getkey(hash1,1,i/2)==getkey(hash2,n-i+1,n-(i+1)/2)) pos1=i; for(int i=1; i&lt;=n; i++) if(getkey(hash2,1,i/2)==getkey(hash1,n-i+1,n-(i+1)/2)) pos2=i; if(pos1>pos2) { reverse(all(s)); cout&lt;&lt;t1&lt;&lt;s.substr(1,pos1)&lt;&lt;t2&lt;&lt;endl; } else { cout&lt;&lt;t1&lt;&lt;s.substr(1,pos2)&lt;&lt;t2&lt;&lt;endl; } } return 0; } manacher代码对S串进行manacher处理，枚举以每个点为对称点的最大回文串，要满足前缀（后缀）关系，即从1开头或者len结尾注意manacher数组与原数组之间的关系 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define sz(x) x.size() #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e6+10; int che[N&lt;&lt;1]; void manacher(string s,string &amp;ma) { ma=\"$#\"; for(int i=0; i&lt;sz(s); i++) ma+=s[i],ma+='#'; int maxn=0,num=0,len=sz(ma); for(int i=0; i&lt;len; i++) { che[i]=maxn>i?min(che[2*num-i],maxn-i):1; while(ma[i+che[i]]==ma[i-che[i]]) che[i]++; if(i+che[i]>maxn) maxn=i+che[i],num=i; } } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; while(t--) { string s; cin>>s; int l=0,r=s.size()-1; while(s[l]==s[r] &amp;&amp; l&lt;r) l++,r--; string t1=s.substr(0,l),t2=s.substr(r+1); s=s.substr(l,r-l+1); string ma; manacher(s,ma); int len=sz(ma); int r1=0,pos1=0,r2=0,pos2=0; for(int i=0; i&lt;len; i++) if(r1&lt;che[i] &amp;&amp; i-che[i]&lt;2) r1=che[i],pos1=i; for(int i=len-1; i>=0; i--) if(r2&lt;che[i] &amp;&amp; i+che[i]==len) r2=che[i],pos2=i; if(r1>r2) cout&lt;&lt;t1+s.substr(0,r1-1)+t2&lt;&lt;endl; else cout&lt;&lt;t1+s.substr(sz(s)+1-r2)+t2&lt;&lt;endl; } return 0; } kmp代码我们知道kmp中的next数组的含义：next[i]表示前i字符串中，最长的相同前缀后缀将S与它的反串相连，那么这个相同的前缀后缀就等于S的最长前缀回文，因为这个长度不能超过S的长度所以拼接的时候再中间加个不相关的字符中断，防止出现溢出的情况 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int base= 67; const int mod=1e9+7; const int N=1e6+10; int n,nex[N&lt;&lt;1]; int getnext(string s) { int i=0,j=-1,len=s.size(); nex[0]=-1; while(i&lt;len) { if(j==-1||s[i]==s[j]) { i++; j++; nex[i]=j; } else j=nex[j]; } return nex[len]; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; while(t--) { string s; cin>>s; int l=0,r=s.size()-1; while(s[l]==s[r] &amp;&amp; l&lt;r) l++,r--; string t1=s.substr(0,l),t2=s.substr(r+1); s=s.substr(l,r-l+1); string t=s; reverse(all(t)); string a=s+\"#\"+t,b=t+\"#\"+s; int pos1=getnext(a); int pos2=getnext(b); if(pos1>pos2) cout&lt;&lt;t1+a.substr(0,pos1)+t2&lt;&lt;endl; else cout&lt;&lt;t1+b.substr(0,pos2)+t2&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"},{"name":"kmp","slug":"kmp","permalink":"http://yoursite.com/tags/kmp/"},{"name":"manacher","slug":"manacher","permalink":"http://yoursite.com/tags/manacher/"}],"author":"小凡"},{"title":"CodeForces-1301F Super Jaber","slug":"CF1301F","date":"2020-03-18T11:14:57.000Z","updated":"2020-03-18T11:23:00.407Z","comments":true,"path":"2020/03/18/CF1301F/","link":"","permalink":"http://yoursite.com/2020/03/18/CF1301F/","excerpt":"","text":"传送门：CodeForces-1301F 思路分析bfs处理除出每个点到各种颜色的最短距离$dis[i][x][y]$表示坐标为$(x,y)$的点到$i$颜色的最短距离那么两个点的最短距离就是两个点到同一个颜色的距离+1的最小值 样例输入3 4 5 1 2 1 3 4 4 5 5 1 2 1 3 2 1 1 3 4 2 2 2 2样例输出2 0AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1010; int n,m,k; vector&lt;pair&lt;int,int>>col[41]; int a[N][N],dis[41][N][N]; int vis[N][N],viscol[41]; int dx[4]= {1,-1,0,0},dy[4]= {0,0,1,-1}; void bfs(int x) { mem(vis,0); mem(viscol,0); viscol[x]=1; queue&lt;pair&lt;int,int>>q; for(auto i:col[x]) { q.push(i); dis[x][i.fi][i.se]=0; vis[i.fi][i.se]=1; } while(!q.empty()) { int nowx=q.front().fi; int nowy=q.front().se; q.pop(); if(!viscol[a[nowx][nowy]]) { for(auto i:col[a[nowx][nowy]]) { int nx=i.fi; int ny=i.se; if(!vis[nx][ny]) { dis[x][nx][ny]=dis[x][nowx][nowy]+1; vis[nx][ny]=1; q.push(mp(nx,ny)); } } } viscol[a[nowx][nowy]]=1; for(int i=0; i&lt;4; i++) { int nx=nowx+dx[i]; int ny=nowy+dy[i]; if(nx&lt;0||ny&lt;0||nx>=n||ny>=m) continue; if(!vis[nx][ny]) { dis[x][nx][ny]=dis[x][nowx][nowy]+1; vis[nx][ny]=1; q.push(mp(nx,ny)); } } } } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n>>m>>k; for(int i=0; i&lt;n; i++) { for(int j=0; j&lt;m; j++) { cin>>a[i][j]; col[a[i][j]].push_back(mp(i,j)); } } for(int i=1; i&lt;=k; i++) bfs(i); int q; cin>>q; while(q--) { int x1,y1,x2,y2; cin>>x1>>y1>>x2>>y2; x1--,x2--,y1--,y2--; int ans=abs(x1-x2)+abs(y1-y2); for(int i=1; i&lt;=k; i++) ans=min(ans,dis[i][x1][y1]+dis[i][x2][y2]+1); cout&lt;&lt;ans&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"http://yoursite.com/tags/BFS/"}],"author":"小凡"},{"title":"CodeForces-1301D Time to Run","slug":"CF1301D","date":"2020-03-18T09:34:57.000Z","updated":"2020-03-18T09:39:09.318Z","comments":true,"path":"2020/03/18/CF1301D/","link":"","permalink":"http://yoursite.com/2020/03/18/CF1301D/","excerpt":"","text":"传送门：CodeForces-1301D 思路分析构造一种走法，可以走完所有的边： 向右走m-1步到达右上角 向下走n-1步再向上走n-1步回到原处 向左走一步 重复2，3直到回到左上角 向下走一步 向右走m-1步，再向左走m-1步回到原处 重复5，6 最后向上走n-1步回到原点 样例输入3 3 4样例输出YES 2 2 R 2 LAC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; vector&lt;pair&lt;int,char> >ans; int n,m,k; void go(int s,char x) { if(!s)return ; if(k&lt;=s) { ans.push_back(mp(k,x)); cout&lt;&lt;\"YES\\n\"&lt;&lt;ans.size()&lt;&lt;endl; for(auto i:ans) cout&lt;&lt;i.fi&lt;&lt;\" \"&lt;&lt;i.se&lt;&lt;endl; exit(0); } k-=s; ans.push_back(mp(s,x)); } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n>>m>>k; go(m-1,'R'); for(int i=1; i&lt;=m-1; i++) { go(n-1,'D'); go(n-1,'U'); go(1,'L'); } for(int i=1; i&lt;=n-1; i++) { go(1,'D'); go(m-1,'R'); go(m-1,'L'); } go(n-1,'U'); cout&lt;&lt;\"NO\"&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"}],"author":"小凡"},{"title":"CodeForces-1304E 1-Trees and Queries","slug":"CF1304E","date":"2020-03-18T05:51:16.000Z","updated":"2020-03-18T05:56:40.304Z","comments":true,"path":"2020/03/18/CF1304E/","link":"","permalink":"http://yoursite.com/2020/03/18/CF1304E/","excerpt":"","text":"传送门：CodeForces-1304E 思路分析考虑添加一条边出现的情况，从$a$到$b$的路径有三条 $dis(a,b)$ $dis(a,x)+dis(b,y)+1$ $dis(a,y)+dis(b,x)+1$ 两点距离可以通过LCA求出判断三种情况与$k$的关系，如果差值为偶数，说明可以往返一条边来凑足 样例输入5 1 2 2 3 3 4 4 5 5 1 3 1 2 2 1 4 1 3 2 1 4 1 3 3 4 2 3 3 9 5 2 3 3 9样例输出YES YES NO YES NOAC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e6+10; struct node { int v,next; } e[N]; int cnt,head[N],dep[N],fa[N][22],lg[N]; void add(int u,int v) { e[++cnt].v=v; e[cnt].next=head[u]; head[u]=cnt; } void dfs(int u,int f) { fa[u][0]=f; dep[u]=dep[f]+1; for(int i=1; i&lt;=lg[dep[u]]; i++) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[u]; i; i=e[i].next) if(e[i].v!=f) dfs(e[i].v,u); } int lca(int x,int y) { if(dep[x]&lt;dep[y]) swap(x,y); while(dep[x]>dep[y]) x=fa[x][lg[dep[x]-dep[y]]-1]; if(x==y) return x; for(int k=lg[dep[x]]-1; k>=0; k--) if(fa[x][k]!=fa[y][k]) x=fa[x][k],y=fa[y][k]; return fa[x][0]; } int dis(int x,int y) { return dep[x]+dep[y]-2*dep[lca(x,y)]; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,q; cin>>n; for(int i=1; i&lt;n; i++) { int u,v; cin>>u>>v; add(u,v); add(v,u); } for(int i=1; i&lt;=n; i++) lg[i]=lg[i-1]+((1&lt;&lt;lg[i-1])==i); dfs(1,-1); cin>>q; while(q--) { int x,y,a,b,k; cin>>x>>y>>a>>b>>k; bool ok=false; int len=dis(a,b); if((k-len)%2==0 &amp;&amp; len&lt;=k) ok=true; len=dis(a,x)+dis(b,y)+1; if((k-len)%2==0 &amp;&amp; len&lt;=k) ok=true; len=dis(a,y)+dis(b,x)+1; if((k-len)%2==0 &amp;&amp; len&lt;=k) ok=true; cout&lt;&lt;(ok?\"YES\":\"NO\")&lt;&lt;\"\\n\"; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"http://yoursite.com/tags/LCA/"}],"author":"小凡"},{"title":"CodeForces-1321E Battle for Azathoth","slug":"CF1321E","date":"2020-03-17T16:44:05.000Z","updated":"2020-03-17T16:45:45.165Z","comments":true,"path":"2020/03/18/CF1321E/","link":"","permalink":"http://yoursite.com/2020/03/18/CF1321E/","excerpt":"","text":"传送门：CodeForces-1321E 思路分析将武器和防具从小到大排序，怪物按防御力从小到大排序因为武器是递增的，所以能杀死的怪物是逐渐增多的，怎么计算贡献呢对于每一件防具，加上能抵抗的怪物的价值，那么在枚举武器的时候，同时枚举怪物，对于每一只怪物，更新所有防具的贡献防具区间可以通过二分查找实现，然后更新操作可以通过线段树区间覆盖完成，维护一下区间最大值 样例输入2 3 3 2 3 4 7 2 4 3 2 5 11 1 2 4 2 1 6 3 4 6样例输出1AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); #define int long long using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 1e18; const int N=1e6+10; struct node { int l,r,mid,ma,lazy; } tree[N&lt;&lt;2]; struct wuqi { int a,b; bool operator &lt;(const wuqi &amp;x)const { return a&lt;x.a; } } a[N]; struct fangju { int a,b; bool operator &lt;(const fangju &amp;x)const { return a&lt;x.a; } } b[N]; struct guaiwu { int a,b,c; bool operator &lt;(const guaiwu &amp;x)const { return a&lt;x.a; } } c[N]; int d[N]; void pp(int x) { tree[x].ma=max(tree[ls].ma,tree[rs].ma); } void pd(int x) { if(tree[x].lazy) { tree[ls].lazy+=tree[x].lazy; tree[rs].lazy+=tree[x].lazy; tree[ls].ma+=tree[x].lazy; tree[rs].ma+=tree[x].lazy; tree[x].lazy=0; } } void build(int x,int l,int r) { tree[x]= {l,r,l+r>>1,0,0}; if(l==r) { tree[x].ma=-b[l].b; return ; } int mid=tree[x].mid; build(ls,l,mid); build(rs,mid+1,r); pp(x); } void change(int x,int l,int r,int k) { if(l&lt;=tree[x].l&amp;&amp;tree[x].r&lt;=r) { tree[x].lazy+=k; tree[x].ma+=k; return; } pd(x); int mid=tree[x].mid; if(l&lt;=mid) change(ls,l,r,k); if(r>mid) change(rs,l,r,k); pp(x); } signed main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,m,p; cin>>n>>m>>p; for(int i=1; i&lt;=n; i++) cin>>a[i].a>>a[i].b; for(int i=1; i&lt;=m; i++) cin>>b[i].a>>b[i].b; for(int i=1; i&lt;=p; i++) cin>>c[i].a>>c[i].b>>c[i].c; sort(a+1,a+1+n); sort(b+1,b+1+m); sort(c+1,c+1+p); for(int i=1; i&lt;=m; i++) d[i]=b[i].a; build(1,1,m); int ans=-INF; for(int i=1,pos=1; i&lt;=n; i++) { while(pos&lt;=p &amp;&amp; c[pos].a&lt;a[i].a) { int w=upper_bound(d+1,d+1+m,c[pos].b)-d; if(w&lt;=m) change(1,w,m,c[pos].c); pos++; } ans=max(ans,tree[1].ma-a[i].b); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"author":"小凡"},{"title":"CodeForces-1305F Kuroni and the Punishment","slug":"CF1305F","date":"2020-03-17T14:12:41.000Z","updated":"2020-03-17T14:25:43.627Z","comments":true,"path":"2020/03/17/CF1305F/","link":"","permalink":"http://yoursite.com/2020/03/17/CF1305F/","excerpt":"","text":"传送门：CodeForces-1305F 思路分析考虑最坏情况，当$gcd$为$2$的时候，最坏$n$次操作就能满足，因此操作上限是$n$若$gcd$不为$1$，只要每个数都能整除某个质因子$p$,每个数组贪心的统计答案因为上面得到了操作上限，可以推出，在最优的情况下，至少有一半的数操作最多$1$次所以在数列里随机找一个数，这个有$\\frac{1}{2}$的概率找到最多只操作一次的数然后将这个数的三种情况进行质因数分解，插入到集合中，最后枚举每个质因子进行30次抽取，得不到正确答案的概率为$2^{-30}$，概率非常小 样例输入5 9 8 7 3 1样例输出4AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;chrono> #include &lt;random> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define lowbit(x) x&amp;(-x) #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); const int INF = 0x3f3f3f3f; const int N=1e6+10; set&lt;ll>s; ll a[N]; void init(ll x) { for(ll i=2; i*i&lt;=x; i++) { if(x%i==0) { while(x%i==0)x/=i; s.insert(i); } } if(x>1) s.insert(x); } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=0; i&lt;n; i++) cin>>a[i]; for(int i=1; i&lt;=30; i++) { int x=rng()%n; if(a[x]>2) init(a[x]-1); init(a[x]); init(a[x]+1); } ll ans=n+1; for(auto x:s) { ll sum=0; for(int i=0; i&lt;n; i++) { if(a[i]>=x) sum+=min(a[i]%x,x-a[i]%x); else sum+=x-a[i]; } ans=min(ans,sum); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"随机化","slug":"随机化","permalink":"http://yoursite.com/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"}],"author":"小凡"},{"title":"CodeForces-1305E Kuroni and the Score Distribution（构造）","slug":"CF1305E","date":"2020-03-17T12:55:19.000Z","updated":"2020-03-17T13:05:28.483Z","comments":true,"path":"2020/03/17/CF1305E/","link":"","permalink":"http://yoursite.com/2020/03/17/CF1305E/","excerpt":"","text":"传送门：CodeForces-1305E 思路分析如果一开始从1，2，3这样递增排列，那么对于每一个$i$，它的贡献是$(i-1)/2$如果最后一位加上2，那么它的贡献就会少1，所以先构造到数量大于等于$m$的排列然后将最后一位加上$(sum-m)*2$,剩下没有构造的数从最后面开始，构造一个从$10^9$开始公差为最后一位+1的递减序列 样例输入5 3样例输出4 5 9 13 18AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e6+10; int ans[N]; int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,m,i; cin>>n>>m; int sum=0; for(i=1;i&lt;=n &amp;&amp; sum&lt;m;i++){ sum+=(i-1)/2; ans[i]=i; } if(sum&lt;m){ cout&lt;&lt;-1&lt;&lt;endl; return 0; } if(sum>m){ --i; ans[i]+=(sum-m)*2; ++i; } int ma=1e9; for(int j=n;j>=i;j--){ ans[j]=ma; ma-=ans[i-1]+1; } for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;\" \"; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"}],"author":"小凡"},{"title":"HDU - 6582 Path","slug":"HDU6582","date":"2020-03-17T07:32:55.000Z","updated":"2020-03-17T07:38:51.118Z","comments":true,"path":"2020/03/17/HDU6582/","link":"","permalink":"http://yoursite.com/2020/03/17/HDU6582/","excerpt":"","text":"传送门：HDU - 6582 思路分析删掉一些边，使得$1$到$n$的最短路变长很明显的最小割问题，可能删除的边一定是最短路上经过的边那么怎么判断哪些边是最短路上的呢，连反向边令$d1$为1到各个点的距离，$d2$为$n$到各个点的距离比如一条边$u–v$边权为$w$如果这条边是最短路上的边，那么一定满足$d1[u]+d2[v]+w==d1[n]$将满足条件的点全部连边跑一遍最小割就行了 样例输入1 3 4 1 2 1 2 3 1 1 3 2 1 3 3样例输出3AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); #define int long long using namespace std; const int INF = 1e18; const int N=1e5+10; vector&lt;pair&lt;int,int>>e1[N],e2[N]; struct node { int v,w,next; } e[N]; int cnt=1,head[N&lt;&lt;1],d1[N],d2[N],dep[N],vis[N]; int n,m; void add(int u,int v,int w) { e[++cnt].v=v; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt; } void dij(int s,int *dis,vector&lt;pair&lt;int,int>> *edge) { for(int i=0;i&lt;=n;i++){ dis[i]=INF; vis[i]=0; } dis[s]=0; priority_queue&lt;pair&lt;int,int> > q; q.push(make_pair(-dis[s],s)); while(!q.empty()) { int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; for(auto i:edge[u]) { int v=i.fi; int w=i.se; if(!vis[v]&amp;&amp;dis[v]>dis[u]+w) { dis[v]=dis[u]+w; q.push(make_pair(-dis[v],v)); } } } } bool bfs(int s,int t) { queue&lt;int>q; mem(dep,0); dep[s]=1; q.push(s); while(!q.empty()) { int u=q.front(); q.pop(); for(int i=head[u]; i ; i=e[i].next) { int v=e[i].v; int w=e[i].w; if(w &amp;&amp; !dep[v]) { dep[v]=dep[u]+1; q.push(v); } } } return dep[t]; } int dfs(int u,int f,int t) { int fl=0; if(u==t) return f; for(int i=head[u]; i &amp;&amp; f ; i=e[i].next) { int v=e[i].v; if(dep[v]==dep[u]+1 &amp;&amp; e[i].w) { int nx=dfs(v,min(f,e[i].w),t); e[i].w-=nx; e[i^1].w+=nx; f-=nx; fl+=nx; } } if(!fl) dep[u]=-2; return fl; } int dinic(int s,int t) { int ans=0; while(bfs(s,t)) ans+=dfs(s,INF,t); return ans; } signed main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; scanf(\"%lld\",&amp;t); while(t--) { cnt=1; mem(head,0); scanf(\"%lld%lld\",&amp;n,&amp;m); while(m--) { int u,v,w; scanf(\"%lld%lld%lld\",&amp;u,&amp;v,&amp;w); e1[u].push_back(mp(v,w)); e2[v].push_back(mp(u,w)); } dij(1,d1,e1); dij(n,d2,e2); if(d1[n]==INF) { puts(\"0\"); continue; } for(int u=1; u&lt;=n; u++) { for(auto i:e1[u]) { int v=i.fi; int w=i.se; if(d1[u]+d2[v]+w==d1[n]) { add(u,v,w); add(v,u,0); } } } printf(\"%lld\\n\",dinic(1,n)); for(int i=1;i&lt;=n;i++){ e1[i].clear(); e2[i].clear(); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"author":"小凡"},{"title":"HDU - 3308 LCIS","slug":"HDU3308","date":"2020-03-17T07:19:30.000Z","updated":"2020-03-17T07:23:51.375Z","comments":true,"path":"2020/03/17/HDU3308/","link":"","permalink":"http://yoursite.com/2020/03/17/HDU3308/","excerpt":"","text":"传送门：HDU - 3308 思路分析一个节点维护5个主要的值 ma 区间最长 lma 从左端点开始的最长 rma 从右端点开始的最长 lsum 左端点的值 rsum 右端点的值 样例输入1 10 10 7 7 3 3 5 9 9 8 1 8 Q 6 6 U 3 4 Q 0 1 Q 0 5 Q 4 7 Q 3 5 Q 0 2 Q 4 6 U 6 10 Q 0 9样例输出1 1 4 2 3 1 2 5AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e5+10; struct node { int l,r,mid,len,ma,lma,rma,lsum,rsum; } tree[N&lt;&lt;2]; int a[N]; void merge(node &amp;ans,node &amp;lson,node &amp;rson) { ans.ma=max(rson.ma,lson.ma); ans.lsum=lson.lsum; ans.rsum=rson.rsum; if(lson.rsum&lt;rson.lsum) ans.ma=max(ans.ma,lson.rma+rson.lma); ans.lma=lson.lma; if(lson.rsum&lt;rson.lsum &amp;&amp; lson.lma==lson.len) ans.lma+=rson.lma; ans.rma=rson.rma; if(lson.rsum&lt;rson.lsum &amp;&amp; rson.lma==rson.len) ans.rma+=lson.rma; } void pp(int x) { merge(tree[x],tree[ls],tree[rs]); } void build(int x,int l,int r) { tree[x].l=l; tree[x].r=r; tree[x].mid=l+r>>1; tree[x].len=r-l+1; if(l==r) { tree[x].ma=tree[x].lma=tree[x].rma=1; tree[x].lsum=tree[x].rsum=a[l]; return ; } int mid=tree[x].mid; build(ls,l,mid); build(rs,mid+1,r); pp(x); } void change(int x,int pos,int v) { if(tree[x].l==pos &amp;&amp; tree[x].r==pos) { tree[x].lsum=tree[x].rsum=v; return ; } int mid=tree[x].mid; if(pos&lt;=mid) change(ls,pos,v); if(pos>mid) change(rs,pos,v); pp(x); } node query(int x,int l,int r) { if(l&lt;=tree[x].l&amp;&amp;tree[x].r&lt;=r) { return tree[x]; } int mid=tree[x].mid; if(r&lt;=mid) { return query(ls,l,r); } else if(l>mid) { return query(rs,l,r); } else { node lson,rson,ans; lson=query(ls,l,r); rson=query(rs,l,r); merge(ans,lson,rson); return ans; } } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; while(t--) { int n,m; cin>>n>>m; for(int i=1; i&lt;=n; i++) cin>>a[i]; build(1,1,n); while(m--) { char a; int l,r; cin>>a>>l>>r; if(a=='U') change(1,l+1,r); else cout&lt;&lt;query(1,l+1,r+1).ma&lt;&lt;endl; } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"author":"小凡"},{"title":"AcWing - 1326 军训队列","slug":"acwing1326","date":"2020-03-16T10:05:46.000Z","updated":"2020-03-16T10:54:41.870Z","comments":true,"path":"2020/03/16/acwing1326/","link":"","permalink":"http://yoursite.com/2020/03/16/acwing1326/","excerpt":"","text":"传送门：AcWing - 1326 思路分析贪心的想，最小化差值，大小相近的放在一起，所以先对数据进行排序dp[i][j]表示前面i个人，分为j个队列的最小值对答案有影响的就是最后一个队列怎么排的枚举最后一个队列的起始位置，然后就可以转移了 样例输入3 2 170 180 168样例输出4AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; int a[555]; int dp[555][555]; int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,m; cin>>n>>m; for(int i=1; i&lt;=n; i++)cin>>a[i]; sort(a+1,a+1+n); mem(dp,INF); dp[0][0]=0; for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=i &amp;&amp; j&lt;=m; j++) for(int k=i; k>=j; k--) dp[i][j]=min(dp[i][j],dp[k-1][j-1]+(a[i]-a[k])*(a[i]-a[k])); cout&lt;&lt;dp[n][m]&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"CodeForces-1325E Ehab's REAL Number Theory Problem（最小环）","slug":"CF1325E","date":"2020-03-15T13:34:27.000Z","updated":"2020-03-15T13:46:44.992Z","comments":true,"path":"2020/03/15/CF1325E/","link":"","permalink":"http://yoursite.com/2020/03/15/CF1325E/","excerpt":"","text":"传送门：CodeForces-1325E 思路分析从n个数里面，选出最少的数，使得乘积为完全平方。如果其中有1，那么答案肯定为1，如果有两个相同的数，答案也为1首先，对于一个数，如果他自己的因数中存在完全平方数，那么可以将这个数除掉，对答案并没有影响因为最多只有7个因数，所以一个数最多有两个素数因子那么一个数可以划分为两种形式 $1×c$ $a×b$ 然后对于每一个数，在两个因数之间连边，那么答案就是图中的最小环但是如果要求每一个点所在的最小环，复杂度是$n^2$的，显然不行令$m=\\sqrt{max(a_i)}$，那么对于大于$m$的数之间是肯定没有边的也就是说，最小环上的点一定有$≤m$的所以只需要对$≤m$的点进行一遍BFS就行了 样例输入3 6 15 10样例输出3AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e6+10; int n; int vis[N],dis[N]; vector&lt;int>a,us,e[N]; int init(int x) { for(int i=2; i*i&lt;=x; i++) { if(x%i==0) { int cnt=0; while(x%i==0) { cnt++; x/=i; } if(cnt&amp;1) x*=i; } } return x; } int bfs(int s) { for(auto i:us) { dis[i]=INF; vis[i]=0; } queue&lt;int>q; dis[s]=0; q.push(s); int ans=INF; while(!q.empty()) { int u=q.front(); q.pop(); vis[u]=0; for(auto v:e[u]) { if(dis[v]>dis[u]+1) { dis[v]=dis[u]+1; vis[v]=1; q.push(v); } else if(vis[v]) { ans=min(ans,dis[u]+dis[v]+1); } } } return ans; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n; for(int i=0; i&lt;n; i++) { int x; cin>>x; a.push_back(init(x)); } sort(all(a)); a.erase(unique(all(a)),a.end()); if(a[0]==1) { cout&lt;&lt;1&lt;&lt;endl; return 0; } if(a.size()&lt;n) { cout&lt;&lt;2&lt;&lt;endl; return 0; } for(int i=0; i&lt;n; i++) { int t1=a[i]; int t2=1; for(int j=2; j*j&lt;=a[i]; j++) { if(a[i]%j==0) { t1=j; t2=a[i]/j; break; } } us.push_back(t1); us.push_back(t2); e[t1].push_back(t2); e[t2].push_back(t1); } sort(all(us)); us.erase(unique(all(us)),us.end()); int ans=INF; for(int i=1; i&lt;=1000; i++) { if(!e[i].empty()) ans=min(ans,bfs(i)); } cout&lt;&lt;(ans==INF?-1:ans)&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"author":"小凡"},{"title":"CodeForces-1281C Cut and Paste","slug":"CF1281C","date":"2020-03-14T07:50:56.000Z","updated":"2020-03-14T07:53:35.997Z","comments":true,"path":"2020/03/14/CF1281C/","link":"","permalink":"http://yoursite.com/2020/03/14/CF1281C/","excerpt":"","text":"传送门：CodeForces-1281C 思路分析实际上，每次复制的次数都只跟前面n个字符有关，所以只要构造出长度为n的字符串，之后的长度都可以通过计算得到 样例输入4 5 231 7 2323 6 333 24 133321333样例输出25 1438 1101 686531475AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int mod=1e9+7; int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; while(t--) { int n; string s; cin>>n>>s; int l=1; int len=s.size(); while(len&lt;n) { for(int i=1; i&lt;s[l-1]-'0'; i++) s+=s.substr(l,len-l); len=s.size(); l++; } ll ans=s.size()%mod; for(int i=l; i&lt;=n; i++) ans=(ans+1LL*(s[i-1]-'0'-1)%mod*(ans-i)%mod+mod)%mod; cout&lt;&lt;ans&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"}],"author":"小凡"},{"title":"牛客练习赛59 - C 装备合成","slug":"NK4743C","date":"2020-03-14T05:59:14.000Z","updated":"2020-03-14T06:03:13.084Z","comments":true,"path":"2020/03/14/NK4743C/","link":"","permalink":"http://yoursite.com/2020/03/14/NK4743C/","excerpt":"","text":"传送门：牛客练习赛59 - C 题目描述牛牛有$x$件材料$a$和$y$件材料$b$，2个材料$a$和3个材料$b$可以合成一个装备，4个材料$a$和1个材料$b$可以合成一个装备，最大化装备数量 输入描述输入包含$t$组数据第一行一个整数$t$接下来$t$行每行两个整数$x$,$y$ 输出描述每组数据输出一行一个整数表示答案。 思路分析整数三分 样例输入5 4 8 7 6 8 10 100 4555 45465 24124样例输出2 2 3 50 13917AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; int a,b; int get(int x) { return x+min((a-2*x)/4,(b-3*x)); } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; while(t--) { cin>>a>>b; int r=min(a/2,b/3); int l=0; while(r>l) { int m1=l+(r-l)/3; int m2=r-(r-l)/3; if(get(m1)>get(m2)) r=m2-1; else l=m1+1; } cout&lt;&lt;get(l)&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"三分","slug":"三分","permalink":"http://yoursite.com/tags/%E4%B8%89%E5%88%86/"}],"author":"小凡"},{"title":"CodeForces-1324F Maximum White Subtree","slug":"CF1324F","date":"2020-03-13T06:50:44.000Z","updated":"2020-03-13T06:59:44.549Z","comments":true,"path":"2020/03/13/CF1324F/","link":"","permalink":"http://yoursite.com/2020/03/13/CF1324F/","excerpt":"","text":"传送门：CodeForces-1324F 题目描述You are given a tree consisting of $n$ vertices. A tree is a connected undirected graph with n−1 edges. Each vertex v of this tree has a color assigned to it （$a_v=1$ if the vertex $v$ is white and 0 if the vertex $v$ is black）. You have to solve the following problem for each vertex v: what is the maximum difference between the number of white and the number of black vertices you can obtain if you choose some subtree of the given tree that contains the vertex $v$? The subtree of the tree is the connected subgraph of the given tree. More formally, if you choose the subtree that contains $cnt_w$ white vertices and $cnt_b$ black vertices, you have to maximize $cnt_w−cnt_b$. 输入描述The first line of the input contains one integer $n$ $(2≤n≤2⋅10^5)$ — the number of vertices in the tree. The second line of the input contains $n$ integers $a_1,a_2,…,a_n$ $(0≤a_i≤1)$, where $a_i$ is the color of the $i$-th vertex. Each of the next $n−1$ lines describes an edge of the tree. Edge $i$ is denoted by two integers $u_i$ and $v_i$, the labels of vertices it connects $(1≤u_i,v_i≤n,u_i≠v_i)$. It is guaranteed that the given edges form a tree. 输出描述Print $n$ integers $res_1,res_2,…,res_n$, where $res_i$ is the maximum possible difference between the number of white and black vertices in some subtree that contains the vertex $i$. 思路分析$dp[i]$表示以$i$为根的答案，但是需要每一个点的答案，所以需要换根 样例输入9 0 1 1 1 0 0 0 0 1 1 2 1 3 3 4 3 5 2 6 4 7 6 8 5 9样例输出2 2 2 2 2 1 1 0 2 AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e6+10; int dp[N],ans[N]; vector&lt;int>e[N]; void dfs1(int u,int fa) { for(auto v:e[u]) { if(v==fa)continue; dfs1(v,u); dp[u]+=max(0,dp[v]); } } void dfs2(int u,int fa) { ans[u]=dp[u]; for(auto v:e[u]) { if(v==fa)continue; dp[u]-=max(0,dp[v]); dp[v]+=max(0,dp[u]); dfs2(v,u); dp[v]-=max(0,dp[u]); dp[u]+=max(0,dp[v]); } } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=1; i&lt;=n; i++) { cin>>dp[i]; if(!dp[i]) dp[i]=-1; } for(int i=0; i&lt;n-1; i++) { int u,v; cin>>u>>v; e[u].push_back(v); e[v].push_back(u); } dfs1(1,-1); dfs2(1,-1); for(int i=1; i&lt;=n; i++) cout&lt;&lt;ans[i]&lt;&lt;\" \\n\"[i==n]; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"小凡"},{"title":"CodeForces-1324E Sleeping Schedule","slug":"CF1324E","date":"2020-03-13T06:45:15.000Z","updated":"2020-03-13T06:50:24.594Z","comments":true,"path":"2020/03/13/CF1324E/","link":"","permalink":"http://yoursite.com/2020/03/13/CF1324E/","excerpt":"","text":"传送门：CodeForces-1324E 题目描述Vova had $a$ pretty weird sleeping schedule. There are h hours in a day. Vova will sleep exactly $n$ times. The $i$-th time he will sleep exactly after $a_i$ hours from the time he woke up. You can assume that Vova woke up exactly at the beginning of this story . Each time Vova sleeps exactly one day Vova thinks that the $i$-th sleeping time is good if he starts to sleep between hours $l$ and $r$ inclusive. Vova can control himself and before the $i$-th time can choose between two options: go to sleep after $a_i$ hours or after $a_i−1$ hours. Your task is to say the maximum number of good sleeping times Vova can obtain if he acts optimally. 输入描述The first line of the input contains four integers $n,h,l$ and $r$ $(1≤n≤2000,3≤h≤2000,0≤l≤r&lt;h)$ — the number of times Vova goes to sleep, the number of hours in a day and the segment of the good sleeping time. The second line of the input contains $n$ integers $a_1,a_2,…,a_n$ $(1≤a_i&lt;h)$, where $a_i$ is the number of hours after which Vova goes to sleep the $i$-th time. 输出描述Print one integer — the maximum number of good sleeping times Vova can obtain if he acts optimally. 思路分析$dp[i][j]$表示对于前$i$个时间，有$j$个选择了$-1$的最多good次数转移就很明显了，用前缀和预处理一下 样例输入7 24 21 23 16 17 14 20 20 11 22样例输出3AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e5+10; int dp[2020][2020]; int s[N]; int n,d,l,r; int judge(int x) { x%=d; if(x>=l&amp;&amp;x&lt;=r) return 1; else return 0; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n>>d>>l>>r; for(int i=1; i&lt;=n; i++) { int x; cin>>x; s[i]=s[i-1]+x; } int ans=-INF; for(int i=1; i&lt;=n; i++) for(int j=0; j&lt;=i; j++) dp[i][j]=max(dp[i-1][j-1!=-1?j-1:0],dp[i-1][j])+judge(s[i]-j); for(int i=0; i&lt;=n; i++) ans=max(ans,dp[n][i]); cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"CodeForces-1278D Segment Tree","slug":"CF1278D","date":"2020-03-11T12:53:15.000Z","updated":"2020-03-11T13:00:24.507Z","comments":true,"path":"2020/03/11/CF1278D/","link":"","permalink":"http://yoursite.com/2020/03/11/CF1278D/","excerpt":"","text":"传送门：CodeForces-1278D 题目描述As the name of the task implies, you are asked to do some work with segments and trees. Recall that a tree is a connected undirected graph such that there is exactly one simple path between every pair of its vertices. You are given $n$ segments $[l_1,r_1],[l_2,r_2],…,[l_n,r_n]$, $l_i&lt;r_i$ for every $i$. It is guaranteed that all segments’ endpoints are integers, and all endpoints are unique — there is no pair of segments such that they start in the same point, end in the same point or one starts in the same point the other one ends. Let’s generate a graph with n vertices from these segments. Vertices $v$ and $u$ are connected by an edge if and only if segments $[l_v,r_v]$ and $[l_u,r_u]$ intersect and neither of it lies fully inside the other one. For example, pairs $([1,3],[2,4])$ and $([5,10],[3,7])$ will induce the edges but pairs $([1,2],[3,4])$ and $([5,7],[3,10])$ will not. Determine if the resulting graph is a tree or not. 输入描述The first line contains a single integer $n$ $(1≤n≤5⋅10^5)$ — the number of segments. The $i$-th of the next n lines contain the description of the $i$-th segment — two integers $l_i$ and $r_i$ $(1≤l_i&lt;r_i≤2*n)$. It is guaranteed that all segments borders are pairwise distinct. 输出描述Print “YES” if the resulting graph is a tree and “NO” otherwise. 思路分析一棵树的概念为只有$n-1$条边，且所有点的父亲都是一个点（并查集维护）所以枚举需要连边的点，超过$n-1$或者两个已经连通的话肯定不行暴力枚举肯定不行，可以将线段按照左端点排序，并用set维护之前的右端点，二分查找满足相交的区间就行了 样例输入6 9 12 2 11 1 3 6 10 5 7 4 8样例输出YESAC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e6+10; int f[N]; pair&lt;int,int>a[N]; set&lt;pair&lt;int,int>>s; int find(int x) { return f[x]==x?x:f[x]=find(f[x]); } bool merge(int x,int y) { int t1=find(x); int t2=find(y); if(t1==t2)return false; f[t2]=t1; return true; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=0; i&lt;n; i++) { cin>>a[i].fi>>a[i].se; f[i]=i; } sort(a,a+n); int cnt=0; for(int i=0; i&lt;n; i++) { for(auto j=s.upper_bound(mp(a[i].fi,0)); j!=s.end(); j++) { if(a[i].se>j->fi) { cnt++; if(cnt>n-1 || !merge(i,j->se)) { cout&lt;&lt;\"NO\"&lt;&lt;endl; return 0; } } else { break; } } s.insert(mp(a[i].se,i)); } cnt&lt;n-1?cout&lt;&lt;\"NO\"&lt;&lt;endl:cout&lt;&lt;\"YES\"&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"}],"author":"小凡"},{"title":"CodeForces-1312E Array Shrinking","slug":"CF1312E","date":"2020-03-10T12:09:32.000Z","updated":"2020-03-10T12:16:48.916Z","comments":true,"path":"2020/03/10/CF1312E/","link":"","permalink":"http://yoursite.com/2020/03/10/CF1312E/","excerpt":"","text":"传送门：CodeForces-1312E 题目描述You are given an array $a_1,a_2,…,a_n.$ You can perform the following operation any number of times: Choose a pair of two neighboring equal elements $a_i=a_{i+1}$ （if there is at least one such pair）. Replace them by one element with value $a_i+1$ After each such operation, the length of the array will decrease by one （and elements are renumerated accordingly）. What is the minimum possible length of the array $a$ you can get? 输入描述The first line contains the single integer $n$ $(1≤n≤500)$ — the initial length of the array $a$. The second line contains $n$ integers $a_1,a_2,…,a_n$ $(1≤a_i≤1000)$ — the initial array $a$ 输出描述Print the only integer — the minimum possible length you can get after performing the operation described above any number of times. 思路分析数据范围只有500，可以区间DP$dp[i][j]$表示$i$到$j$这个区间最后剩下几个元素，还需要另一个数组来记录$i$到$j$剩下的元素是多少然后枚举区间长度以及中间点，只有当左区间和右区间长度都为1的时候，且元素之间也符合关系，才能合并 样例输入7 3 3 4 4 4 3 3样例输出2AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1111; int dp[N][N],a[N][N]; int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=1; i&lt;=n; i++) for(int j=i+1; j&lt;=n; j++) dp[i][j]=j-i+1; for(int i=1; i&lt;=n; i++) { cin>>a[i][i]; dp[i][i]=1; } for(int len=2; len&lt;=n; len++) { for(int l=1,r=l+len-1; r&lt;=n; l++,r++) { for(int k=l; k&lt;=r; k++) { dp[l][r]=min(dp[l][r],dp[l][k]+dp[k+1][r]); if(dp[l][k]==1 &amp;&amp; dp[k+1][r]==1 &amp;&amp; a[l][k]==a[k+1][r]) { dp[l][r]=1; a[l][r]=a[l][k]+1; } } } } cout&lt;&lt;dp[1][n]&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"区间DP","slug":"区间DP","permalink":"http://yoursite.com/tags/%E5%8C%BA%E9%97%B4DP/"}],"author":"小凡"},{"title":"CodeForces-1323D Present","slug":"CF1323D","date":"2020-03-10T11:51:24.000Z","updated":"2020-03-10T12:08:50.072Z","comments":true,"path":"2020/03/10/CF1323D/","link":"","permalink":"http://yoursite.com/2020/03/10/CF1323D/","excerpt":"","text":"传送门：CodeForces-1323D 题目描述每两两组合形成一个数，求这些数的异或和 输入描述The first line contains $a$ single integer $n$ $(2≤n≤400000)$ — the number of integers in the array. The second line contains integers $a_1,a_2,…,a_n$ $(1≤a_i≤10^7).$ 输出描述Print a single integer — xor of all pairwise sums of integers in the given array. 思路分析一般这种二进制的题，都需要对分别每一位计算贡献对于第$i$位，大于这一位的跟答案没关系，所以可以创建一个新数组$b$为原数组第$i$位以下的部分只有$b_i+b_j$的第i位是1的时候才对答案有贡献即在$[2^i,2^{i+1}-1]\\bigcup[2^{i+1}+2^i,2^{i+2}-1]$的时候对答案有影响可以固定$i$然后二分查找符合条件的区间如果数量为奇数，那么这一位的答案是$1$ 样例输入2 1 2样例输出3AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e6+10; int a[N],b[N]; int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=0; i&lt;n; i++) cin>>a[i]; int ans=0; for(int i=0; i&lt;26; i++) { int p=(1&lt;&lt;(i+1))-1; for(int j=0; j&lt;n; j++) b[j]=a[j]&amp;p; sort(b,b+n); p=(1&lt;&lt;i); ll sum=0; for(int j=0; j&lt;n; j++) { int t1=lower_bound(b+j+1,b+n,p-b[j])-b; int t2=upper_bound(b+j+1,b+n,(p&lt;&lt;1)-1-b[j])-b; sum+=t2-t1; t1=lower_bound(b+j+1,b+n,(p&lt;&lt;1)+p-b[j])-b; t2=upper_bound(b+j+1,b+n,(p&lt;&lt;2)-1-b[j])-b; sum+=t2-t1; } if(sum&amp;1)ans+=p; } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"}],"author":"小凡"},{"title":"CodeForces-1305D Kuroni and the Celebration","slug":"CF1305D","date":"2020-03-06T16:12:21.000Z","updated":"2020-03-06T16:37:02.186Z","comments":true,"path":"2020/03/07/CF1305D/","link":"","permalink":"http://yoursite.com/2020/03/07/CF1305D/","excerpt":"","text":"传送门：CodeForces-1305D 题目描述给你一个树，每次询问两个点，返回这两个点的LCA，最多询问n/2次，找出根节点 思路分析就是一个删除叶子节点的过程：将边数为1的点，放进队列，每次取出两个点询问如果LCA是其中一个，那就是根如果不是，就将这两个点删除，并更新想连的点的边数，为1的进队列 样例输入6 1 4 4 2 5 3 6 3 2 3 3 4 4 样例输出? 5 6 ? 3 1 ? 1 2 ! 4AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N = 1e5 + 10; vector&lt;int>e[N]; int deg[N]; int main() { IOS; #ifdef xiaofan freopen(\"1.in\", \"r\", stdin); freopen(\"1.out\", \"w\", stdout); #endif int n; cin >> n; for (int i = 1; i &lt; n; i++) { int u, v; cin >> u >> v; e[u].push_back(v); e[v].push_back(u); deg[u]++; deg[v]++; } queue&lt;int>q; for (int i = 1; i &lt;= n; i++) if (deg[i] == 1) q.push(i); int time = n / 2; while (!q.empty() &amp;&amp; time--) { int r1 = q.front(); q.pop(); int r2 = q.front(); q.pop(); cout &lt;&lt; \"? \" &lt;&lt; r1 &lt;&lt; \" \" &lt;&lt; r2 &lt;&lt; endl; int root; cin >> root; if (root == r1 || root == r2) { cout &lt;&lt; \"! \" &lt;&lt; root &lt;&lt; endl; return 0; } deg[r1] = -1; deg[r2] = -1; for (auto v : e[r1]) { deg[v]--; if (deg[v] == 1) q.push(v); } for (auto v : e[r2]) { deg[v]--; if (deg[v] == 1) q.push(v); } } for (int i = 1; i &lt;= n; i++) if (!deg[i]) cout &lt;&lt; \"! \" &lt;&lt; i &lt;&lt; endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"交互","slug":"交互","permalink":"http://yoursite.com/tags/%E4%BA%A4%E4%BA%92/"}],"author":"小凡"},{"title":"CodeForces-1316E Team Building","slug":"CF1316E","date":"2020-03-06T15:03:35.000Z","updated":"2020-03-06T15:14:15.367Z","comments":true,"path":"2020/03/06/CF1316E/","link":"","permalink":"http://yoursite.com/2020/03/06/CF1316E/","excerpt":"","text":"传送门：CodeForces-1316E 题目描述$n$个人，$p$个位置，选$p$个人作为相应位置的运动员，选$k$个人作为观众，每个人都有自己作为观众和相应位置的权值 求最大的权值和 输入描述The first line contains $3$ integers $n,p,k$ $(2≤n≤10^5,1≤p≤7,1≤k,p+k≤n)$ The second line contains $n$ integers $a_1,a_2,…,a_n$ $(1≤a_i≤10^9)$ The $i$-th of the next $n$ lines contains $p$ integers $s_{i,1},s_{i,2},…,s_{i,p}.$ $(1≤s_{i,j}≤10^9)$ 输出描述Print a single integer res — the maximum possible strength of the club. 思路分析由于$p$很小，所以可以状压dp，将运动员位置有无情况作为状态表示$dp[i][j]$表示前$i$个人，状态为$j$的最大值 贪心的想，将每个人按观众实力排序，那么前$k+p$个人要么做观众要么做选手这样对于观众来说是最优的，选手可以转移 样例输入6 2 3 78 93 9 17 13 78 80 97 30 52 26 17 56 68 60 36 84 55样例输出377AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N = 1e5 + 10, M = 1 &lt;&lt; 7; struct node { int id, val; } a[N]; int w[N][10]; ll dp[N][M]; int cmp(node a, node b) { return a.val > b.val; } int count(int x) { int cnt = 0; while (x) { if (x &amp; 1)cnt++; x >>= 1; } return cnt; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\", \"r\", stdin); freopen(\"1.out\", \"w\", stdout); #endif int n, p, k; cin >> n >> p >> k; for (int i = 1; i &lt;= n; i++) { cin >> a[i].val; a[i].id = i; } for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= p; j++) cin >> w[i][j]; sort(a + 1, a + 1 + n, cmp); for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; 1 &lt;&lt; p; j++) { dp[i][j] = dp[i - 1][j]; int cnt = count(j); if (cnt &lt; i &amp;&amp; i - cnt &lt;= k) dp[i][j] = dp[i - 1][j] + a[i].val; for (int s = 1; s &lt;= p; s++) if (1 &lt;&lt; (s - 1)&amp;j) dp[i][j] = max(dp[i][j], dp[i - 1][j ^ (1 &lt;&lt; (s - 1))] + w[a[i].id][s]); } } cout &lt;&lt; dp[n][(1 &lt;&lt; p) - 1] &lt;&lt; endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"状压DP","slug":"状压DP","permalink":"http://yoursite.com/tags/%E7%8A%B6%E5%8E%8BDP/"}],"author":"小凡"},{"title":"CodeForces-1307D Cow and Fields","slug":"CF1307D","date":"2020-03-06T13:07:31.000Z","updated":"2020-03-06T13:48:48.069Z","comments":true,"path":"2020/03/06/CF1307D/","link":"","permalink":"http://yoursite.com/2020/03/06/CF1307D/","excerpt":"","text":"传送门：CodeForces-1307D 题目描述Bessie is out grazing on the farm, which consists of n fields connected by m bidirectional roads. She is currently at field $1$, and will return to her home at field $n$ at the end of the day. The Cowfederation of Barns has ordered Farmer John to install one extra bidirectional road. The farm has $k$ special fields and he has decided to install the road between two different special fields. He may add the road between two special fields that already had a road directly connecting them. After the road is added, Bessie will return home on the shortest path from field $1$ to field $n$. Since Bessie needs more exercise, Farmer John must maximize the length of this shortest path. Help him! 输入描述The first line contains integers $n$, $m$, and $k$ $(2≤n≤2⋅10^5, n−1≤m≤2⋅10^5, 2≤k≤n)$ — the number of fields on the farm, the number of roads, and the number of special fields. The second line contains $k$ integers $a_1,a_2,…,a_k$ $(1≤a_i≤n)$ — the special fields. All $a_i$ are distinct. The $i$-th of the following m lines contains integers xi and yi (1≤xi,yi≤n, xi≠yi), representing a bidirectional road between fields $x_i$ and $y_i$. It is guaranteed that one can reach any field from every other field. It is also guaranteed that for any pair of fields there is at most one road connecting them. 输出描述Output one integer, the maximum possible length of the shortest path from field $1$ to $n$ after Farmer John installs one road optimally. 思路分析$d1[i]$表示从$1$到$i$的最短距离$d2[i]$表示从$1$到$i$的最短距离 对于选择的两个点$i,j$如果对答案有影响，那么影响为$min(d1[i]+1+d2[j],d1[j]+1+d2[i])$如果枚举$i,j$的话肯定会超时 观察以上的式子，经过移项之后为$d1[i]-d2[j]&lt;d1[j]-d2[j]$令$F[x]=d1[x]-d2[x]$可以得出，两个关键点，优先选取$F[x]$小的那个点对关键点按$F[x]$排序，枚举$j$,对于每个$j$答案等于$j$之前的$d1[i]+1+d2[j]$最后再与初始的$d1[n]$取最小值就是答案 样例输入5 5 3 1 3 5 1 2 2 3 3 4 3 5 2 4样例输出3AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e6+10; vector&lt;int>e[N]; int n,m,k; int vis[N],d1[N],d2[N],p[N]; void spfa(int s,int *dis) { for(int i=0; i&lt;=n; i++) { dis[i]=INF; vis[i]=0; } queue&lt;int>q; q.push(s); dis[s]=0; while(!q.empty()) { int u=q.front(); q.pop(); vis[u]=0; for(auto v:e[u]) { if(dis[v]>dis[u]+1) { dis[v]=dis[u]+1; if(!vis[v]) { vis[v]=1; q.push(v); } } } } } int cmp(int a,int b) { return d1[a]-d2[a]&lt;d1[b]-d2[b]; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n>>m>>k; for(int i=0; i&lt;k; i++) cin>>p[i]; for(int i=0; i&lt;m; i++) { int u,v; cin>>u>>v; e[u].pb(v); e[v].pb(u); } spfa(1,d1); spfa(n,d2); sort(p,p+k,cmp); int ma=d1[p[0]]; int ans=-1; for(int i=1; i&lt;k; i++) { ans=max(ans,ma+d2[p[i]]+1); ma=max(ma,d1[p[i]]); } cout&lt;&lt;min(d1[n],ans)&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"author":"小凡"},{"title":"CodeForces-1321D  Navigation System","slug":"CF1321D","date":"2020-03-04T12:45:06.000Z","updated":"2020-03-04T12:52:52.864Z","comments":true,"path":"2020/03/04/CF1321D/","link":"","permalink":"http://yoursite.com/2020/03/04/CF1321D/","excerpt":"","text":"传送门：CodeForces-1321D 题目描述给出一个由 $n$ 个点和 $m$ 条边组成的有向图，现在有一个人，他有一条固定的路线，这个题目中有一个导航，当到达任意一个点时，导航都会给出一条通往终点的最短路，但是这个人固定的路线并不一定每次都是最短路，导航最初会给出一条最短路，如果这个人不按照最短路行走的话，那么导航需要“重构”最短路，题目问“重构”的最小次数和最大次数 思路分析先建反边，求出每个点到终点的最短路，然后题目给了$k-1$条边，对于每一条边$u-&gt;v$，判断一下： 如果这条边不在最短路上面$(dis[u]!=dis[v]+1)$说明肯定要重构，所以 $min++$，$max++$ 否则如果$u$与其他节点$nv$存在一条边，且$(dis[u]=dis[nv]+1)$,说明可以重构，$max++$ 样例输入6 9 1 5 5 4 1 2 2 3 3 4 4 1 2 6 6 4 4 2 4 1 2 3 4样例输出1 2AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N = 1e6 + 10; int n, m, a[N], dis[N], vis[N]; vector&lt;int>e[N], re[N]; void spfa(int s) { for (int i = 1; i &lt;= n; i++) { dis[i] = INF; vis[i] = 0; } queue&lt;int>q; vis[s] = 1; dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (auto v : re[u]) { if (dis[v] > dis[u] + 1) { dis[v] = dis[u] + 1; if (!vis[v]) { vis[v] = 1; q.push(v); } } } } } int main() { IOS; #ifdef xiaofan freopen(\"1.in\", \"r\", stdin); freopen(\"1.out\", \"w\", stdout); #endif cin >> n >> m; while (m--) { int u, v; cin >> u >> v; e[u].push_back(v); re[v].push_back(u); } int k; cin >> k; for (int i = 1; i &lt;= k; i++) cin >> a[i]; spfa(a[k]); int mi = 0, ma = 0; int u = a[1]; for (int i = 2; i &lt;= k; i++) { int v = a[i]; if (dis[u] != dis[v] + 1) { mi++; ma++; } else { for (auto nv : e[u]) { if (nv == v)continue; if (dis[u] == dis[nv] + 1) { ma++; break; } } } u = v; } cout &lt;&lt; mi &lt;&lt; \" \" &lt;&lt; ma &lt;&lt; endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"}],"author":"小凡"},{"title":"洛谷 - P3919 可持续化数组","slug":"luogu3919","date":"2020-03-04T12:38:05.000Z","updated":"2020-03-04T12:43:06.492Z","comments":true,"path":"2020/03/04/luogu3919/","link":"","permalink":"http://yoursite.com/2020/03/04/luogu3919/","excerpt":"","text":"传送门：洛谷 - P3919 题目描述维护两个操作： 在某个历史版本修改某个值 查询某个历史版本的一个值 每进行一次操作，就会生成一个新的版本 输入描述第一行包含两个整数$N$,$M$，分别表示数组长度和操作个数第二行包含$N$个数，表示初始数组接下来$M$行： $v_i$ $1$ $pos$ $val$ 表示在$v_i$个版本的$pos$位置上更改值为$val$ $v_i$ $2$ $pos$ 表示在$v_i$个版本查询$pos$位置上的值 输出描述输出答案 思路分析主席树维护普通线段树 样例输入5 10 59 46 14 87 41 0 2 1 0 1 1 14 0 1 1 57 0 1 1 88 4 2 4 0 2 5 0 2 4 4 2 1 2 2 2 1 1 5 91样例输出59 87 41 87 88 46AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N = 1e6 + 10; inline int read() { int s = 0, w = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') w = -1; for (; isdigit(c); c = getchar()) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (c ^ 48); return s * w; } struct node { int l, r, val; } tree[N &lt;&lt; 5]; int cnt, root[N], a[N]; void build(int l, int r, int &amp;x) { x = ++cnt; if (l == r) { tree[x].val = a[l]; return ; } int mid = l + r >> 1; build(l, mid, tree[x].l); build(mid + 1, r, tree[x].r); } inline void update(int l, int r, int ver, int &amp;x, int pos, int v) { x = ++cnt; tree[x] = tree[ver]; if (l == r) { tree[x].val = v; return ; } int mid = l + r >> 1; if (pos &lt;= mid) update(l, mid, tree[ver].l, tree[x].l, pos, v); else update(mid + 1, r, tree[ver].r, tree[x].r, pos, v); } inline int query(int x, int l, int r, int pos) { if (l == r) return tree[x].val; int mid = l + r >> 1; if (pos &lt;= mid) return query(tree[x].l, l, mid, pos); else return query(tree[x].r, mid + 1, r, pos); } int main() { #ifdef xiaofan freopen(\"1.in\", \"r\", stdin); freopen(\"1.out\", \"w\", stdout); #endif int n, m, ver, opt, x, y; n = read(); m = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); build(1, n, root[0]); for (int i = 1; i &lt;= m; i++) { ver = read(); opt = read(); switch (opt) { case 1: x = read(); y = read(); update(1, n, root[ver], root[i], x, y); break; case 2: x = read(); printf(\"%d\\n\", query(root[ver], 1, n, x)); root[i] = root[ver]; break; } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"主席树","slug":"主席树","permalink":"http://yoursite.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}],"author":"小凡"},{"title":"洛谷 - P3384 轻重链剖分","slug":"luogu3384","date":"2020-03-04T10:35:43.000Z","updated":"2020-03-27T05:22:55.501Z","comments":true,"path":"2020/03/04/luogu3384/","link":"","permalink":"http://yoursite.com/2020/03/04/luogu3384/","excerpt":"","text":"传送门：洛谷 - P3384 题目描述如题，已知一棵包含 $N$ 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作： 格式： $1$ $x$ $y$ $z$ 表示将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$ 格式： $2$ $x$ $y$ 表示求树从 $x$ 到 $y$ 结点最短路径上所有节点的值之和 格式： $3$ $x$ $z$ 表示将以 $x$ 为根节点的子树内所有节点值都加上 $z$ 格式： $4$ $x$ 表示求以 $x$ 为根节点的子树内所有节点值之和 输入描述第一行包含 $4$ 个正整数 $N$,$M$,$R$,$P$，分别表示树的结点个数、操作个数、根节点序号和取模数（即所有的输出结果均对此取模）接下来一行包含 $N$ 个非负整数，分别依次表示各个节点上初始的数值接下来 $N-1$ 行每行包含两个整数 $x$,$y$表示点 $x$ 和点 $y$ 之间连有一条边（保证无环且连通）接下来 $M$ 行每行包含若干个正整数，每行表示一个操作 输出描述输出答案 概念 重儿子：对于每一个非叶子节点，它的儿子中 以那个儿子为根的子树节点数最大的儿子 为该节点的重儿子 轻儿子：对于每一个非叶子节点，它的儿子中 非重儿子 的剩下所有儿子即为轻儿子叶子节点没有重儿子也没有轻儿子（因为它没有儿子。。） 重边：一个父亲连接他的重儿子的边称为重边 轻边：剩下的即为轻边 重链：相邻重边连起来的 连接一条重儿子 的链叫重链 对于叶子节点，若其为轻儿子，则有一条以自己为起点的长度为1的链 每一条重链以轻儿子为起点 dfs1（确定重儿子）这个dfs要处理几件事情： 标记每个点的深度dep 标记每个点的父亲fa 标记每个非叶子节点的子树大小（含它自己） 标记每个非叶子节点的重儿子编号son void dfs1(int u, int f) { fa[u] = f; //记录父亲 dep[u] = dep[f] + 1; //更新深度 siz[u] = 1; //子树大小 int maxsize = -1; //最大子树大小 for (auto v : e[u]) { if (v == f)continue; dfs1(v, u); siz[u] += siz[v]; if (siz[v] > maxsize) { //更新重儿子 son[u] = v; maxsize = siz[v]; } } } dfs2（标记时间戳）这个dfs要做以下事情： 标记每个点的时间戳 建立一个新的权值数组 确定每个重链的顶端 void dfs2(int u, int t) { top[u] = t; dfn[u] = ++tim; w[tim] = a[u]; if (!son[u]) //没有重儿子说明没有儿子了 return ; dfs2(son[u], t); //先处理重儿子 for (auto v : e[u]) { if (v == son[u] || v == fa[u]) continue; dfs2(v, v); //轻儿子作为顶端 } } 处理问题在链上的时间戳是连续的，所以区间问题可以用线段树维护 有两种情况： 两个点不在一条链上 两个点在一条链上 对与第一种情况： 设$x$为深度较大的那个点 $ans$加上$x$到$x$顶端的点权和 $x$更新为它的顶端 不断进行上述操作，直到两个点在同一链上复杂度为$O(log^2n)$ 对于第二种情况： 直接进行区间操作就行了 复杂度为$O(logn)$ 样例输入5 5 2 24 7 3 7 8 0 1 2 1 5 3 1 4 1 3 4 2 3 2 2 4 5 1 5 1 3 2 1 3样例输出2 21AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e6+10; struct node { int l,r,sum,mid,len,lazy; } tree[N&lt;&lt;2]; int a[N],mod; vector&lt;int>e[N]; int fa[N],dep[N],son[N],siz[N],tim,dfn[N],top[N],w[N]; void dfs1(int u,int f) { fa[u]=f; dep[u]=dep[f]+1; siz[u]=1; int maxsize=-1; for(auto v:e[u]) { if(v==f)continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]>maxsize) { son[u]=v; maxsize=siz[v]; } } } void dfs2(int u,int t) { top[u]=t; dfn[u]=++tim; w[tim]=a[u]; if(!son[u]) return ; dfs2(son[u],t); for(auto v:e[u]) { if(v==son[u]||v==fa[u]) continue; dfs2(v,v); } } void pp(int x) { tree[x].sum=(tree[ls].sum+tree[rs].sum)%mod; } void build(int x,int l,int r) { tree[x].l=l; tree[x].r=r; tree[x].mid=l+r>>1; tree[x].len=r-l+1; if(l==r) { tree[x].sum=w[l]; return ; } int mid=tree[x].mid; build(ls,l,mid); build(rs,mid+1,r); pp(x); } void pd(int x) { if(tree[x].lazy) { tree[ls].lazy=(tree[x].lazy+tree[ls].lazy)%mod; tree[rs].lazy=(tree[x].lazy+tree[rs].lazy)%mod; tree[rs].sum=(tree[rs].sum+tree[x].lazy*tree[rs].len)%mod; tree[ls].sum=(tree[ls].sum+tree[x].lazy*tree[ls].len)%mod; tree[x].lazy=0; } } void update(int x,int l,int r,int v) { if(l&lt;=tree[x].l &amp;&amp; tree[x].r&lt;=r) { tree[x].sum=(tree[x].sum+v*tree[x].len)%mod; tree[x].lazy=(tree[x].lazy+v)%mod; return ; } pd(x); int mid=tree[x].mid; if(l&lt;=mid) update(ls,l,r,v); if(r>mid) update(rs,l,r,v); pp(x); } int query(int x,int l,int r) { if(l&lt;=tree[x].l&amp;&amp;tree[x].r&lt;=r) { return tree[x].sum%mod; } pd(x); int mid=tree[x].mid; int ans=0; if(l&lt;=mid) ans+=query(ls,l,r)%mod; if(r>mid) ans+=query(rs,l,r)%mod; return ans%mod; } void cqson(int x,int y,int v) { v%=mod; while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); update(1,dfn[top[x]],dfn[x],v); x=fa[top[x]]; } if(dep[x]>dep[y]) swap(x,y); update(1,dfn[x],dfn[y],v); } int qqson(int x, int y) { int ret = 0; while (top[x] != top[y]) { if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); ret += query(1,dfn[top[x]], dfn[x]); x = fa[top[x]]; } if (dep[x] > dep[y]) swap(x, y); ret += query(1,dfn[x], dfn[y]); return ret % mod; } void cson(int x, int v) { update(1,dfn[x], dfn[x] + siz[x] - 1, v); } int qson(int x) { return query(1,dfn[x], dfn[x] + siz[x] - 1); } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,m,r; cin>>n>>m>>r>>mod; for(int i=1; i&lt;=n; i++) cin>>a[i]; for(int i=1; i&lt;n; i++) { int u,v; cin>>u>>v; e[u].push_back(v); e[v].push_back(u); } dfs1(r,r); dfs2(r,r); build(1,1,n); while(m--) { int opt, x, y, z; cin>>opt; switch (opt) { case 1: cin>>x>>y>>z; cqson(x, y, z); break; case 2: cin>>x>>y; cout&lt;&lt;qqson(x,y)&lt;&lt;endl; break; case 3: cin>>x>>z; cson(x,z); break; case 4: cin>>x; cout&lt;&lt;qson(x)&lt;&lt;endl; break; } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://yoursite.com/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}],"author":"小凡"},{"title":"洛谷 - P3834 主席树","slug":"luogu3834","date":"2020-03-04T10:27:29.000Z","updated":"2020-03-04T11:12:47.675Z","comments":true,"path":"2020/03/04/luogu3834/","link":"","permalink":"http://yoursite.com/2020/03/04/luogu3834/","excerpt":"","text":"传送门：洛谷 - P3834 题目描述求静态区间第K小 输入描述第一行包含两个正整数 $n$,$m$，分别表示序列的长度和查询的个数第二行包含 $n$ 个整数，表示这个序列各项的数字接下来 $m$ 行每行包含三个整数 $l$, $r$, $k$ 表示查询区间 $[l, r]$ 内的第 $k$ 小值。 输出描述输出包含 $m$ 行，每行一个整数，依次表示每一次查询的结果 思路分析对于每一个前缀建立一颗权值线段树，类似于前缀和，计算的时候$R-(l-1)$就是答案了，用主席树来减少空间 样例输入5 5 25957 6405 15770 26287 26465 2 2 1 3 4 1 4 5 1 1 2 2 4 4 1样例输出6405 15770 26287 25957 26287AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define fun function #define ll long long #define pb push_back #define mp make_pair #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N = 2e5 + 10; struct node { int l, r, sum; } tree[N * 40]; int cnt, root[N], a[N]; vector&lt;int> v; void ins(int l, int r, int pre, int &amp;now, int pos) { tree[++cnt] = tree[pre]; //复制前驱 now = cnt; tree[now].sum++; if (l == r) return; int mid = l + r >> 1; if (pos &lt;= mid) ins(l, mid, tree[pre].l, tree[now].l, pos); else ins(mid + 1, r, tree[pre].r, tree[now].r, pos); } int query(int l, int r, int L, int R, int k) { if (l == r) return l; int mid = l + r >> 1; int temp = tree[tree[R].l].sum - tree[tree[L].l].sum; if (k &lt;= temp) return query(l, mid, tree[L].l , tree[R].l, k); else return query(mid + 1, r, tree[L].r, tree[R].r, k - temp); //减去左子树的大小 } int getid(int x) { return lower_bound(v.begin(), v.end(), x) - v.begin() + 1; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\", \"r\", stdin); freopen(\"1.out\", \"w\", stdout); #endif int n, m; cin >> n >> m; for (int i = 1; i &lt;= n; i++) { cin >> a[i]; v.push_back(a[i]); } sort(all(v)); v.erase(unique(all(v)), v.end()); int tot = v.size(); for (int i = 1; i &lt;= n; i++) ins(1, tot, root[i - 1], root[i], getid(a[i])); while (m--) { int l, r, k; cin >> l >> r >> k; cout &lt;&lt; v[query(1, tot, root[l - 1], root[r], k) - 1] &lt;&lt; endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"主席树","slug":"主席树","permalink":"http://yoursite.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}],"author":"小凡"},{"title":"洛谷 - P3391 文艺平衡树 （fhq Treap）","slug":"luogu3391","date":"2020-03-03T11:57:56.000Z","updated":"2020-06-25T09:30:07.510Z","comments":true,"path":"2020/03/03/luogu3391/","link":"","permalink":"http://yoursite.com/2020/03/03/luogu3391/","excerpt":"","text":"传送门：洛谷 - P3391 题目描述您需要写一种数据结构（可参考题目标题），来维护一个有序数列 其中需要提供以下操作：翻转一个区间，例如原有序序列是 $5 4 3 2 1$，翻转区间是 $[2,4]$ 的话，结果是 $5 2 3 4 1$ 输入描述第一行两个正整数 $n$,$m$，表示序列长度与操作个数。序列中第 $i$ 项初始为 $i$接下来 $m$ 行，每行两个正整数 $l$,$r$表示翻转的区间 输出描述输出一行 $n$ 个正整数，表示原始序列经过 $m$ 次变换后的结果 思路分析按大小分裂 样例输入5 3 1 3 1 3 1 4样例输出4 3 2 1 5AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e5+10; struct node { int l,r; int val,key; int size; bool lazy; } tree[N]; int cnt,root; int newnode(int val) { tree[++cnt].val=val; tree[cnt].key=rand(); tree[cnt].size=1; return cnt; } void update(int now) { tree[now].size=tree[tree[now].l].size+tree[tree[now].r].size+1; } void pushdown(int now) { if(tree[now].lazy) { swap(tree[now].l,tree[now].r); tree[tree[now].l].lazy^=1; tree[tree[now].r].lazy^=1; tree[now].lazy=false; } } void split(int now,int siz,int &amp;x,int &amp;y) { if(!now)x=y=0; else { pushdown(now); if(tree[tree[now].l].size&lt;siz) { x=now; split(tree[now].r,siz-tree[tree[now].l].size-1,tree[x].r,y); } else { y=now; split(tree[now].l,siz,x,tree[y].l); } update(now); } } int merge(int x,int y) { if(!x||!y) return x+y; if(tree[x].key&lt;tree[y].key) { pushdown(x); tree[x].r=merge(tree[x].r,y); update(x); return x; } else { pushdown(y); tree[y].l=merge(x,tree[y].l); update(y); return y; } } void reverse(int l,int r) { int x,y,z; split(root,l-1,x,y); split(y,r-l+1,y,z); tree[y].lazy^=1; root=merge(merge(x,y),z); } void print(int now) { if(!now) return ; pushdown(now); print(tree[now].l); cout&lt;&lt;tree[now].val&lt;&lt;\" \"; print(tree[now].r); } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,m; cin>>n>>m; for(int i=1; i&lt;=n; i++) root=merge(root,newnode(i)); while(m--) { int l,r; cin>>l>>r; reverse(l,r); } print(root); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"平衡树","slug":"平衡树","permalink":"http://yoursite.com/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"}],"author":"小凡"},{"title":"洛谷 - P3369 普通平衡树 （fhq Treap）","slug":"luogu3369","date":"2020-03-03T10:49:59.000Z","updated":"2020-06-25T09:29:53.221Z","comments":true,"path":"2020/03/03/luogu3369/","link":"","permalink":"http://yoursite.com/2020/03/03/luogu3369/","excerpt":"","text":"传送门：洛谷 - P3369 题目描述您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作： 插入$x$ 删除$x$,如果有多个数，删除一个 查询$x$的排名 查询排名为$x$的数 查询$x$的前驱 查询$x$的后继 输入描述第一行为 $n$，表示操作的个数,下面 $n$ 行每行有两个数 $opt$ 和 $x$，$opt$ 表示操作的序号$( 1≤opt≤6 )$ 输出描述输出对应的答案 思路分析按权值分裂 样例输入10 1 106465 4 1 1 317721 1 460929 1 644985 1 84185 1 89851 6 81968 1 492737 5 493598样例输出106465 84185 492737AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N= 1e5+10; struct ndoe { int l,r; int key,val; int size; } tree[N]; int cnt,root; int newnode(int val) { tree[++cnt].val=val; tree[cnt].key=rand(); tree[cnt].size=1; return cnt; } void update(int now) { tree[now].size=tree[tree[now].l].size+tree[tree[now].r].size+1; } void split(int now,int val,int &amp;x,int &amp;y) { if(!now) x=y=0; else { if(tree[now].val&lt;=val) { x=now; split(tree[now].r,val,tree[x].r,y); } else { y=now; split(tree[now].l,val,x,tree[y].l); } update(now); } } int merge(int x,int y) { if(!x||!y) return x+y; if(tree[x].key>tree[y].key) { tree[x].r=merge(tree[x].r,y); update(x); return x; } else { tree[y].l=merge(x,tree[y].l); update(y); return y; } } int x,y,z; void ins(int val) { split(root,val,x,y); root=merge(merge(x,newnode(val)),y); } void del(int val) { split(root,val,x,z); split(x,val-1,x,y); y=merge(tree[y].l,tree[y].r); root=merge(merge(x,y),z); } void getrank(int val) { split(root,val-1,x,y); cout&lt;&lt;tree[x].size+1&lt;&lt;endl; root=merge(x,y); } void getnum(int rank) { int now=root; while(now) { if(tree[tree[now].l].size+1==rank) break; else if(tree[tree[now].l].size>=rank) now=tree[now].l; else { rank-=tree[tree[now].l].size+1; now=tree[now].r; } } cout&lt;&lt;tree[now].val&lt;&lt;endl; } void pre(int val) { split(root,val-1,x,y); int now=x; while(tree[now].r) now=tree[now].r; cout&lt;&lt;tree[now].val&lt;&lt;endl; root=merge(x,y); } void nxt(int val) { split(root,val,x,y); int now=y; while(tree[now].l) now=tree[now].l; cout&lt;&lt;tree[now].val&lt;&lt;endl; root=merge(x,y); } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; while(t--) { int opt,x; cin>>opt>>x; switch(opt) { case 1: ins(x); break; case 2: del(x); break; case 3: getrank(x); break; case 4: getnum(x); break; case 5: pre(x); break; case 6: nxt(x); break; } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"平衡树","slug":"平衡树","permalink":"http://yoursite.com/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"}],"author":"小凡"},{"title":"洛谷 - P1494 [国家集训队]小Z的袜子","slug":"luogu1494","date":"2020-03-03T07:00:57.000Z","updated":"2020-03-03T11:04:46.841Z","comments":true,"path":"2020/03/03/luogu1494/","link":"","permalink":"http://yoursite.com/2020/03/03/luogu1494/","excerpt":"","text":"传送门：洛谷 - P1494 题目描述作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命…… 具体来说，小Z把这 $N$ 只袜子从 1 到 $N$ 编号，然后从编号 $L$ 到 $R$ 你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个$(L,R)$以方便自己选择。 输入描述输入文件第一行包含两个正整数 $N$ 和 $M$。$N$为袜子的数量，$M$为小Z所提的询问的数量。接下来一行包含 $N$ 个正整数 $C_i$​$C_i$表示第 $i$ 只袜子的颜色，相同的颜色用相同的数字表示。再接下来 $M$ 行，每行两个正整数 $L$, $R$表示一个询问。 输出描述包含 $M$ 行，对于每个询问在一行中输出分数 $A/B$ 表示从该询问的区间 $[L,R]$ 中随机抽出两只袜子颜色相同的概率。若该概率为 0 则输出 0/1，否则输出的$A/B$必须为最简分数。 思路分析对于每种颜色的袜子，抽到两只的概率为 $\\frac{cnt * (cnt-1)}{(R-L+1) * (R-L) }$ 所以总概率就是 $\\frac{\\sum_{i=1}^x cnt * (cnt-1) }{(R-L+1) * (R-L) }$ 样例输入6 4 1 2 3 3 3 2 2 6 1 3 3 5 1 6样例输出2/5 0/1 1/1 4/15AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N = 5e5 + 10; struct node { int l, r, k; } q[N]; int bel[N]; ll a[N], cnt[N], res; pair&lt;ll, ll>ans[N]; bool cmp(node a, node b) { return bel[a.l] == bel[b.l] ? a.r &lt; b.r : bel[a.l] &lt; bel[b.l]; } void add(int x) { if (cnt[a[x]] > 0) res -= cnt[a[x]] * (cnt[a[x]] - 1); cnt[a[x]]++; res += cnt[a[x]] * (cnt[a[x]] - 1); } void del(int x) { if (cnt[a[x]] > 0) res -= cnt[a[x]] * (cnt[a[x]] - 1); cnt[a[x]]--; if (cnt[a[x]] > 0) res += cnt[a[x]] * (cnt[a[x]] - 1); } ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); } int main() { #ifdef xiaofan freopen(\"1.in\", \"r\", stdin); freopen(\"1.out\", \"w\", stdout); #endif int n, m; cin >> n >> m; int size = sqrt(n); for (int i = 1; i &lt;= n; i++) { cin >> a[i]; bel[i] = i / size; } for (int i = 0; i &lt; m; i++) { cin >> q[i].l >> q[i].r; q[i].k = i; } sort(q, q + m, cmp); ll l = 1, r = 0; for (int i = 0; i &lt; m; i++) { while (q[i].l &lt; l)add(--l); while (q[i].r > r)add(++r); while (q[i].l > l)del(l++); while (q[i].r &lt; r)del(r--); if (!res) { ans[q[i].k].fi = 0; ans[q[i].k].se = 1; continue; } ll g = __gcd(res, (r - l + 1) * (r - l)); ans[q[i].k].fi = res / g; ans[q[i].k].se = (r - l + 1) * (r - l) / g; } for (int i = 0; i &lt; m; i++) printf(\"%lld/%lld\\n\", ans[i].fi, ans[i].se); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://yoursite.com/tags/%E8%8E%AB%E9%98%9F/"}],"author":"小凡"},{"title":"Gym - 102470A Trick or Treat","slug":"gym102470A","date":"2020-03-02T11:23:48.000Z","updated":"2020-03-14T05:40:07.235Z","comments":true,"path":"2020/03/02/gym102470A/","link":"","permalink":"http://yoursite.com/2020/03/02/gym102470A/","excerpt":"","text":"传送门：Gym - 102470A 题目描述Johnny and his friends have decided to spend Halloween night doing the usual candy collection from the households of their village. As the village is too big for a single group to collect the candy from all houses sequentially, Johnny and his friends have decided to split up so that each of them goes to a different house, collects the candy （or wreaks havoc if the residents don’t give out candy）, and returns to a meeting point arranged in advance. There are n houses in the village, the positions of which can be identified with their Cartesian coordinates on the Euclidean plane. Johnny’s gang is also made up of n people （including Johnny himself）. They have decided to distribute the candy after everybody comes back with their booty. The houses might be far away, but Johnny’s interest is in eating the candy as soon as possible. Keeping in mind that, because of their response to the hospitality of some villagers, some children might be wanted by the local authorities, they have agreed to fix the meeting point by the river running through the village, which is the line y=0. Note that there may be houses on both sides of the river, and some of the houses may be houseboats (y=0). The walking speed of every child is 1 meter per second, and they can move along any direction on the plane. At exactly midnight, each child will knock on the door of the house he has chosen, collect the candy instantaneously, and walk back along the shortest route to the meeting point. Tell Johnny at what time he will be able to start eating the candy. 输入描述Each test case starts with a line indicating the number $n$ of houses $(1≤n≤50000)$. The next n lines describe the positions of the houses; each of these lines contains two floating point numbers $x$ and $y$ $(−200000≤x,y≤200000)$, the coordinates of $a$ house in meters. All houses are at different positions. A blank line follows each case. A line with $n=0$ indicates the end of the input; do not write any output for this case. 输出描述For each test case, print two numbers in a line separated by a space: the coordinate x of the meeting point on the line y=0 that minimizes the time the last child arrives, and this time itself (measured in seconds after midnight). Your answer should be accurate to within an absolute or relative error of $10^{-5}$. 思路分析三分求极值，这题精度卡的紧，算的过程中不要开方，结果再开方 样例输入2 1.5 1.5 3 0 1 0 0 4 1 4 4 4 -3 3 2 4 5 4 7 -4 0 7 -6 -2 4 8 -5 0样例输出1.500000000 1.500000000 0.000000000 0.000000000 1.000000000 5.000000000 3.136363636 7.136363636AC代码#include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N = 100010; const double eps = 1e-7; double x[N], y[N]; int n; int main() { #ifdef xiaofan freopen(\"in.txt\", \"r\", stdin); #endif while (~scanf(\"%d\", &amp;n) &amp;&amp; n) { for (int i = 0; i &lt; n; i++) scanf(\"%lf %lf\", &amp;x[i], &amp;y[i]); fun&lt;double (double) > f = [&amp;] (double nx) { double ma = 0; for (int i = 0; i &lt; n; i++) { double s = (nx - x[i]) * (nx - x[i]) + y[i] * y[i]; ma = max(ma, s); } return ma; }; double l = -2000000.0, r = 2000000.0; while (r - l > eps) { double m1 = l + (r - l) / 3; double m2 = r - (r - l) / 2; if (f(m1) > f(m2)) { l = m1; } else { r = m2; } } printf(\"%.7lf %.7lf\\n\", r, sqrt(f(r))); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"三分","slug":"三分","permalink":"http://yoursite.com/tags/%E4%B8%89%E5%88%86/"}],"author":"小凡"},{"title":"CodeForces-1315D Recommendations","slug":"CF1315D","date":"2020-03-02T07:33:37.000Z","updated":"2020-03-02T07:42:12.169Z","comments":true,"path":"2020/03/02/CF1315D/","link":"","permalink":"http://yoursite.com/2020/03/02/CF1315D/","excerpt":"","text":"传送门：CodeForces-1315D 题目描述VK news recommendation system daily selects interesting publications of one of $n$ disjoint categories for each user. Each publication belongs to exactly one category. For each category $i$ batch algorithm selects $a_i$ publications. The latest A/B test suggests that users are reading recommended publications more actively if each category has a different number of publications within daily recommendations. The targeted algorithm can find a single interesting publication of $i$-th category within $t_i$ seconds. What is the minimum total time necessary to add publications to the result of batch algorithm execution, so all categories have a different number of publications? You can’t remove publications recommended by the batch algorithm. 输入描述The first line of input consists of single integer $n$ — the number of news categories $(1≤n≤200000)$. The second line of input consists of n integers $a_i$ — the number of publications of $i$-th category selected by the batch algorithm $(1≤a_i≤10^9)$. The third line of input consists of n integers $t_i$ — time it takes for targeted algorithm to find one new publication of category $i$ $(1≤t_i≤10^5)$. 输出描述Print one integer — the minimal required time for the targeted algorithm to get rid of categories with the same size. 思路分析贪心的想，如果有很多个相同的元素，那么将花费最大的留在原地，其他+1肯定是最优的，可以用set来维护最值 样例输入5 3 7 9 7 8 5 2 5 7 5样例输出6AC代码 #include &lt;functional> #include &lt;algorithm> #include &lt;iostream> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;map> #include &lt;set> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N = 2e5 + 10; multiset&lt;ll>q; pair&lt;ll, ll>a[N]; int main() { IOS; #ifdef xiaofan freopen(\"1.in\", \"r\", stdin); freopen(\"1.out\", \"w\", stdout); #endif int n; cin >> n; for (int i = 0; i &lt; n; i++) cin >> a[i].fi; for (int i = 0; i &lt; n; i++) cin >> a[i].se; sort(a, a + n); int now = -1; ll ans = 0, sum = 0; for (int i = 0; i &lt; n; i++) { while (q.size() &amp;&amp; now &lt; a[i].fi) { ll ma = *q.rbegin(); ans += sum - ma; sum -= ma; q.erase(q.find(ma)); now++; } q.insert(a[i].se); sum += a[i].se; now = a[i].fi; } while (q.size()) { ll ma = *q.rbegin(); ans += sum - ma; sum -= ma; q.erase(q.find(ma)); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"}],"author":"小凡"},{"title":"CodeForces-1111C Creative Snap（动态开点）","slug":"CF1111C","date":"2020-03-02T07:05:38.000Z","updated":"2020-05-30T13:35:58.816Z","comments":true,"path":"2020/03/02/CF1111C/","link":"","permalink":"http://yoursite.com/2020/03/02/CF1111C/","excerpt":"","text":"传送门：CodeForces-1111C 题目描述Thanos wants to destroy the avengers base, but he needs to destroy the avengers along with their base.Let we represent their base with an array, where each position can be occupied by many avengers, but one avenger can occupy only one position. Length of their base is a perfect power of 2. Thanos wants to destroy the base using minimum power. He starts with the whole base and in one step he can do either of following: if the current length is at least 2, divide the base into 2 equal halves and destroy them separately, or burn the current base. If it contains no avenger in it, it takes A amount of power, otherwise it takes his $B⋅n_a⋅l$ amount of power, where $n_a$ is the number of avengers and $l$ is the length of the current base. Output the minimum power needed by Thanos to destroy the avengers’ base. 输入描述The first line contains four integers $n$, $k$, $A$ and $B$ $(1≤n≤30, 1≤k≤10^5, 1≤A,B≤10^4)$, where $2^n$ is the length of the base, $k$ is the number of avengers and $A$ and $B$ are the constants explained in the question. The second line contains $k$ integers $a_1,a_2,a_3,…,a_k$ $(1≤a_i≤2^n)$, where $a_i$ represents the position of avenger in the base. 输出描述Output one integer — the minimum power needed to destroy the avengers base. 思路分析很容易想到线段树模拟，但是空间太大了，所以要用到动态开点，只开需要的空间 样例输入2 2 1 2 1 3样例输出6AC代码 #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N = 1e7 + 10; struct node { int lson, rson; ll sum; } tree[N]; int n, k, tot; ll A, B; void update(int &amp;x, int l, int r, int pos) { if (!x)x = ++tot; tree[x].sum++; if (l == r)return ; int mid = l + r >> 1; if (pos &lt;= mid) update(tree[x].lson, l, mid, pos); else update(tree[x].rson, mid + 1, r, pos); } ll query(int x, int l, int r) { if (!x)return A; if (l == r)return B * tree[x].sum; int mid = l + r >> 1; ll ans = B * (r - l + 1) * tree[x].sum; ans = min(ans, query(tree[x].lson, l, mid) + query(tree[x].rson, mid + 1, r)); return ans; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\", \"r\", stdin); freopen(\"1.out\", \"w\", stdout); #endif int ro = 0; cin >> n >> k >> A >> B; int cnt = 1 &lt;&lt; n; for (int i = 0; i &lt; k; i++) { int x; cin >> x; update(ro, 1, cnt, x); } cout &lt;&lt; query(ro, 1, cnt) &lt;&lt; endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"author":"小凡"},{"title":"洛谷 - P1144 最短路计数","slug":"luogu1144","date":"2020-03-02T06:55:51.000Z","updated":"2020-03-02T07:02:00.817Z","comments":true,"path":"2020/03/02/luogu1144/","link":"","permalink":"http://yoursite.com/2020/03/02/luogu1144/","excerpt":"","text":"传送门：洛谷 - P1144 题目描述给出一个$N$个顶点$M$条边的无向无权图，顶点编号为$1−-N$。问从顶点1开始，到其他每个点的最短路有几条。 输入描述第一行包含2个正整数$N$,$M$，为图的顶点数与边数。 接下来$M$行，每行2个正整数$x$,$y$，表示有一条顶点$x$连向顶点$y$的边，请注意可能有自环与重边。 输出描述共$N$行，每行一个非负整数，第$i$行输出从顶点1到顶点$i$有多少条不同的最短路，由于答案有可能会很大，你只需要输出$ans$mod 100003后的结果即可。如果无法到达顶点$i$则输出0。 思路分析遍历边的时候更新答案 样例输入5 7 1 2 1 3 2 4 3 4 2 3 4 5 4 5样例输出1 1 1 2 4AC代码 #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int mod = 100003; const int N = 2e6 + 10; vector&lt;int>e[N]; int vis[N], dis[N], ans[N]; int n, m; void spfa() { for (int i = 1; i &lt;= n; i++) { dis[i] = INF; vis[i] = 0; } dis[1] = 0; vis[1] = 1; queue&lt;int>q; q.push(1); while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (auto v : e[u]) { if (dis[v] > dis[u] + 1) { dis[v] = dis[u] + 1; ans[v] = ans[u]; if (!vis[v]) { vis[v] = 1; q.push(v); } } else if (dis[v] == dis[u] + 1) { ans[v] = (ans[u] + ans[v]) % mod; } } } } int main() { IOS; #ifdef xiaofan freopen(\"1.in\", \"r\", stdin); freopen(\"1.out\", \"w\", stdout); #endif cin >> n >> m; for (int i = 0; i &lt; m; i++) { int u, v; cin >> u >> v; e[u].push_back(v); e[v].push_back(u); } ans[1] = 1; spfa(); for (int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] % mod &lt;&lt; endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"author":"小凡"},{"title":"CodeForces - 1303C Perfect Keyborad","slug":"CF1303C","date":"2020-03-01T10:05:11.000Z","updated":"2020-03-01T10:06:32.486Z","comments":true,"path":"2020/03/01/CF1303C/","link":"","permalink":"http://yoursite.com/2020/03/01/CF1303C/","excerpt":"","text":"传送门：CodeForces - 1303C 题目描述给你一个字符串S，让你输出一个26个字母的排列，使得对于S串的每一个字母它与它的相邻字母，在答案字符串里，也是相邻的。 思路分析可以将相邻两个字母连边，由于可能出现重复的，就用set存图。判断不存在很简单，如果有一个字母与两个字母以上相邻，那么肯定不可能。找出一个只有一条边的字母，把他当作开头，再dfs一边就可以得到答案了 样例输入5 ababa codedoca abcda zxzytyz abcdefghijklmnopqrstuvwxyza样例输出YES bacdefghijklmnopqrstuvwxyz YES edocabfghijklmnpqrstuvwxyz NO YES xzytabcdefghijklmnopqrsuvw NO AC代码 #include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #include &lt;functional> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; void solve() { string s; cin>>s; if(s.size()==1) { puts(\"YES\"); for(int i=0; i&lt;26; i++) printf(\"%c\",i+'a'); cout&lt;&lt;endl; return ; } vector&lt;set&lt;int>>e(26); for(int i=1; i&lt;s.size(); i++) { e[s[i-1]-'a'].insert(s[i]-'a'); e[s[i]-'a'].insert(s[i-1]-'a'); } vector&lt;int>pos; for(int i=0; i&lt;26; i++) { if(e[i].size()>2) { puts(\"NO\"); return ; } if(e[i].size()==1) pos.push_back(i); } if(pos.size()==2) { int u=pos[0]; string ans; function&lt;void (int ,int)> dfs =[&amp;](int u,int fa) { char x=u+'a'; ans+=x; for(auto v:e[u]) { if(v==fa)continue; dfs(v,u); } }; dfs(u,-1); for(int i=0; i&lt;26; i++) if(!~ans.find('a'+i)) ans.push_back('a'+i); puts(\"YES\"); cout&lt;&lt;ans&lt;&lt;endl; } else { puts(\"NO\"); } } int main() { #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif int t; cin>>t; while(t--) { solve(); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"}],"author":"小凡"},{"title":"CodeForces - 1313C Skyscrapers (单调栈)","slug":"CF1313C","date":"2020-03-01T10:03:59.000Z","updated":"2020-03-01T10:04:57.769Z","comments":true,"path":"2020/03/01/CF1313C/","link":"","permalink":"http://yoursite.com/2020/03/01/CF1313C/","excerpt":"","text":"传送门： 题目描述一排大楼，需要满足这样一个条件，每个大楼只能存在一侧比它高。 思路分析经过分析，可以想到这实际上就是一个单峰，一个最大值，左边不严格递减，右边不严格递增可以通过单调栈预处理出每个点作为最大值的贡献，最后枚举得到这个最大的位置 样例输入3 10 6 8样例输出10 6 6AC代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;functional> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=5e5+10; ll a[N],ans[N],le[N],ri[N]; int n,top; pair&lt;ll,ll>st[N]; void init(ll *x) { ll sum=0; st[top=0]=mp(0,0); for(int i=1; i&lt;=n; i++) { while(top>0 &amp;&amp; a[i]&lt;st[top].first) { sum-=st[top].first*(st[top].second-st[top-1].second); --top; } sum+=a[i]*(i-st[top].second); st[++top]=mp(a[i],i); x[i]=sum; } } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif cin>>n; for(int i=1; i&lt;=n; i++) cin>>a[i]; init(le); reverse(a+1,a+1+n); init(ri); reverse(a+1,a+1+n); reverse(ri+1,ri+1+n); int pos=0; ll ma=0; for(int i=1; i&lt;=n; i++) { ll sum=le[i]+ri[i]-a[i]; if(sum>ma) { ma=sum; pos=i; } } ans[pos]=a[pos]; for(int i=pos+1; i&lt;=n; i++) ans[i]=min(ans[i-1],a[i]); for(int i=pos-1; i>=1; i--) ans[i]=min(ans[i+1],a[i]); for(int i=1; i&lt;=n; i++) cout&lt;&lt;ans[i]&lt;&lt;\" \"; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"http://yoursite.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}],"author":"小凡"},{"title":"牛客小白月赛22 - B 树上子链（树的直径）","slug":"NK4462B","date":"2020-03-01T10:02:22.000Z","updated":"2020-03-01T10:03:43.522Z","comments":true,"path":"2020/03/01/NK4462B/","link":"","permalink":"http://yoursite.com/2020/03/01/NK4462B/","excerpt":"","text":"传送门：牛客小白月赛22 - B 题目描述给定一棵树T，树上每个点都有一个权值。定义一棵树的子链大小为：子链上的点的权值和。请找出最大子链。 输入描述第一行输入一个$n$,$1&lt;=n&lt;=10^5$接下来一行包含$n$个数代表节点的权值，$-10^5&lt;=a_i&lt;=10^5$接下来n-1行，每行u，v代表u，v之间有一条边 输出描述输出答案 思路分析树的直径，这里用dp法：设dp[i]表示从节点i出发，往以i为根的子树走，能够走到的最大距离因为题目是无根树，所以子链最大应该是以一个节点为根的最大值和次大值之和。此题有单个节点的情况所以最后再取一次max。 样例输入5 2 -1 -1 -2 3 1 2 2 3 2 4 2 5样例输出4AC代码 #include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;functional> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e5+10; vector&lt;int>e[N]; ll ans=-1e16; ll dp[N],a[N]; void dfs(int u,int fa) { dp[u]=a[u]; for(auto v:e[u]) { if(v==fa)continue; dfs(v,u); ans=max(ans,dp[u]+dp[v]); dp[u]=max(dp[u],dp[v]+a[u]); } ans=max(ans,dp[u]); } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n; cin>>n; for(int i=1; i&lt;=n; i++)cin>>a[i]; for(int i=0; i&lt;n-1; i++) { int u,v; cin>>u>>v; e[u].push_back(v); e[v].push_back(u); } dfs(1,-1); cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"小凡"},{"title":"CodeForces - 1303E Erase Subsequences","slug":"CF1303E","date":"2020-03-01T10:00:53.000Z","updated":"2020-05-30T13:42:23.603Z","comments":true,"path":"2020/03/01/CF1303E/","link":"","permalink":"http://yoursite.com/2020/03/01/CF1303E/","excerpt":"","text":"传送门：CodeForces - 1303E 思路分析两个字符串S和T，能否从S中最多选择两个不想交的子序列拼成T看数据范围可以想到$n^3$的算法因为是可以由两个子序列拼接，所以可以通过枚举T的分割点进行dp设dp[i][j]表示该用第i个字母，并且已经匹配了$t_1$字符串的第j个位置,$t_2$最多匹配到哪一个 AC代码 #include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;functional> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls x&lt;&lt;1 #define rs x&lt;&lt;1|1 #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; int dp[444][444]; bool check(string s,string t) { int cnt=0; for(int i=0; i&lt;s.size(); i++) if(s[i]==t[cnt]) cnt++; return cnt>=t.size(); } bool go(string s,string t1,string t2) { mem(dp,-1); dp[0][0]=0; for(int i=0; i&lt;s.size(); i++) { for(int j=0; j&lt;=t1.size(); j++) { if(dp[i][j]&lt;0)continue; if(j&lt;t1.size() &amp;&amp; s[i]==t1[j]) dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]); if(dp[i][j]&lt;t2.size() &amp;&amp; s[i]==t2[dp[i][j]]) dp[i+1][j]=max(dp[i+1][j],dp[i][j]+1); dp[i+1][j]=max(dp[i+1][j],dp[i][j]); } } int f1=dp[s.size()][t1.size()]; int f2=t2.size(); if(f1>=f2) return true; else return false; } bool solve() { string s,t; cin>>s>>t; if(check(s,t)) return true; for(int i=1; i&lt;=t.size()-1; i++) if(go(s,t.substr(0,i),t.substr(i))) return true; return false; } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int t; cin>>t; while(t--) { if(solve()) cout&lt;&lt;\"YES\"&lt;&lt;endl; else cout&lt;&lt;\"NO\"&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}],"author":"小凡"},{"title":"洛谷 - P4513 小白逛公园","slug":"luogu4513","date":"2020-03-01T09:58:43.000Z","updated":"2020-03-01T10:00:05.123Z","comments":true,"path":"2020/03/01/luogu4513/","link":"","permalink":"http://yoursite.com/2020/03/01/luogu4513/","excerpt":"","text":"传送门：洛谷 - P4513 题目描述在小新家附近有一条“公园路”，路的一边从南到北依次排着nn个公园，小白早就看花了眼，自己也不清楚该去哪些公园玩了。 一开始，小白就根据公园的风景给每个公园打了分-.-。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第aa个和第bb个公园之间（包括aa、bb两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。 那么，就请你来帮小白选择公园吧。 输入描述第一行，两个整数$N$和$M$，分别表示表示公园的数量和操作（遛狗或者改变打分）总数。接下来$N$行，每行一个整数，依次给出小白 开始时对公园的打分。接下来$M$行，每行三个整数。第一个整数$K$，$1$或$2$。 $K=1$表示，小新要带小白出去玩，接下来的两个整数a和b给出了选择公园的范围$(1≤a,b≤N)$。测试数据可能会出现$a&gt;b$的情况，需要进行交换； $K=2$表示，小白改变了对某个公园的打分，接下来的两个整数$p$和$s$，表示小白对第$p$个公园的打分变成了$s$$(1≤p≤N)$。其中，$1≤N≤500000$，$1≤M≤100000$，所有打分都是绝对值不超过10001000的整数。 输出描述小白每出去玩一次，都对应输出一行，只包含一个整数，表示小白可以选出的公园得分和的最大值。 思路分析很明显的最大区间连续子段和，那要怎么维护呢 sum表示区间和 ls表示连接左端点的最大连续子段和 rs表示连接右端点的最大连续子段和 mx表示区间最大连续子段和 具体操作看代码 样例输入5 3 1 2 -3 4 5 1 2 3 2 2 -1 1 2 3样例输出2 -1AC代码 #include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;functional> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e6+10; struct node { int l,r,mid; int sum,ls,rs,mx; } tree[N&lt;&lt;2]; int a[N]; void pushup(int x) { tree[x].sum=tree[x*2].sum+tree[x*2+1].sum; tree[x].ls=max(tree[x*2].ls,tree[x*2].sum+tree[x*2+1].ls); tree[x].rs=max(tree[x*2+1].rs,tree[x*2+1].sum+tree[x*2].rs); tree[x].mx=max(tree[x*2].rs+tree[x*2+1].ls,max(tree[x*2].mx,tree[x*2+1].mx)); } void build(int x,int l,int r) { tree[x].l=l; tree[x].r=r; tree[x].mid=l+r>>1; if(l==r) { tree[x].ls=a[l]; tree[x].mx=a[l]; tree[x].sum=a[l]; tree[x].rs=a[l]; return ; } int mid=tree[x].mid; build(x*2,l,mid); build(x*2+1,mid+1,r); pushup(x); } void update(int x,int pos,int v) { if(tree[x].l==tree[x].r &amp;&amp; tree[x].l==pos) { tree[x].ls=v; tree[x].mx=v; tree[x].sum=v; tree[x].rs=v; return ; } int mid=tree[x].mid; if(pos&lt;=mid) update(x*2,pos,v); else update(x*2+1,pos,v); pushup(x); } node query(int x,int l,int r) { if(l&lt;=tree[x].l &amp;&amp; tree[x].r&lt;=r) { return tree[x]; } int mid=tree[x].mid; if(r&lt;=mid) { return query(x*2,l,r); } else if(l>mid) { return query(x*2+1,l,r); } else { node lson=query(x*2,l,r); node rson=query(x*2+1,l,r); node ans; ans.sum=lson.sum+rson.sum; ans.ls=max(lson.ls,lson.sum+rson.ls); ans.rs=max(rson.rs,rson.sum+lson.rs); ans.mx=max(lson.rs+rson.ls,max(lson.mx,rson.mx)); return ans; } } int main() { #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif int n,m; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1; i&lt;=n; i++)scanf(\"%d\",&amp;a[i]); build(1,1,n); while(m--) { int o,l,r; scanf(\"%d%d%d\",&amp;o,&amp;l,&amp;r); if(o==1) { if(l>r)swap(l,r); printf(\"%d\\n\",query(1,l,r).mx); } else { update(1,l,r); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"author":"小凡"},{"title":"2020牛客寒假训练营Day6 - E 立方数","slug":"2020NKCAMPD6E","date":"2020-03-01T09:56:30.000Z","updated":"2020-03-01T10:02:33.460Z","comments":true,"path":"2020/03/01/2020NKCAMPD6E/","link":"","permalink":"http://yoursite.com/2020/03/01/2020NKCAMPD6E/","excerpt":"","text":"传送门：2020牛客寒假训练营Day6 - E 题目描述对于给定的正整数N，求最大的正整数A，使得存在正整数B，满足$A^3*B=N$输入包含T组数据，$1≤T≤10000$,$1≤N≤10^18$ 输入描述第一行数字T表示数据组数接下来一行，T个整数N 输出描述T行，每一行一个数字表示答案 思路分析因为是立方，所以很容易想到找$10^6$以下的素数，但是这样还是会TLE再进一步分析，如果仅使用$N^{1/4}$（记为W），以为的素数试除，那么最后余下的的数X肯定只有大于W的因子要么他是立方数，要么他对答案没有贡献，我们可以用二分的办法判断它是不是立方数 样例输入4 27 24 7 54样例输出3 2 1 3AC代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;functional> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e6+10; ll prim[N],cnt; ll sq[N],ssq[N]; bool ok[N]; void init() { mem(ok,1); for(ll i=2; i&lt;100000; i++) { if(ok[i]) { prim[++cnt]=i; sq[i]=i*i*i; ssq[i]=i*i*i*i; for(ll j=i*i; j&lt;100000; j+=i) ok[j]=0; } } } int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif init(); int t; cin>>t; while(t--) { ll n; cin>>n; ll ans=1; for(int i=1; ssq[prim[i]]&lt;=n; i++) { if(n%prim[i]==0) { while(n % sq[prim[i]]==0) { ans*=prim[i]; n/=sq[prim[i]]; } while(n%prim[i]==0) n/=prim[i]; } } ll l=1,r=1000000; while(r>=l){ ll mid=l+r>>1; if(mid*mid*mid==n){ ans*=mid; break; } if(mid*mid*mid>n){ r=mid-1; }else{ l=mid+1; } } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"}],"author":"小凡"},{"title":"Atcoder - 155D Pairs","slug":"ATC155D","date":"2020-03-01T09:54:44.000Z","updated":"2020-03-01T09:55:46.788Z","comments":true,"path":"2020/03/01/ATC155D/","link":"","permalink":"http://yoursite.com/2020/03/01/ATC155D/","excerpt":"","text":"传送门：Atcoder - 155D 题目描述 N个整数，每两两组合相乘得到一个数，第K大的数是多少。 输入描述$2≤N≤2*10^5$$-10^9≤a_i≤10^9$ 输出描述输出第K大的数 思路分析很容易想到二分答案，二分过程中再二分查找小于等于mid的数有多少 样例输入10 40 5 4 3 2 -1 0 0 0 0 样例输出6AC代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;functional> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define fun function #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e6; ll a[N]; int main() { IOS; #ifdef xiaofan freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); #endif ll n,k; cin>>n>>k; for(int i=0; i&lt;n; i++) cin>>a[i]; sort(a,a+n); ll L=-1e18-7,R=1e18+7; while(R-L>1) { ll Mid=(L+R)/2; ll cnt=0; for(int i=0; i&lt;n; i++) { if(a[i]&lt;0) { int l=i,r=n; while(r-l>1) { int mid=(l+r)/2; if(a[i]*a[mid]&lt;=Mid) r=mid; else l=mid; } cnt+=n-r; } else { int l=i,r=n; while(r-l>1) { int mid=(l+r)/2; if(a[i]*a[mid]&lt;=Mid) l=mid; else r=mid; } cnt+=l-i; } } if(cnt&lt;k)L=Mid; else R=Mid; } cout&lt;&lt;R&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"}],"author":"小凡"},{"title":"2020牛客寒假算法基础训练营Day1 - F maki和tree","slug":"2020NKCAMPD1F","date":"2020-03-01T09:49:34.000Z","updated":"2020-03-01T09:53:52.034Z","comments":true,"path":"2020/03/01/2020NKCAMPD1F/","link":"","permalink":"http://yoursite.com/2020/03/01/2020NKCAMPD1F/","excerpt":"","text":"传送门：Day1 - F 题目描述 思路分析将相邻的白色节点连通，记录每个连通块内点的数量，再枚举每一个黑点。如图：这张图里的 $ans=(1+2+3)+(1×2)+(1×3)+(2×3)$ 样例输入3 WBW 1 2 2 3样例输出3AC代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define umap unordered_map #define uset unordered_set #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e5+10; ll f[N],size[N]; vector&lt;int>e[N]; char s[N]; int find(int x) { if(f[x]==x) return x; else return f[x]=find(f[x]); } void merge(int u,int v) { int t1=find(u); int t2=find(v); if(t1!=t2) { f[t2]=t1; size[t1]+=size[t2]; } } int main() { IOS; #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif int n; cin>>n; cin>>s+1; for(int i=1; i&lt;=n; i++) { if(s[i]=='W') size[i]++; f[i]=i; } for(int i=1; i&lt;=n-1; i++) { int u,v; cin>>u>>v; e[u].pb(v); e[v].pb(u); if(s[u]==s[v] &amp;&amp; s[u]=='W') merge(u,v); } ll ans=0; for(int i=1; i&lt;=n; i++) { if(s[i]=='B') { ll sum=0; for(auto v:e[i]) sum+=size[find(v)]; ans+=sum; for(auto v:e[i]) { sum-=size[find(v)]; ans+=sum*size[find(v)]; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}],"author":"小凡"},{"title":"2020牛客寒假算法基础训练营Day2 - J 求函数","slug":"2020NKCAMPD2J","date":"2020-03-01T09:45:54.000Z","updated":"2020-03-01T09:48:58.704Z","comments":true,"path":"2020/03/01/2020NKCAMPD2J/","link":"","permalink":"http://yoursite.com/2020/03/01/2020NKCAMPD2J/","excerpt":"","text":"传送门：Day2 - J 题目描述 输入描述第一行，两个正整数 n,m第二行，n个整数$k_1,k_2,…k_n$第三行，n个整数$b_1,b_2,…b_n$接下来m行，操作格式如上保证$1&lt;=n,m&lt;=2×10^5$,$0&lt;=k_i,b_i&lt;=10^9+7$ 输出描述对于每个求值操作，输出一行一个整数，表示答案。 思路分析难点在于如何合并两个子节点 样例输入2 3 1 1 1 0 1 2 114514 1919810 2 1 2 2 1 1样例输出2148838 2AC代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define umap unordered_map #define uset unordered_set #define int long long #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=2e5+10; const int mod=1e9+7; int ans,n,m; int k[N],b[N]; struct node { int l,r,k,b; int mid() { return (l+r)/2; } } tree[N*4]; void pushup(int x) { tree[x].k=(tree[x*2].k*tree[x*2+1].k%mod)%mod; tree[x].b=(tree[x*2+1].k*tree[x*2].b%mod+tree[x*2+1].b)%mod; } void build(int x,int l,int r) { tree[x].l=l; tree[x].r=r; if(l==r) { tree[x].k=k[l]; tree[x].b=b[l]; return ; } int mid=tree[x].mid(); build(x*2,l,mid); build(x*2+1,mid+1,r); pushup(x); } void update(int x,int pos,int k,int b) { if(tree[x].l==tree[x].r &amp;&amp; tree[x].l==pos) { tree[x].k=k; tree[x].b=b; return ; } int mid=tree[x].mid(); if(pos&lt;=mid) update(x*2,pos,k,b); if(pos>mid) update(x*2+1,pos,k,b); pushup(x); } void query(int x,int l,int r) { if(l&lt;=tree[x].l &amp;&amp; tree[x].r &lt;=r) { ans=(ans*tree[x].k%mod+tree[x].b)%mod; return ; } int mid=tree[x].mid(); if(l&lt;=mid) query(x*2,l,r); if(r>mid) query(x*2+1,l,r); } signed main() { IOS; #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif cin>>n>>m; for(int i=1; i&lt;=n; i++) cin>>k[i]; for(int i=1; i&lt;=n; i++) cin>>b[i]; build(1,1,n); for(int i=1; i&lt;=m; i++) { int op,x,y,z; cin>>op; if(op==1) { cin>>x>>y>>z; update(1,x,y,z); } else { cin>>x>>y; ans=1; query(1,x,y); cout&lt;&lt;ans%mod&lt;&lt;endl; } } return 0; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"author":"小凡"},{"title":"HDU-1754 I Hate It","slug":"HDU1754","date":"2020-03-01T09:42:30.000Z","updated":"2020-03-01T09:45:09.956Z","comments":true,"path":"2020/03/01/HDU1754/","link":"","permalink":"http://yoursite.com/2020/03/01/HDU1754/","excerpt":"","text":"传送门：HUD - 1754 题目描述很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 输入描述本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 输出描述对于每一次询问操作，在一行里面输出最高成绩。 思路分析线段树维护区间最大值，单点更新 样例输入5 6 1 2 3 4 5 Q 1 5 U 3 6 Q 3 4 Q 4 5 U 2 9 Q 1 5样例输出5 6 5 9线段树代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> using namespace std; #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define rson ro&lt;&lt;1|1,mid+1,r #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; const int N=1e6+10; struct T{ int l,r,ma; }tree[N&lt;&lt;2]; void pushup(int ro){ tree[ro].ma=max(tree[ls].ma,tree[rs].ma); } void build(int ro,int l,int r){ tree[ro].l=l,tree[ro].r=r,tree[ro].ma=-1; if(l==r){ scanf(\"%d\",&amp;tree[ro].ma); return ; } int mid=(l+r)>>1; build(lson); build(rson); pushup(ro); } void update(int ro,int x,int d){ if(tree[ro].l==x &amp;&amp; tree[ro].r==x){ tree[ro].ma=d; return ; } int mid=(tree[ro].l+tree[ro].r)>>1; if(x&lt;=mid) update(ls,x,d); else update(rs,x,d); pushup(ro); } int query(int ro,int l,int r){ if(l&lt;=tree[ro].l &amp;&amp; tree[ro].r&lt;=r){ return tree[ro].ma; } int ans=-INF; int mid=(tree[ro].l+tree[ro].r)>>1; if(l&lt;=mid) ans=max(ans,query(ls,l,r)); if(r>mid) ans=max(ans,query(rs,l,r)); return ans; } int main() { int n,m; while(~scanf(\"%d %d\",&amp;n,&amp;m)){ build(1,1,n); while(m--){ char op; int l,r; getchar(); scanf(\"%c%d%d\",&amp;op,&amp;l,&amp;r); if(op=='U') update(1,l,r); else printf(\"%d\\n\",query(1,l,r)); } } return 0; } 分块代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define umap unordered_map #define uset unordered_set #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=2e5+10; int blo,bel[N],num,l[N],r[N],Max[N]; int n,q,a[N]; void build() { blo=sqrt(n); num=n/blo; if(n%blo) num++; for(int i=1; i&lt;=num; i++) { l[i]=(i-1)*blo+1; r[i]=i*blo; } r[num]=n; for(int i=1; i&lt;=n; i++) bel[i]=(i-1)/blo+1; for(int i=1; i&lt;=num; i++) for(int j=l[i]; j&lt;=r[i]; j++) Max[i]=max(Max[i],a[j]); } void update(int x,int v) { a[x]=v; Max[bel[x]]=max(Max[bel[x]],a[x]); } int query(int x,int y) { int ans=0; if(bel[x]==bel[y]) { for(int i=x; i&lt;=y; i++) ans=max(ans,a[i]); return ans; } for(int i=x; i&lt;=r[bel[x]]; i++) ans=max(ans,a[i]); for(int i=bel[x]+1; i&lt;bel[y]; i++) ans=max(ans,Max[i]); for(int i=l[bel[y]]; i&lt;=y; i++) ans=max(ans,a[i]); return ans; } int main() { IOS; #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif while(cin>>n>>q) { mem(Max,0); for(int i=1; i&lt;=n; i++) cin>>a[i]; build(); while(q--) { char op; int x,y; cin>>op>>x>>y; if(op=='Q') cout&lt;&lt;query(x,y)&lt;&lt;endl; else update(x,y); } } #ifdef xiaofan cerr&lt;&lt;\"Time elapsed: \"&lt;&lt;1.0*clock()/CLOCKS_PER_SEC&lt;&lt;\"s.\\n\"; #endif return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"分块","slug":"分块","permalink":"http://yoursite.com/tags/%E5%88%86%E5%9D%97/"}],"author":"小凡"},{"title":"CodeForces - 1282D Enchanted Artifact","slug":"CF1282D","date":"2020-03-01T09:37:54.000Z","updated":"2020-03-01T09:42:11.513Z","comments":true,"path":"2020/03/01/CF1282D/","link":"","permalink":"http://yoursite.com/2020/03/01/CF1282D/","excerpt":"","text":"传送门：CodeForces - 1282D 题目描述This is an interactive problem. After completing the last level of the enchanted temple, you received a powerful artifact of the 255th level. Do not rush to celebrate, because this artifact has a powerful rune that can be destroyed with a single spell s, which you are going to find. We define the spell as some non-empty string consisting only of the letters a and b. At any time, you can cast an arbitrary non-empty spell t, and the rune on the artifact will begin to resist. Resistance of the rune is the edit distance between the strings that specify the casted spell t and the rune-destroying spell s. Edit distance of two strings s and t is a value equal to the minimum number of one-character operations of replacing, inserting and deleting characters in s to get t. For example, the distance between ababa and aaa is 2, the distance between aaa and aba is 1, the distance between bbaba and abb is 3. The edit distance is 0 if and only if the strings are equal. It is also worth considering that the artifact has a resistance limit — if you cast more than n+2 spells, where n is the length of spell s, the rune will be blocked. Thus, it takes n+2 or fewer spells to destroy the rune that is on your artifact. Keep in mind that the required destructive spell s must also be counted among these n+2 spells. Note that the length n of the rune-destroying spell s is not known to you in advance. It is only known that its length n does not exceed 300. 思路分析因为最多有300个，所以可以询问两次300个a和300个b，可以得到a的数量和b的数量以及总长度n，定义一个长度为n全部为a的字符串，再遍历n-1，每次将当前位变为b，判断操作次数是否变少，如果没有就说明这一位不是b，再变回a，最后根据剩余b的数量特判最后一位。次数刚好n+2。 样例输入2 2 1 2 3 0样例输出aaa aaab abba bba abaaa aabbaAC代码 #include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define umap unordered_map #define uset unordered_set #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; string get(char a,int n){ string x=\"\"; while(n--) x+=a; return x; } int query(string s){ cout&lt;&lt;s&lt;&lt;endl; int x; cin>>x; if(!x) exit(0); return x; } int main() { IOS; #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif int cnta=300-query(get('a',300)); int cntb=300-query(get('b',300)); int n=cnta+cntb; string s=get('a',n); for(int i=0;i&lt;n-1;i++){ s[i]='b'; int x=query(s); if(x&lt;cntb){ cntb=x; } else{ s[i]='a'; cnta--; } } if(cntb) s[n-1]='b'; query(s); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"交互","slug":"交互","permalink":"http://yoursite.com/tags/%E4%BA%A4%E4%BA%92/"}],"author":"小凡"},{"title":"POJ - 2449 Remmarguts' Date（ K短路 Astar ）","slug":"POJ2449","date":"2020-03-01T09:34:22.000Z","updated":"2020-03-01T09:37:27.202Z","comments":true,"path":"2020/03/01/POJ2449/","link":"","permalink":"http://yoursite.com/2020/03/01/POJ2449/","excerpt":"","text":"传送门：AcWing - 180 题目描述 求第K短路 输入描述The first line contains two integer numbers $N$ and $M$ $(1 &lt;= N &lt;= 1000, 0 &lt;= M &lt;= 100000)$. Stations are numbered from 1 to N. Each of the following M lines contains three integer numbers $A$, $B$ and $T$ $(1 &lt;= A, B &lt;= N, 1 &lt;= T &lt;= 100)$. It shows that there is a directed sideway from A-th station to B-th station with time T. The last line consists of three integer numbers $S$, $T$ and $K$ $(1 &lt;= S, T &lt;= N, 1 &lt;= K &lt;= 1000)$. 输出描述A single line consisting of a single integer number: the length (time required) to welcome Princess Uyuw using the K-th shortest path. If K-th shortest path does not exist, you should output “-1” (without quotes) instead. 思路分析有向图求第K短路，先用dij或spfa跑出终点的估价值，再用A-star 样例输入2 2 1 2 5 2 1 4 1 2 2样例输出14AC代码 #include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define umap unordered_map #define uset unordered_set #define rson ro&lt;&lt;1|1,mid+1,r #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1010; int n,m; int dis[N]; vector&lt;pair&lt;int,int>>e[N],re[N]; struct A{ int v,val; friend bool operator &lt; (A x,A y) { return x.val+dis[x.v]>y.val+dis[y.v]; } }; inline void dij(int s){ priority_queue&lt; pair&lt;int,int> > q; mem(dis,INF); dis[s]=0; q.push(make_pair(0,s)); while(!q.empty()){ int u=q.top().se; q.pop(); for(auto i:re[u]){ int v=i.fi,w=i.se; if(dis[v]>dis[u]+w){ dis[v]=dis[u]+w; q.push(make_pair(-dis[v],v)); } } } } inline int Astar(int s,int t,int k){ priority_queue&lt;A>q; int cnt=0; A tem; tem.v=s; tem.val=0; q.push(tem); while(!q.empty()){ A u=q.top(); q.pop(); if(u.v==t) cnt++; if(cnt==k) return u.val; for(auto i:e[u.v]){ tem.v=i.fi; tem.val=u.val+i.se; q.push(tem); } } return -1; } int main() { scanf(\"%d %d\",&amp;n,&amp;m); while(m--){ int u,v,w; scanf(\"%d %d %d\",&amp;u,&amp;v,&amp;w); e[u].pb(make_pair(v,w)); re[v].pb(make_pair(u,w)); } int s,t,k; scanf(\"%d %d %d\",&amp;s,&amp;t,&amp;k); if(s==t)k++; dij(t); printf(\"%d\\n\",Astar(s,t,k)); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"A-star","slug":"A-star","permalink":"http://yoursite.com/tags/A-star/"}],"author":"小凡"},{"title":"POJ-3468 A Simple Problem with Integers","slug":"POJ3468","date":"2020-03-01T09:31:51.000Z","updated":"2020-03-01T09:34:02.571Z","comments":true,"path":"2020/03/01/POJ3468/","link":"","permalink":"http://yoursite.com/2020/03/01/POJ3468/","excerpt":"","text":"传送门：POJ - 3468 题目描述You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. 输入描述The first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.Each of the next Q lines represents an operation.“C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.“Q a b” means querying the sum of Aa, Aa+1, … , Ab. 输出描述You need to answer all Q commands in order. One answer in a line. 思路分析线段树维护区间和，区间更新 样例输入10 5 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 3 Q 2 4样例输出4 55 9 15线段树代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define umap unordered_map #define uset unordered_set #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e6+10; struct node { int left,right; ll sum; int len() { return right-left+1; } int mid() { return (right+left)/2; } } tree[N*4]; ll a[N],lazy[N]; void pp(int x) { tree[x].sum=tree[x*2].sum+tree[x*2+1].sum; } void pd(int x) { if(lazy[x]) { int mid=(tree[x].left+tree[x].right)/2; lazy[x*2]+=lazy[x]; lazy[x*2+1]+=lazy[x]; tree[x*2].sum+=tree[x*2].len()*lazy[x]; tree[x*2+1].sum+=tree[x*2+1].len()*lazy[x]; lazy[x]=0; } } void build(int x,int l,int r) { tree[x].left=l; tree[x].right=r; if(l==r) { tree[x].sum=a[l]; } else { int mid=tree[x].mid(); build(x*2,l,mid); build(x*2+1,mid+1,r); pp(x); } } void update(int x,int l,int r,ll v) { if(l&lt;=tree[x].left &amp;&amp; tree[x].right&lt;=r) { tree[x].sum+=tree[x].len()*v; lazy[x]+=v; } else { pd(x); int mid=tree[x].mid(); if(l&lt;=mid) update(x*2,l,r,v); if(r>mid) update(x*2+1,l,r,v); pp(x); } } ll query(int x,int l,int r) { ll ans=0; if(l&lt;=tree[x].left &amp;&amp; tree[x].right&lt;=r) { return tree[x].sum; } pd(x); int mid=tree[x].mid(); if(l&lt;=mid) ans+=query(x*2,l,r); if(r>mid) ans+=query(x*2+1,l,r); return ans; } int main() { #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif int n,m; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) scanf(\"%lld\",&amp;a[i]); build(1,1,n); while(m--) { char o; int x,y; ll z; cin>>o; scanf(\"%d%d\",&amp;x,&amp;y); if(o=='C') { scanf(\"%lld\",&amp;z); update(1,x,y,z); } else { printf(\"%lld\\n\",query(1,x,y)); } } return 0; } 分块代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define umap unordered_map #define uset unordered_set #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=100010; int n,m,blo,num; ll bel[N],l[N],r[N],sum[N],tag[N],a[N]; void build() { blo=sqrt(n); num=n/blo; if(n%blo) num++; for(int i=1; i&lt;=num; i++) { l[i]=(i-1)*blo+1; r[i]=i*blo; } r[num]=n; for(int i=1; i&lt;=n; i++) bel[i]=(i-1)/blo+1; for(int i=1; i&lt;=num; i++) for(int j=l[i]; j&lt;=r[i]; j++) sum[i]+=a[j]; } void add(int x,int y,ll v) { if(bel[x]==bel[y]) { for(int i=x; i&lt;=y; i++) { a[i]+=v; sum[bel[x]]+=v; } return ; } for(int i=bel[x]+1; i&lt;bel[y]; i++) tag[i]+=v; for(int i=x; i&lt;=r[bel[x]]; i++) { a[i]+=v; sum[bel[x]]+=v; } for(int i=l[bel[y]]; i&lt;=y; i++) { a[i]+=v; sum[bel[y]]+=v; } } ll query(int x,int y) { ll ans=0; if(bel[x]==bel[y]) { for(int i=x; i&lt;=y; i++) { ans+=a[i]; ans+=tag[bel[x]]; } return ans; } for(int i=bel[x]+1; i&lt;bel[y]; i++) ans+=tag[i]*(r[i]-l[i]+1)+sum[i]; for(int i=x; i&lt;=r[bel[x]]; i++) { ans+=a[i]; ans+=tag[bel[x]]; } for(int i=l[bel[y]]; i&lt;=y; i++) { ans+=a[i]; ans+=tag[bel[y]]; } return ans; } int main() { #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) scanf(\"%lld\",&amp;a[i]); build(); while(m--) { char o; int x,y; ll z; cin>>o; if(o=='C') { scanf(\"%d%d%lld\",&amp;x,&amp;y,&amp;z); add(x,y,z); } else { scanf(\"%d%d\",&amp;x,&amp;y); printf(\"%lld\\n\",query(x,y)); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"分块","slug":"分块","permalink":"http://yoursite.com/tags/%E5%88%86%E5%9D%97/"}],"author":"小凡"},{"title":"HDU-1166 敌兵布阵","slug":"HDU1166","date":"2020-03-01T09:28:26.000Z","updated":"2020-03-01T09:31:31.788Z","comments":true,"path":"2020/03/01/HDU1166/","link":"","permalink":"http://yoursite.com/2020/03/01/HDU1166/","excerpt":"","text":"传送门：HDU - 1166 题目描述C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。 中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. 输入描述第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式： Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30） Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）; Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数; End 表示结束，这条命令在每组数据最后出现; 每组数据最多有40000条命令 输出描述对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 思路分析线段树维护区间和，单点更新 样例输入1 10 1 2 3 4 5 6 7 8 9 10 Query 1 3 Add 3 6 Query 2 7 Sub 10 2 Add 6 3 Query 3 10 End 样例输出Case 1: 6 33 59分块AC代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define umap unordered_map #define uset unordered_set #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=2e5+10; int blo,bel[N],num,l[N],r[N],sum[N]; int n,q,a[N]; void build() { blo=sqrt(n); num=n/blo; if(n%blo) num++; for(int i=1; i&lt;=num; i++) { l[i]=(i-1)*blo+1; r[i]=i*blo; } r[num]=n; for(int i=1; i&lt;=n; i++) bel[i]=(i-1)/blo+1; for(int i=1; i&lt;=num; i++) for(int j=l[i]; j&lt;=r[i]; j++) sum[i]+=a[j]; } void update(int x,int v) { a[x]+=v; sum[bel[x]]+=v; } int query(int x,int y) { int ans=0; if(bel[x]==bel[y]) { for(int i=x; i&lt;=y; i++) ans+=a[i]; return ans; } for(int i=x; i&lt;=r[bel[x]]; i++) ans+=a[i]; for(int i=bel[x]+1; i&lt;bel[y]; i++) ans+=sum[i]; for(int i=l[bel[y]]; i&lt;=y; i++) ans+=a[i]; return ans; } int main() { #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif int t,cnt=1; scanf(\"%d\",&amp;t); while(t--){ printf(\"Case %d:\\n\",cnt++); scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++){ sum[i]=0; scanf(\"%d\",&amp;a[i]); } build(); string s; int x,y; while(cin>>s&amp;&amp;s[0]!='E'){ cin>>x>>y; if(s[0]=='A'){ update(x,y); }else if(s[0]=='S'){ update(x,-y); }else if(s[0]=='Q'){ printf(\"%d\\n\",query(x,y)); } } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"分块","slug":"分块","permalink":"http://yoursite.com/tags/%E5%88%86%E5%9D%97/"}],"author":"小凡"},{"title":"CodeForces - 1295C Obtain The String（二分 / 序列自动机）","slug":"CF1295C","date":"2020-03-01T09:24:41.000Z","updated":"2020-03-01T09:27:27.632Z","comments":true,"path":"2020/03/01/CF1295C/","link":"","permalink":"http://yoursite.com/2020/03/01/CF1295C/","excerpt":"","text":"传送门：CodeForces - 1295C 题目描述You are given two strings s and t consisting of lowercase Latin letters. Also you have a string z which is initially empty. You want string z to be equal to string t. You can perform the following operation to achieve this: append any subsequence of s at the end of string z. A subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements. For example, if z=ac, s=abcde, you may turn z into following strings in one operation: z=acace （if we choose subsequence ace） z=acbcd （if we choose subsequence bcd） z=acbce （if we choose subsequence bce） Note that after this operation string s doesn’t change. Calculate the minimum number of such operations to turn string z into string t. 输入描述The first line contains the integer $T$ $(1≤T≤100)$ — the number of test cases. The first line of each testcase contains one string $s$ $(1≤|s|≤105)$ consisting of lowercase Latin letters. The second line of each testcase contains one string $t$ $(1≤|t|≤105)$ consisting of lowercase Latin letters. 输出描述For each testcase, print one integer — the minimum number of operations to turn string z into string t. If it’s impossible print −1. 思路分析给你两个串s和t，问最小需要几个s中的子序列可以组成t。有种做法。一是序列自动机： 预处理出nex[i][j]数组，表示i之后第一次出现j的位置。 然后暴力匹配就行了。 二是二分查找： 将26个字母的位置存进26个数组中。 位置肯定是有序的，所以可以二分。 也是暴力匹配就行了。 样例输入3 aabce ace abacaba aax ty yyt样例输出1 -1 3二分代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define umap unordered_map #define uset unordered_set #define rson ro&lt;&lt;1|1,mid+1,r #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e5+10; char s[N],t[N]; int main() { #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif int T; cin>>T; while(T--) { int vis[26]= {0}; vector&lt;int>q[26]; scanf(\"%s%s\",s,t); int n=strlen(s),m=strlen(t); for(int i=0; i&lt;m; i++) { vis[t[i]-'a']=1; } for(int i=0; i&lt;n; i++) { vis[s[i]-'a']=0; q[s[i]-'a'].pb(i); } int f=0; for(int i=0; i&lt;26; i++) { if(vis[i]==1) { f=1; break; } } if(f) { puts(\"-1\"); continue; } int ans=1,p=0,idx=-1; while(p!=m) { int x=t[p]-'a'; int nx=upper_bound(q[x].begin(),q[x].end(),idx)-q[x].begin(); if(nx==q[x].size()){ ans++; idx=-1; }else{ p++; idx=q[x][nx]; } } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } 序列自动机代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define umap unordered_map #define uset unordered_set #define rson ro&lt;&lt;1|1,mid+1,r #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e5+10; char s[N],t[N]; int nex[N][26]; int main() { #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif int T; cin>>T; while(T--) { int vis[26]= {0}; scanf(\"%s%s\",s+1,t+1); int n=strlen(s+1),m=strlen(t+1); for(int i=1; i&lt;=m; i++) vis[t[i]-'a']=1; for(int i=1; i&lt;=n; i++) vis[s[i]-'a']=0; int f=0; for(int i=0; i&lt;26; i++) { if(vis[i]==1) { f=1; break; } } if(f) { puts(\"-1\"); continue; } for(int i=0; i&lt;26; i++) nex[n][i]=0; for(int i=n; i>=1; i--) { for(int j=0; j&lt;26; j++) { nex[i-1][j]=nex[i][j]; } nex[i-1][s[i]-'a']=i; } int ans=1,pos=0; for(int i=1; i&lt;=m; i++) { pos=nex[pos][t[i]-'a']; if(!pos) { ans++; i--; pos=0; } } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"},{"name":"序列自动机","slug":"序列自动机","permalink":"http://yoursite.com/tags/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"author":"小凡"},{"title":"CodeForces - 1295E Permutation Separation","slug":"CF1295E","date":"2020-03-01T09:21:27.000Z","updated":"2020-03-01T09:24:15.186Z","comments":true,"path":"2020/03/01/CF1295E/","link":"","permalink":"http://yoursite.com/2020/03/01/CF1295E/","excerpt":"","text":"传送门：CodeForces - 1295E 题目描述You are given a permutation $p_1,p_2,…,p_n$ （an array where each integer from 1 to n appears exactly once）. The weight of the i-th element of this permutation is $a_i$. At first, you separate your permutation into two non-empty sets — prefix and suffix. More formally, the first set contains elements $p_1,p_2,…,p_k$, the second — $p_{k+1},p_{k+2},…,p_n$, where $1≤k&lt;n$. After that, you may move elements between sets. The operation you are allowed to do is to choose some element of the first set and move it to the second set, or vice versa （move from the second set to the first）. You have to pay $a_i$ dollars to move the element $p_i$. Your goal is to make it so that each element of the first set is less than each element of the second set. Note that if one of the sets is empty, this condition is met. For example, if p=[3,1,2] and a=[7,1,4], then the optimal strategy is: separate p into two parts [3,1] and [2] and then move the 2-element into first set （it costs 4）. And if p=[3,5,1,6,2,4], a=[9,1,9,9,1,9], then the optimal strategy is: separate p into two parts [3,5,1] and [6,2,4], and then move the 2-element into first set （it costs 1）, and 5-element into second set （it also costs 1）. Calculate the minimum number of dollars you have to spend. 输入描述The first line contains one integer n $(2≤n≤2⋅10^5)$ — the length of permutation. The second line contains n integers $p_1,p_2,…,p_n$ $(1≤p_i≤n)$. It’s guaranteed that this sequence contains each element from 1 to n exactly once. The third line contains n integers $a_1,a_2,…,a_n (1≤a_i≤10^9)$. 输出描述Print one integer — the minimum number of dollars you have to spend. 思路分析一开始给你一个序列，每个位置都有一个移动他的代价$a_i$，最开始你可以分成两个不空的集合，然后移动过后，使第一个集合中的元素全部小于第二个集合，或者有一个为空集。思路： 枚举第一个集合剩余$i$个元素，那么它的元素肯定是$[1,i]$所有的，除了空集。 有一个基础贡献$base$,要满足，假设要移动$[1,i]$所有，那么这个贡献就是这些之和。 将$[1,i]$的位置上的贡献取负数，那么在前缀里面，如果它的位置已经满足了，那么就会抵消掉$base$中的贡献。 需要注意的是不能一开始有空集，所以是$[1,n-1]$的前缀，且$ans$一开始应该为a[1]（也就是把第一个集合移空的操作的最少花费） 所以，我们可以用一个线段树来维护前缀最小值。 样例输入3 3 1 2 7 1 4样例输出4AC代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define fi first #define se second #define ll long long #define pb push_back #define mp make_pair #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define umap unordered_map #define uset unordered_set #define int long long #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=2e5+10; struct Btree { int left,right,lmi,sum; } tree[N&lt;&lt;2]; int p[N],a[N],pos[N]; void pushup(int x) { if(tree[x].left==tree[x].right) return ; tree[x].sum=tree[x*2].sum+tree[x*2+1].sum; tree[x].lmi=min(tree[x*2].lmi,tree[x*2].sum+tree[x*2+1].lmi); } void build(int x,int l,int r) { tree[x].left=l; tree[x].right=r; if(l==r) { tree[x].lmi=tree[x].sum=a[l]; return ; } else { int mid=(l+r)/2; build(x*2,l,mid); build(x*2+1,mid+1,r); } pushup(x); } void update(int x,int p,int v) { if(tree[x].left==tree[x].right) { tree[x].lmi=v; tree[x].sum=v; } else { int mid=(tree[x].left+tree[x].right)/2; if(p&lt;=mid) update(x*2,p,v); else update(x*2+1,p,v); pushup(x); } } pair&lt;int,int> query(int x,int l,int r) { if(l&lt;=tree[x].left &amp;&amp; tree[x].right&lt;=r) { return mp(tree[x].sum,tree[x].lmi); } else { int mid=(tree[x].left+tree[x].right)/2; if(r&lt;=mid) return query(x*2,l,r); if(l>=mid+1) return query(x*2+1,l,r); pair&lt;int,int>ls=query(x*2,l,r); pair&lt;int,int>rs=query(x*2+1,l,r); return mp(ls.fi+rs.se,min(ls.se,ls.fi+rs.se)); } } signed main() { IOS; #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif int n; cin>>n; for(int i=1;i&lt;=n;i++) cin>>p[i]; for(int i=1;i&lt;=n;i++) cin>>a[i]; for(int i=1;i&lt;=n;i++) pos[p[i]]=i; build(1,1,n); int base=0; int ans=a[1]; for(int i=1;i&lt;=n;i++){ base+=a[pos[i]]; update(1,pos[i],-a[pos[i]]); ans=min(ans,query(1,1,n-1).se+base); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"author":"小凡"},{"title":"CodeForces - 1295D Same GCDs （欧拉函数）","slug":"CF1295D","date":"2020-03-01T09:18:21.000Z","updated":"2020-03-01T09:20:49.045Z","comments":true,"path":"2020/03/01/CF1295D/","link":"","permalink":"http://yoursite.com/2020/03/01/CF1295D/","excerpt":"","text":"传送门：CodeForces - 1295D 题目描述You are given two integers $a$ and $m$. Calculate the number of integers $x$ such that $0≤x&lt;m$ and $gcd(a,m)=gcd(a+x,m)$. 输入描述The first line contains the single integer $T$ $(1≤T≤50)$ — the number of test cases. Next $T$ lines contain test cases — one per line. Each line contains two integers $a$ and $m$ $(1≤a&lt;m≤10^{10})$. 输出描述Print $T$ integers — one per test case. For each test case print the number of appropriate $x-s$. 思路分析借鉴网上的题解，数论题确实恼火： 给出两个正整数 $a$ 和 $m$ ，再给出 $x$ 的范围为 $[0,m)$，现在要求满足 $gcd(a,m)=gcd(a+x,m)$ 时 $x$ 的个数。 首先提取 $a$ 和 $m$ 的最大公约数$g$，令 $a=xg$ , $m=yg$ 题意就可以转化为使得 $gcd(xg,yg)=gcd(xg+z,yg)=g$ 显然可知 $z$ 为 $g$ 的倍数，令$z=kg$, $k\\in[0,y)$ 那么所有满足 $gcd(x+k,y)=1$ 的 $k$ 都可以，即求 $[x,x+y)$ 中与 $y$ 互质的个数 因为$gcd(x,y)=gcd(y,y%x)$，故当 $x+k \\in (y,x+y)$ 时，$gcd(x+k,y)=gcd(y,(x+k)%y)$ 因为 $x&lt;y$，$k \\in [0,y)$，所以$gcd(x+k,y)=gcd(y,(x+k)-y)=1$ 而$x+k-y \\in (0,x)$ 所以$(y,x+y)$中与$y$互质的个数与$(0,x)$中与$y$互质的个数相等 所以答案就是$[1,y)$中，与$y$互质的个数，也就是欧拉函数。 样例输入3 4 9 5 10 42 9999999967样例输出6 1 9999999966AC代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define umap unordered_map #define uset unordered_set #define rson ro&lt;&lt;1|1,mid+1,r #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; ll phi(ll n){ ll m=n; for(int i=2;i&lt;=sqrt(n);i++){ if(n%i==0) //第一次找到的必为素因子 { m-=m/i; //把是素因子i的倍数的数的数目减掉 i,2i,3i,···,(m/i)*i while(n%i==0) n/=i; //把该素因子全部约掉 } } if(n>1) //还有一个比根号n大的素因子 ,也就是现在这个n m-=m/n; return m; } int main() { IOS; #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif int t; cin>>t; while(t--){ ll a,m; cin>>a>>m; cout&lt;&lt;phi(m/__gcd(a,m))&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"}],"author":"小凡"},{"title":"CodeForces - 1287D Numbers on Tree","slug":"CF1287D","date":"2020-03-01T09:15:06.000Z","updated":"2020-03-18T11:07:33.847Z","comments":true,"path":"2020/03/01/CF1287D/","link":"","permalink":"http://yoursite.com/2020/03/01/CF1287D/","excerpt":"","text":"传送门：CodeForces - 1287D 题目描述Evlampiy was gifted a rooted tree. The vertices of the tree are numbered from 1 to n. Each of its vertices also has an integer $a_i$ written on it. For each vertex $i$, Evlampiy calculated $c_i$ — the number of vertices $j$ in the subtree of vertex $i$, such that $a_j&lt;a_i$. After the new year, Evlampiy could not remember what his gift was! He remembers the tree and the values of $c_i$, but he completely forgot which integers $a_i$ were written on the vertices. Help him to restore initial integers! 输入描述The first line contains an integer n $(1≤n≤2000)$ — the number of vertices in the tree. The next $n$ lines contain descriptions of vertices: the i-th line contains two integers $p_i$ and $c_i$ $(0≤p_i≤n; 0≤c_i≤n−1)$, where $p_i$ is the parent of vertex $i$ or 0 if vertex $i$ is root, and $c_i$ is the number of vertices $j$ in the subtree of vertex $i$, such that $a_j&lt;a_i$. It is guaranteed that the values of $p_i$ describe a rooted tree with n vertices. 输出描述If a solution exists, in the first line print “YES”, and in the second line output n integers ai $(1≤a_i≤10^9)$. If there are several solutions, output any of them. One can prove that if there is a solution, then there is also a solution in which all $a_i$ are between 1 and $10^9$. 思路分析大概意思就是，给你一个树，每个点有一个$c$,表示这棵树的子树中有多少个子节点比它的权值小，让你构造出所有点的权值。 样例输入3 2 0 0 2 2 0样例输出YES 1 2 1 AC代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define umap unordered_map #define uset unordered_set #define rson ro&lt;&lt;1|1,mid+1,r #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e5+10; int c[N],ans[N]; vector&lt;int>e[N]; vector&lt;int> dfs(int u){ vector&lt;int>res; for(auto v:e[u]){ vector&lt;int>temp=dfs(v); res.insert(res.end(),all(temp)); } if(c[u]>res.size()){ puts(\"NO\"); exit(0); } res.insert(res.begin()+c[u],u); return res; } int main() { #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif int n,rt; cin>>n; for(int i=1;i&lt;=n;i++){ int x; cin>>x>>c[i]; if(x==0) rt=i; e[x].pb(i); } vector&lt;int>s=dfs(rt); puts(\"YES\"); for(int i=0;i&lt;s.size();i++) ans[s[i]]=i+1; for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;\" \"; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}],"author":"小凡"},{"title":"CodeForces985F - Isomorphic Strings","slug":"CF985F","date":"2020-02-28T15:35:15.000Z","updated":"2020-02-28T15:37:43.750Z","comments":true,"path":"2020/02/28/CF985F/","link":"","permalink":"http://yoursite.com/2020/02/28/CF985F/","excerpt":"","text":"传送门：CodeForces - 985F 题目描述You are given a string s of length n consisting of lowercase English letters. For two given strings $s$ and $t$, say $S$ is the set of distinct characters of $s$ and $T$ is the set of distinct characters of $t$. The strings $s$ and $t$ are isomorphic if their lengths are equal and there is a one-to-one mapping (bijection) $f$ between $S$ and $T$ for which $f(s_i) = t_i$. Formally: $f(s_i) = t_i$ for any index $i$ for any character $ x \\in S$ there is exactly one character $ y\\in T $ that $f(x) = y$ for any character $ y \\in S$ there is exactly one character $ x\\in T $ that $f(x) = y$ For example, the strings “aababc” and “bbcbcz” are isomorphic. Also the strings “aaaww” and “wwwaa” are isomorphic. The following pairs of strings are not isomorphic: “aab” and “bbb”, “test” and “best”. You have to handle m queries characterized by three integers x, y, len (1 ≤ x, y ≤ n - len + 1). For each query check if two substrings s[x… x + len - 1] and s[y… y + len - 1] are isomorphic. 输入描述The first line contains two space-separated integers n and m $(1 ≤ n ≤ 2·10^5, 1 ≤ m ≤ 2·10^5)$ — the length of the string $s$ and the number of queries. The second line contains string s consisting of n lowercase English letters. The following m lines contain a single query on each line: xi, yi and leni $(1 ≤ x_i, y_i ≤ n, 1 ≤ len_i ≤ n - max(x_i, y_i) + 1) $— the description of the pair of the substrings to check. 输出描述For each query in a separate line print “YES” if substrings $s[x_i… x_i + len_i - 1]$ and $s[y_i… y_i + len_i - 1]$ are isomorphic and “NO” otherwise. 思路分析一个长度为n的字符串s，一共有m次询问，每次询问两个子串，如果这两个子串之间存在一种映射关系使两个子串相等，就输入YES。思路： 如果满足，那么肯定两个子串中的不同字母个数位置相同。 可以将原串hash成26个01串。 每次取出子串的26个hash值存进vector中，进行排序，如果两个子串vector相等，那么满足。 样例输入7 4 abacaba 1 1 1 1 4 2 2 1 3 2 4 3样例输出YES YES NO YESAC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define umap unordered_map #define uset unordered_set #define rson ro&lt;&lt;1|1,mid+1,r #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int p=13331,mod=1e9+7; const int N=2e5+10; ll px[N],ha[26][N]; char s[N]; ll get(int i,int x,int y){ return (ha[i][y]-ha[i][x-1]*px[y-x+1]%mod+mod)%mod; } int main() { #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif int n,m; scanf(\"%d%d%s\",&amp;n,&amp;m,s+1); px[0]=1; for(int i=1;i&lt;=n;i++) px[i]=px[i-1]*p%mod; for(int i=0;i&lt;26;i++){ for(int j=1;j&lt;=n;j++){ ha[i][j]=(ha[i][j-1]*p+(s[j]=='a'+i))%mod; } } while(m--){ int x,y,l; cin>>x>>y>>l; vector&lt;ll>a,b; for(int i=0;i&lt;26;i++){ a.pb(get(i,x,x+l-1)); b.pb(get(i,y,y+l-1)); } sort(all(a)); sort(all(b)); if(a==b) puts(\"YES\"); else puts(\"NO\"); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"}],"author":"小凡"},{"title":"CodeForces1288E - Messenger Simulator","slug":"CF1288E","date":"2020-02-28T15:33:09.000Z","updated":"2020-02-28T15:35:00.605Z","comments":true,"path":"2020/02/28/CF1288E/","link":"","permalink":"http://yoursite.com/2020/02/28/CF1288E/","excerpt":"","text":"传送门：CodeForces - 1288E 题目描述Polycarp is a frequent user of the very popular messenger. He’s chatting with his friends all the time. He has n friends, numbered from 1 to n. Recall that a permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. So his recent chat list can be represented with a permutation p of size n. $p_1$ is the most recent friend Polycarp talked to, $p_2$ is the second most recent and so on. Initially, Polycarp’s recent chat list p looks like 1,2,…,n (in other words, it is an identity permutation). After that he receives $m$ messages, the j-th message comes from the friend $a_j$. And that causes friend $a_j$ to move to the first position in a permutation, shifting everyone between the first position and the current position of $a_j$ by 1. Note that if the friend $a_j$ is in the first position already then nothing happens. For example, let the recent chat list be $p$=[4,1,5,3,2]: if he gets messaged by friend 3, then p becomes [3,4,1,5,2]; if he gets messaged by friend 4, then p doesn’t change [4,1,5,3,2]; if he gets messaged by friend 2, then p becomes [2,4,1,5,3]. For each friend consider all position he has been at in the beginning and after receiving each message. Polycarp wants to know what were the minimum and the maximum positions. 输入描述The first line contains two integers $n$ and $m$ $(1≤n,m≤3⋅10^5)$ — the number of Polycarp’s friends and the number of received messages, respectively. The second line contains $m$ integers $a_1,a_2,…,a_m (1≤a_i≤n)$ — the descriptions of the received messages. 输出描述Print n pairs of integers. For each friend output the minimum and the maximum positions he has been in the beginning and after receiving each message. 思路分析一开始有n个数按顺序排列好，有一种操作，可以使数字$x$移动到第一位，后面就向后退一位，求每个数字的最大和最小相对位置。解题思路： 要知道这个数的相对位置，我们可以判断这个数之前有多少个数。 要完成这一操作，暴力肯定不行，但是可以利用树状数组。 可以在数组前放$m$个空位，方便计算。 该位置上用01来表示有无数字 每次操作先询问一遍当前位置是多少，在将该位置置0，在新的位置上置1，并更新位置坐标。 操作完成后再询问一遍每个数，然后就可以得到答案了。 样例输入5 4 3 5 1 4样例输出1 3 2 5 1 4 1 5 1 5AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define umap unordered_map #define uset unordered_set #define rson ro&lt;&lt;1|1,mid+1,r #define all(x) x.begin(),x.end() #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e6+10; int n,m; int pos[N],bit[N],mi[N],ma[N]; void add(int x,int v) { for(int i=x; i&lt;=n+m; i+=lowbit(i)) bit[i]+=v; } int getsum(int x) { int ans=0; for(int i=x; i; i-=lowbit(i)) ans+=bit[i]; return ans; } int main() { IOS; #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif cin>>n>>m; for(int i=1; i&lt;=n; i++) { mi[i]=ma[i]=i; pos[i]=i+m; add(pos[i],1); } for(int i=1; i&lt;=m; i++) { int x; cin>>x; mi[x]=1; ma[x]=max(ma[x],getsum(pos[x])); add(pos[x],-1); pos[x]=m-i+1; add(pos[x],1); } for(int i=1; i&lt;=n; i++) { ma[i]=max(ma[i],getsum(pos[i])); cout&lt;&lt;mi[i]&lt;&lt;\" \"&lt;&lt;ma[i]&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}],"author":"小凡"},{"title":"CodeForces1294F - Three Paths on a Tree（树的直径）","slug":"CF1294F","date":"2020-02-28T15:30:57.000Z","updated":"2020-02-28T15:32:47.134Z","comments":true,"path":"2020/02/28/CF1294F/","link":"","permalink":"http://yoursite.com/2020/02/28/CF1294F/","excerpt":"","text":"传送门：CodeForces - 1294F 题目描述You are given an unweighted tree with n vertices. Recall that a tree is a connected undirected graph without cycles. Your task is to choose three distinct vertices a,b,c on this tree such that the number of edges which belong to at least one of the simple paths between a and b, b and c, or a and c is the maximum possible. See the notes section for a better understanding. The simple path is the path that visits each vertex at most once. 输入描述The first line contains one integer number n $(3≤n≤2⋅10^5)$ — the number of vertices in the tree. Next n−1 lines describe the edges of the tree in form $a_i,b_i (1≤a_i, b_i≤n, a_i≠b_i)$. It is guaranteed that given graph is a tree. 输出描述In the first line print one integer res — the maximum number of edges which belong to at least one of the simple paths between a and b, b and c, or a and c. In the second line print three integers a,b,c such that 1≤a,b,c≤n and a≠,b≠c,a≠c. If there are several answers, you can print any. 思路分析一个树，找到三个点，使这三个点之间的路径的边数之和最大，相同边不重复计算。 可以确定其中两个点一定是树的直径的两个端点。 最后一个端点为直径上一个点，往非直径方向扩展的最深的点。 两次dfs确定直径端点，并标记直径。第三次dfs确定深度最深的第三个点。 样例输入8 1 2 2 3 3 4 4 5 4 6 3 7 3 8样例输出5 1 8 6AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define umap unordered_map #define uset unordered_set #define rson ro&lt;&lt;1|1,mid+1,r #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=2e5+10; int n; vector&lt;int>e[N]; int dep[N],fa[N],vis[N]; void dfs(int u){ if(vis[u]) dep[u]=1; else dep[u]=dep[fa[u]]+1; for(auto v:e[u]){ if(v==fa[u]) continue; fa[v]=u; dfs(v); } } int main() { IOS; #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif cin>>n; for(int i=1;i&lt;n;i++){ int u,v; cin>>u>>v; e[u].pb(v); e[v].pb(u); } int a=0,b=0,c=0,sum=0; dfs(1); for(int i=1;i&lt;=n;i++) if(dep[i]>dep[a]) a=i; fa[a]=0; dfs(a); for(int i=1;i&lt;=n;i++) if(dep[i]>dep[b] &amp;&amp; a!=i) b=i; int x=b; while(x){ vis[x]=1; x=fa[x]; sum++; } dfs(a); for(int i=1;i&lt;=n;i++) if(dep[i]>dep[c]&amp;&amp; a!=i &amp;&amp; b!=i) c=i; x=c; while(!vis[x]){ vis[x]=1; x=fa[x]; sum++; } cout&lt;&lt;sum-1&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;\" \"&lt;&lt;c&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"author":"小凡"},{"title":"洛谷 - P2756 飞行员配对方案问题 （网络流24题）","slug":"luogu2756","date":"2020-02-28T15:28:43.000Z","updated":"2020-02-29T14:15:06.382Z","comments":true,"path":"2020/02/28/luogu2756/","link":"","permalink":"http://yoursite.com/2020/02/28/luogu2756/","excerpt":"","text":"传送门：洛谷 - P2756 题目描述英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的2 名飞行员，其中1 名是英国飞行员，另1名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。如何选择配对飞行的飞行员才能使一次派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。 对于给定的外籍飞行员与英国飞行员的配合情况，编程找出一个最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。 输入描述第 1 行有 2 个正整数 m 和 n。n 是皇家空军的飞行员总数(n&lt;100)；m 是外籍飞行员数(m&lt;=n)。外籍飞行员编号为 1–m；英国飞行员编号为 m+1–n。 接下来每行有 2 个正整数 i 和 j，表示外籍飞行员 i 可以和英国飞行员 j 配合。最后以 2个-1 结束。 输出描述第 1 行是最佳飞行员配对方案一次能派出的最多的飞机数 M。接下来 M 行是最佳飞行员配对方案。每行有 2个正整数 i 和 j，表示在最佳飞行员配对方案中，飞行员 i 和飞行员 j 配对。如果所求的最佳飞行员配对方案不存在，则输出‘No Solution!’。 思路分析建立源点s，汇点t，让1–m所有点与源点相连，m+1—n所有点与汇点相连，最大流就是最佳方案，判断反向边有无流量即可。 样例输入5 10 1 7 1 8 2 6 2 9 2 10 3 7 3 8 4 7 4 8 5 10 -1 -1样例输出4 1 7 2 9 3 8 5 10 AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define umap unordered_map #define uset unordered_set #define rson ro&lt;&lt;1|1,mid+1,r #define int long long #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e5+10; struct node{ int v,w,next; }e[N]; int head[N],cnt; int n,m,s,t,dep[N]; void add(int u,int v,int w){ e[++cnt].v=v; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt; } bool bfs(){ queue&lt;int>q; mem(dep,0); dep[s]=1; q.push(s); while(!q.empty()){ int u=q.front(); q.pop(); for(int i=head[u];i;i=e[i].next){ int v=e[i].v; int w=e[i].w; if(w &amp;&amp; !dep[v]){ dep[v]=dep[u]+1; q.push(v); } } } return dep[t]; } int dfs(int u,int f){ if(u==t) return f; int fl=0; for(int i=head[u];i&amp;&amp;f;i=e[i].next){ int v=e[i].v; if(dep[v]==dep[u]+1 &amp;&amp; e[i].w){ int nx=dfs(v,min(f,e[i].w)); e[i].w-=nx; e[i^1].w+=nx; f-=nx; fl+=nx; } } if(!fl) dep[u]=-2; return fl; } int dinic(){ int ans=0; while(bfs()) ans+=dfs(s,INF); return ans; } signed main() { IOS; #ifdef xiaofan freopen(\"in.txt\",\"r\",stdin); #endif cin>>m>>n; cnt=1; s=0,t=n+1; int a,b; while(cin>>a>>b){ if(a==-1 &amp;&amp; b==-1) break; add(a,b,INF); add(b,a,0); } for(int i=1;i&lt;=m;i++){ add(s,i,1); add(i,s,0); } for(int i=m+1;i&lt;=n;i++){ add(i,t,1); add(t,i,0); } int ans=dinic(); if(!ans){ cout&lt;&lt;\"No Solution\"&lt;&lt;endl; return 0; } cout&lt;&lt;ans&lt;&lt;endl; for(int i=2;i&lt;=cnt;i+=2){ if(e[i].v==s||e[i^1].v==t) continue; if(e[i].v==t||e[i^1].v==s) continue; if(e[i^1].w) cout&lt;&lt;e[i^1].v&lt;&lt;\" \"&lt;&lt;e[i].v&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"author":"小凡"},{"title":"Dijkstra 模板","slug":"Dij","date":"2020-02-28T15:19:40.000Z","updated":"2020-04-20T14:15:38.962Z","comments":true,"path":"2020/02/28/Dij/","link":"","permalink":"http://yoursite.com/2020/02/28/Dij/","excerpt":"","text":"复杂度：$O(（n+m）logm)$ #include&lt;bits/stdc++.h> using namespace std; #define fi first #define se second #define ll long long #define pii pair&lt;int,int> #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; const int N=2002; struct edge { int next,to,w; } e[N]; int n,m; int head[N],cnt=0,vis[N],dis[N]; void add(int u,int v,int w) { e[++cnt].to=v; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt; } void dij(int s) { mem(dis,INF); mem(vis,0); dis[s]=0; priority_queue&lt;pair&lt;int,int> > q; q.push(make_pair(-dis[s],s)); while(!q.empty()) { int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u]; i; i=e[i].next) { int v=e[i].to; if(!vis[v]&amp;&amp;dis[v]>dis[u]+e[i].w) { dis[v]=dis[u]+e[i].w; q.push(make_pair(-dis[v],v)); } } } } int main() { cin>>n>>m; cnt=1; memset(head,0,sizeof(head)); for(int i=1; i&lt;=m; i++) { int u,v,w; cin>>u>>v>>w; add(u,v,w); add(v,u,w); } dij(3); for(int i=1; i&lt;=n; i++) cout&lt;&lt;dis[i]&lt;&lt;\" \"; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"author":"小凡"},{"title":"SPFA 模板","slug":"SPFA","date":"2020-02-28T15:17:52.000Z","updated":"2020-04-20T14:15:09.879Z","comments":true,"path":"2020/02/28/SPFA/","link":"","permalink":"http://yoursite.com/2020/02/28/SPFA/","excerpt":"","text":"复杂度：$O(nm)$ #include&lt;bits/stdc++.h> using namespace std; #define ll long long #define ull unsigned long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; const int N=2002; struct node { int to,val,next; } e[N]; int n,m; int head[N],dis[N],vis[N],cnt; void add(int u,int v,int w) { e[++cnt].to=v; e[cnt].val=w; e[cnt].next=head[u]; head[u]=cnt; } void spfa(int s) { mem(dis,INF); mem(vis,0); dis[s]=0; vis[s]=1; queue&lt;int> q; q.push(s); while(!q.empty()) { int u=q.front(); vis[u]=0; q.pop(); for(int i=head[u]; i; i=e[i].next) { int v=e[i].to; if(dis[v]>(dis[u]+e[i].val)) { dis[v]=dis[u]+e[i].val; if(!vis[v]) { vis[v]=1; q.push(v); } } } } } int main() { cin>>n>>m; memset(head,0,sizeof(head)); cnt=1; for(int i=1; i&lt;=m; i++) { int u,v,w; cin>>u>>v>>w; add(u,v,w); add(v,u,w); } spfa(1); for(int i=1;i&lt;=n;i++) cout&lt;&lt;dis[i]&lt;&lt;\" \"; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"author":"小凡"},{"title":"LCA 各种模板","slug":"LCA","date":"2020-02-28T15:01:33.000Z","updated":"2020-03-27T05:28:36.750Z","comments":true,"path":"2020/02/28/LCA/","link":"","permalink":"http://yoursite.com/2020/02/28/LCA/","excerpt":"","text":"LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。 ———来自百度百科 倍增LCA预处理复杂度$O(nlogn)$,查询复杂度$O(logn)$ struct node { int v,next; } e[N]; int n,m; int cnt,head[N],dep[N],fa[N][22],lg[N]; void add(int u,int v) { e[++cnt].v=v; e[cnt].next=head[u]; head[u]=cnt; } void init(){ for(int i=1; i&lt;=n; i++) lg[i]=lg[i-1]+((1&lt;&lt;lg[i-1])==i); } void dfs(int u,int f) { fa[u][0]=f; dep[u]=dep[f]+1; for(int i=1; i&lt;=lg[dep[u]]; i++) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[u]; i; i=e[i].next) if(e[i].v!=f) dfs(e[i].v,u); } int lca(int x,int y) { if(dep[x]&lt;dep[y]) swap(x,y); while(dep[x]>dep[y]) x=fa[x][lg[dep[x]-dep[y]]-1]; if(x==y) return x; for(int k=lg[dep[x]]-1; k>=0; k--) if(fa[x][k]!=fa[y][k]) x=fa[x][k],y=fa[y][k]; return fa[x][0]; } 树剖LCA预处理复杂度$O(n)$，查询复杂度$O(logn)$ vector&lt;int>e[N]; int fa[N],dep[N],son[N],siz[N],top[N]; void dfs1(int u,int f) { fa[u]=f; dep[u]=dep[f]+1; siz[u]=1; int maxsize=-1; for(auto v:e[u]) { if(v==f)continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]>maxsize) { son[u]=v; maxsize=siz[v]; } } } void dfs2(int u,int t) { top[u]=t; if(!son[u]) return ; dfs2(son[u],t); for(auto v:e[u]) { if(v==son[u]||v==fa[u]) continue; dfs2(v,v); } } int lca(int x,int y) { while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; } return dep[x]>dep[y]?y:x; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"http://yoursite.com/tags/LCA/"}]},{"title":"HDU - 3667 Transportation","slug":"HDU3667","date":"2020-02-28T14:58:17.000Z","updated":"2020-05-21T08:52:34.034Z","comments":true,"path":"2020/02/28/HDU3667/","link":"","permalink":"http://yoursite.com/2020/02/28/HDU3667/","excerpt":"","text":"传送门：HDU - 3667 题目描述There are N cities, and M directed roads connecting them. Now you want to transport K units of goods from city 1 to city N. There are many robbers on the road, so you must be very careful. The more goods you carry, the more dangerous it is. To be more specific, for each road i, there is a coefficient $a_i$. If you want to carry x units of goods along this road, you should pay $a_i * x^2$ dollars to hire guards to protect your goods. And what’s worse, for each road i, there is an upper bound $C_i$, which means that you cannot transport more than $C_i$ units of goods along this road. Please note you can only carry integral unit of goods along each road.You should find out the minimum cost to transport all the goods safely. 输入描述There are several test cases. The first line of each case contains three integers, N, M and K. (1 &lt;= N &lt;= 100, 1 &lt;= M &lt;= 5000, 0 &lt;= K &lt;= 100). Then M lines followed, each contains four integers ($u_i, v_i, a_i, C_i)$, indicating there is a directed road from city $u_i to v_i$, whose coefficient is $a_i$ and upper bound is $C_i$. $(1 &lt;= u_i, v_i &lt;= N, 0 &lt; a_i &lt;= 100, C_i &lt;= 5)$ 输出描述Output one line for each test case, indicating the minimum cost. If it is impossible to transport all the K units of goods, output -1. 思路分析很容易看出是道费用流，可以边的费用不是普通的，跟运送量有关系，直接建边跑的话是不行的。所以可以这样考虑每一条边 假设有一条边是$u,v,2,3$ 因为C最大只有5，所以我们可以拆边，拆成C条容量为1的边。 这条边的花费分别是：2，8，18。 第一条边花费为2，第二条边花费为8-2=6，第三条边花费为18-8=10。 那么可以将这条容量为3的边，拆成三条容量为1的边，权值分别是：1×1×1，2×2×2-2×1×1，2×3×3-2×2×2。 样例输入2 1 2 1 2 1 2 2 1 2 1 2 1 1 2 2 2 1 2 1 2 1 2 2 2样例输出4 -1 3AC代码 #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define umap unordered_map #define uset unordered_set #define rson ro&lt;&lt;1|1,mid+1,r #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e4+10; const int M=1e6+10; struct node { int v,flow,w,next; } e[M]; int head[N],cnt; int n,m,s,t,k,maxflow,mincost,path[N],pre[N]; int dis[N],vis[N]; inline void ade(int u,int v,int f,int w) { e[++cnt].v=v; e[cnt].flow=f; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt; } inline void add(int u,int v,int f,int w) { ade(u,v,f,w); ade(v,u,0,-w); } inline bool spfa() { mem(dis,INF); mem(vis,0); mem(pre,-1); dis[s]=0; vis[s]=1; queue&lt;int>q; q.push(s); while(!q.empty()) { int u=q.front(); vis[u]=0; q.pop(); for(int i=head[u]; i; i=e[i].next) { int v=e[i].v; int w=e[i].w; if(e[i].flow &amp;&amp; dis[v]>dis[u]+w) { dis[v]=dis[u]+w; pre[v]=u; path[v]=i; if(!vis[v]) { q.push(v); vis[v]=1; } } } } return pre[t]!=-1; } inline void EK() { while(spfa()) { int mi=INF; for(int i=t; i!=s; i=pre[i]) mi=min(mi,e[path[i]].flow); for(int i=t; i!=s; i=pre[i]) { e[path[i]].flow-=mi; e[path[i]^1].flow+=mi; } maxflow+=mi; mincost+=dis[t]*mi; } } inline void init() { cnt=1; mem(head,0); maxflow=mincost=0; s=0; t=n+1; add(s,1,k,0); add(n,t,k,0); } int main() { while(~scanf(\"%d %d %d\",&amp;n,&amp;m,&amp;k)) { init(); while(m--){ int u,v,a,c; scanf(\"%d %d %d %d\",&amp;u,&amp;v,&amp;a,&amp;c); for(int i=1;i&lt;=c;i++) add(u,v,1, a*(i*i-(i-1)*(i-1)) ); } EK(); printf(\"%d\\n\",maxflow==k?mincost:-1); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"费用流","slug":"费用流","permalink":"http://yoursite.com/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"洛谷 - P3381 最小费用最大流 （SPFA费用流模板）","slug":"luogu3381","date":"2020-02-28T14:56:06.000Z","updated":"2020-05-21T08:52:07.684Z","comments":true,"path":"2020/02/28/luogu3381/","link":"","permalink":"http://yoursite.com/2020/02/28/luogu3381/","excerpt":"","text":"传送门：洛谷 - P3381 题目描述如题，给出一个网络图，以及其源点和汇点，每条边已知其最大流量和单位流量费用，求出其网络最大流和在最大流情况下的最小费用。 输入描述第一行包含四个正整数N、M、S、T，分别表示点的个数、有向边的个数、源点序号、汇点序号。 接下来M行每行包含四个正整数$u_i、v_i、w_i、f_i$，表示第i条有向边从$u_i$出发，到达$v_i$，边权为$w_i$（即该边最大流量为$w_i$），单位流量的费用为$f_i$。 输出描述一行，包含两个整数，依次为最大流量和在最大流量情况下的最小费用。 思路分析SPFA费用流模板 样例输入4 5 4 3 4 2 30 2 4 3 20 3 2 3 20 1 2 1 30 9 1 3 40 5样例输出50 280AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define umap unordered_map #define uset unordered_set #define rson ro&lt;&lt;1|1,mid+1,r #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1e4+10; const int M=1e6+10; struct node { int v,flow,w,next; } e[M]; int head[N],cnt; int n,m,s,t,k,maxflow,mincost,path[N],pre[N]; int dis[N],vis[N]; inline void ade(int u,int v,int f,int w) { e[++cnt].v=v; e[cnt].flow=f; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt; } inline void add(int u,int v,int f,int w) { ade(u,v,f,w); ade(v,u,0,-w); } inline bool spfa() { mem(dis,INF); mem(vis,0); mem(pre,-1); dis[s]=0; vis[s]=1; queue&lt;int>q; q.push(s); while(!q.empty()) { int u=q.front(); vis[u]=0; q.pop(); for(int i=head[u]; i; i=e[i].next) { int v=e[i].v; int w=e[i].w; if(e[i].flow &amp;&amp; dis[v]>dis[u]+w) { dis[v]=dis[u]+w; pre[v]=u; path[v]=i; if(!vis[v]) { q.push(v); vis[v]=1; } } } } return pre[t]!=-1; } inline void EK() { while(spfa()) { int mi=INF; for(int i=t; i!=s; i=pre[i]) mi=min(mi,e[path[i]].flow); for(int i=t; i!=s; i=pre[i]) { e[path[i]].flow-=mi; e[path[i]^1].flow+=mi; } maxflow+=mi; mincost+=dis[t]*mi; } } int main() { IOS; cin>>n>>m>>s>>t; mem(head,0); cnt=1; while(m--){ int a,b,c,d; cin>>a>>b>>c>>d; add(a,b,c,d); } EK(); cout&lt;&lt;maxflow&lt;&lt;\" \"&lt;&lt;mincost&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"费用流","slug":"费用流","permalink":"http://yoursite.com/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"HDU - 3061 Battle （最大权闭合图-最小割/最大流）","slug":"HDU3061","date":"2020-02-28T14:52:05.000Z","updated":"2020-02-28T14:55:38.760Z","comments":true,"path":"2020/02/28/HDU3061/","link":"","permalink":"http://yoursite.com/2020/02/28/HDU3061/","excerpt":"","text":"传送门：HDU - 3061 题目描述由于小白同学近期习武十分刻苦，很快被晋升为天策军的统帅。而他上任的第一天，就面对了一场极其困难的战斗：据侦查兵回报，前方共有N座城池，考虑到地势原因，最终得到一个结论：攻占某些城池之前必须攻占另外一些城池。事实上，可以把地图看做是一张拓扑图，而攻占某个城池，就意味着必须先攻占它的所有前驱结点。小白还做了一份调查，得到了攻占每个城池会对他的兵力产生多少消耗（当然也可能会得到增长，因为每攻占一个城池，便可以整顿军队，扩充兵力，天策军的兵力十分庞大，如果不考虑收益，他们可以攻取所有的城池）。现在请你帮小白统帅做一份战斗计划，挑选攻打哪些城市，使得天策军在战斗过后军容最为壮大。 输入描述首先输入一个N 代表有N个城池（1&lt;= n &lt;= 500）接着输入一个M，代表城池和城池之间的拓扑关系数。接着输入N个数字 代表从1 到 N 编号城池的战斗消耗（负数代表将要消耗天策军兵力，正数表示天策军可以获得相应的战斗收益）最后M行 每行2个数字 a，b，代表相应城池的编号。表示攻占b之后才可以攻占a； 输出描述天策军最大能获得多少战斗收益 思路分析 最大权闭合图模板，ans=sum-maxflow 建图方式如下： 建立源点s，连接源点与所有正权的点。 建立汇点t，连接汇点与所有负权的点，权值为绝对值。 讲有依赖关系的点连边，权值为INF，比如a的攻占需要先攻占b，则连a–&gt;b的有向边，权值为INF。 最后所以正权和-最大流就是答案 样例输入5 5 8 -8 -10 12 -10 1 2 2 5 1 4 3 4 4 5样例输出2AC代码 #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define umap unordered_map #define uset unordered_set #define rson ro&lt;&lt;1|1,mid+1,r #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=5555,M=1000010; struct node{ int v,w,next; }e[M]; int head[N],h[N],cnt,n,m,s,t; inline void adde(int u,int v,int w){ e[++cnt].v=v; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt; } inline void add(int u,int v,int w){ adde(u,v,w); adde(v,u,0); } inline bool bfs(){ queue&lt;int>q; mem(h,0); h[s]=1; q.push(s); while(!q.empty()){ int u=q.front(); q.pop(); if(u==t) return 1; for(int i=head[u];i;i=e[i].next){ if(e[i].w &amp;&amp; !h[e[i].v]){ q.push(e[i].v); h[e[i].v]=h[u]+1; } } } return 0; } inline int dfs(int u,int f){ if(u==t) return f; int fl=0; for(int i=head[u];i&amp;&amp;f;i=e[i].next){ int v=e[i].v; if(h[v]==h[u]+1 &amp;&amp; e[i].w){ int nx=dfs(v,min(f,e[i].w)); e[i].w-=nx; e[i^1].w+=nx; f-=nx; fl+=nx; } } if(!fl) h[u]=-2; return fl; } inline int dinic(){ int ans=0; while(bfs()){ ans+=dfs(s,INF); } return ans; } int main() { while(~scanf(\"%d%d\",&amp;n,&amp;m)){ cnt=1; mem(head,0); t=n+1; int sum=0; for(int i=1;i&lt;=n;i++){ int x; scanf(\"%d\",&amp;x); if(x>0){ add(s,i,x); sum+=x; }else{ add(i,t,-x); } } for(int i=0;i&lt;m;i++){ int u,v; scanf(\"%d%d\",&amp;u,&amp;v); add(u,v,INF); } printf(\"%d\\n\",sum-dinic()); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"最大权闭合图","slug":"最大权闭合图","permalink":"http://yoursite.com/tags/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%9B%BE/"}]},{"title":"HDU - 3549 Flow Problem （Dinic模板）","slug":"HDU3549","date":"2020-02-28T14:49:01.000Z","updated":"2020-07-08T02:20:28.003Z","comments":true,"path":"2020/02/28/HDU3549/","link":"","permalink":"http://yoursite.com/2020/02/28/HDU3549/","excerpt":"","text":"传送门：HDU - 3549 题目描述Network flow is a well-known difficult problem for ACMers. Given a graph, your task is to find out the maximum flow for the weighted directed graph. 输入描述The first line of input contains an integer T, denoting the number of test cases.For each test case, the first line contains two integers N and M, denoting the number of vertexes and edges in the graph. (2 &lt;= N &lt;= 15, 0 &lt;= M &lt;= 1000)Next M lines, each line contains three integers X, Y and C, there is an edge from X to Y and the capacity of it is C. (1 &lt;= X, Y &lt;= N, 1 &lt;= C &lt;= 1000) 输出描述For each test cases, you should output the maximum flow from source 1 to sink N. 思路分析Dinic模板 样例输入2 3 2 1 2 1 2 3 1 3 3 1 2 1 2 3 1 1 3 1样例输出Case 1: 1 Case 2: 2AC代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define umap unordered_map #define uset unordered_set #define rson ro&lt;&lt;1|1,mid+1,r #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=1005,M=100005; struct node { int v,w,next; } e[M]; int head[N],dep[N],cnt=1; int n,m; void add(int u,int v,int w) { e[++cnt].v=v; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt; } bool bfs(int s,int t) { queue&lt;int>q; mem(dep,0); dep[s]=1; q.push(s); while(!q.empty()) { int u=q.front(); q.pop(); for(int i=head[u]; i ; i=e[i].next) { int v=e[i].v; int w=e[i].w; if(w &amp;&amp; !dep[v]) { dep[v]=dep[u]+1; q.push(v); } } } return dep[t]; } int dfs(int u,int f,int t) { int fl=0; if(u==t) return f; for(int i=head[u]; i &amp;&amp; f ; i=e[i].next) { int v=e[i].v; if(dep[v]==dep[u]+1 &amp;&amp; e[i].w) { int nx=dfs(v,min(f,e[i].w),t); e[i].w-=nx; e[i^1].w+=nx; f-=nx; fl+=nx; } } if(!fl) dep[u]=-2; return fl; } int dinic(int s,int t) { int ans=0; while(bfs(s,t)) ans+=dfs(s,INF,t); return ans; } int main() { int t; scanf(\"%d\",&amp;t); for(int T=1; T&lt;=t; T++) { cnt=1; mem(head,0); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=0; i&lt;m; i++) { int u,v,w; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,0);//如果是无向图就是初始流量，有向图是0 } printf(\"Case %d: %d\\n\",T,dinic(1,n)); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"Light oj 1074 - Extended Traffic（SPFA判负环）","slug":"LTOJ1074","date":"2020-02-28T14:46:59.000Z","updated":"2020-02-28T14:50:17.118Z","comments":true,"path":"2020/02/28/LTOJ1074/","link":"","permalink":"http://yoursite.com/2020/02/28/LTOJ1074/","excerpt":"","text":"传送门：Light oj - 1074 题目描述Dhaka city is getting crowded and noisy day by day. Certain roads always remain blocked in congestion. In order to convince people avoid shortest routes, and hence the crowded roads, to reach destination, the city authority has made a new plan. Each junction of the city is marked with a positive integer (≤ 20) denoting the busyness of the junction. Whenever someone goes from one junction (the source junction) to another (the destination junction), the city authority gets the amount (busyness of destination - busyness of source)3 (that means the cube of the difference) from the traveler. The authority has appointed you to find out the minimum total amount that can be earned when someone intelligent goes from a certain junction (the zero point) to several others. 输入描述Input starts with an integer T (≤ 50), denoting the number of test cases. Each case contains a blank line and an integer n (1 &lt; n ≤ 200) denoting the number of junctions. The next line contains n integers denoting the busyness of the junctions from 1 to n respectively. The next line contains an integer m, the number of roads in the city. Each of the next m lines (one for each road) contains two junction-numbers (source, destination) that the corresponding road connects (all roads are unidirectional). The next line contains the integer q, the number of queries. The next q lines each contain a destination junction-number. There can be at most one direct road from a junction to another junction. 输出描述For each case, print the case number in a single line. Then print q lines, one for each query, each containing the minimum total earning when one travels from junction 1 (the zero point) to the given junction. However, for the queries that gives total earning less than 3, or if the destination is not reachable from the zero point, then print a ‘?’. 思路分析1为源点,（u，v）的距离为(m[v] -m[u])3的，如果从源点到该点的距离小于3则输出？，否则输出距离。如果存在负环，那负环上的点到源点的距离肯定小于3 样例输入2 5 6 7 8 9 10 6 1 2 2 3 3 4 1 5 5 4 4 5 2 4 5 2 10 10 1 1 2 1 2样例输出Case 1: 3 4 Case 2: ?AC代码 #include&lt;bits/stdc++.h> using namespace std; #define ll long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; const int N=222; inline int read () { register int s = 0, w = 1; register char ch = getchar (); while (! isdigit (ch)) {if (ch == '-') w = -1; ch = getchar ();} while (isdigit (ch)) {s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + (ch ^ 48); ch = getchar ();} return s * w; } int a[N],e[N][N],vis[N],dis[N],isring[N],num[N],cur[N]; int n; void dfs(int x) { //找负环上的点 isring[x]=1; for(int i=1; i&lt;=n; i++) { if(e[x][i]!=INF &amp;&amp; !isring[i]) dfs(i); } } void spfa() { fill(dis,dis+N,INF); queue&lt;int>q; vis[1]=1; dis[1]=0; q.push(1); while(!q.empty()) { int u=q.front(); q.pop(); vis[u]=0; for(int i=1; i&lt;=n; i++) { if(isring[i]) continue; //如果已经是负环上的点，则不再入队列 if(dis[i]>dis[u]+e[u][i]&amp;&amp;e[u][i]!=INF) { dis[i]=dis[u]+e[u][i]; if(!vis[i]) { vis[i]=1; q.push(i); cur[i]=cur[u]+1; if(cur[i]>=n) //如果某条路的边有n条，那么一定存在负环 dfs(i); } } } } } int main() { int t,cnt=0; t=read(); while(t--) { memset(cur,0,sizeof(num)); memset(isring,0,sizeof(isring)); memset(vis,0,sizeof(vis)); n=read(); for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) e[i][j]=INF; } for(int i=1; i&lt;=n; i++) a[i]=read(); int m; m=read(); for(int i=0; i&lt;m; i++) { int x,y; x=read(); y=read(); e[x][y]=pow((a[y]-a[x]),3); } spfa(); int tt; tt=read(); printf(\"Case %d:\\n\",++cnt); while(tt--) { int x; x=read(); if(dis[x]&lt;3||dis[x]==INF||isring[x]) printf(\"?\\n\"); else printf(\"%d\\n\",dis[x]); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"CodeForces1228D - Complete Tripartite","slug":"CF1228D","date":"2020-02-28T14:44:10.000Z","updated":"2020-02-28T14:46:20.017Z","comments":true,"path":"2020/02/28/CF1228D/","link":"","permalink":"http://yoursite.com/2020/02/28/CF1228D/","excerpt":"","text":"传送门：CodeForces - 1228D 题目描述You have a simple undirected graph consisting of n vertices and m edges. The graph doesn’t contain self-loops, there is at most one edge between a pair of vertices. The given graph can be disconnected. Let’s make a definition. Let $v_1$ and $v_2$ be two some nonempty subsets of vertices that do not intersect. Let $f(v_1,v_2)$ be true if and only if all the conditions are satisfied: There are no edges with both endpoints in vertex set $v_1$. There are no edges with both endpoints in vertex set $v_2$. For every two vertices $x$ and $y$ such that $x$ is in $v_1$ and $y$ is in $v_2$, there is an edge between $x$ and $y$. Create three vertex sets $(v_1, v_2, v_3)$ which satisfy the conditions below; All vertex sets should not be empty. Each vertex should be assigned to only one vertex set. $f(v_1,v_2)$, $f(v_2,v_3)$, $f(v_3,v_1)$ are all true. Is it possible to create such three vertex sets? If it’s possible, print matching vertex set for each vertex. 输入描述The first line contains two integers n and m $(3≤n≤10^5, 0≤m≤min(3⋅10^5,\\frac{n(n-1)}{2}))$ — the number of vertices and edges in the graph. The i-th of the next m lines contains two integers $a_i$ and $b_i$ $(1≤a_i&lt;b_i≤n)$ — it means there is an edge between ai and bi. The graph doesn’t contain self-loops, there is at most one edge between a pair of vertices. The given graph can be disconnected. 输出描述If the answer exists, print n integers. i-th integer means the vertex set number (from 1 to 3) of i-th vertex. Otherwise, print −1. If there are multiple answers, print any. 思路分析n个点m条边的无向图，问能不能将这些点分成三个集合，每个集合中的点互不相连，每个集合中的点除了自身集合的点之外，与其余每个点都相连。我们只要确定一个点，就能确定哪些点跟它不在一个集合（与这个点相连的点），一开始都在一个集合，枚举每个点$u$，如果与之连边的点$v$的集合是同一个，那个使$v$这个点的集合+1。如果集合数超出了3，那么肯定不行。还有一点，三个集合之间的边数肯定等于互相之间点的乘积，最后判断总和等不等与$m$。 样例输入6 11 1 2 1 3 1 4 1 5 1 6 2 4 2 5 2 6 3 4 3 5 3 6 样例输出1 2 2 3 3 3AC代码 #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define umap unordered_map #define uset unordered_set #define rson ro&lt;&lt;1|1,mid+1,r #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; const int N=3e5+50; int color[N],ans[N]; vector&lt;int>e[N]; int main() { int n,m; cin>>n>>m; for(int i=0; i&lt;m; i++) { int a,b; cin>>a>>b; e[a].pb(b); e[b].pb(a); } for(int i=1; i&lt;=n; i++) color[i]=1; int tot=1; for(int u=1; u&lt;=n; u++) { for(auto v:e[u]) { if(color[v]==color[u]) color[v]++; tot=max(tot,color[v]); } } if(tot!=3) { puts(\"-1\"); } else { for(int i=1; i&lt;=n; i++) ans[color[i]]++; if(ans[1]*ans[2]+ans[2]*ans[3]+ans[1]*ans[3]!=m) puts(\"-1\"); else for(int i=1; i&lt;=n; i++) cout&lt;&lt;color[i]&lt;&lt;\" \"; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"AcWing - 179.八数码","slug":"acwing179","date":"2020-02-28T14:40:18.000Z","updated":"2020-02-28T14:43:04.480Z","comments":true,"path":"2020/02/28/acwing179/","link":"","permalink":"http://yoursite.com/2020/02/28/acwing179/","excerpt":"","text":"传送门：AcWing - 179 题目描述在一个3×3的网格中，1~8这8个数字和一个“X”恰好不重不漏地分布在这3×3的网格中。例如： 1 2 3x 4 67 5 8 在游戏过程中，可以把“X”与其上、下、左、右四个方向之一的数字交换（如果存在）。 我们的目的是通过交换，使得网格变为如下排列（称为正确排列）： 1 2 34 5 67 8 x 把“X”与上下左右方向数字交换的行动记录为“u”、“d”、“l”、“r”。现在，给你一个初始网格，请你通过最少的移动次数，得到正确排列。 输入描述输入占一行，将3×3的初始网格描绘出来。 输出描述输出占一行，包含一个字符串，表示得到正确排列的完整行动记录。如果答案不唯一，输出任意一种合法方案即可。 如果不存在解决方案，则输出”unsolvable”。 思路分析对于这类问题，我们知道一个结论，如果去除空格将数排列起来，如果逆序对的个数为奇数，那么肯定无解，那么对于有解的情况，这道题可以用普通的BFS做，这里用的是A*算法，定义一个估价函数，即每一个数到它正确的位置的曼哈顿距离之和。 样例输入2 3 4 1 5 x 7 6 8 样例输出ullddrurdllurdruldrAC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> #if __cplusplus >= 201103L #include &lt;unordered_map> #include &lt;unordered_set> #endif #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define umap unordered_map #define uset unordered_set #define rson ro&lt;&lt;1|1,mid+1,r #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); using namespace std; const int INF = 0x3f3f3f3f; int dx[4]={1,-1,0,0},dy[4]={0,0,1,-1}; char op[4]={'d','u','r','l'}; int f(string s){ int sum=0; for(int i=0;i&lt;s.size();i++){ if(s[i]!='x'){ int t=s[i]-'1'; sum+=abs(i/3-t/3)+abs(i%3-t%3); } } return sum; } string Astar(string st){ string end=\"12345678x\"; umap&lt;string,int>dis; umap&lt;string,bool>vis; umap&lt;string,pair&lt;string,char>>pre; priority_queue&lt;pair&lt;int,string>,vector&lt;pair&lt;int,string>>,greater&lt;pair&lt;int,string>>> q; dis[st]=0; q.push({f(st),st}); while(!q.empty()){ auto t=q.top(); q.pop(); string now=t.se; if(now==end) break; if(vis[now]) continue; vis[now]=true; int step=dis[now]; int x,y; for(int i=0;i&lt;now.size();i++){ if(now[i]=='x'){ x=i/3; y=i%3; break; } } string u=now; for(int i=0;i&lt;4;i++){ int nx=x+dx[i]; int ny=y+dy[i]; if( nx>=0 &amp;&amp; nx&lt;3 &amp;&amp; ny>=0 &amp;&amp; ny&lt;3){ swap(now[x*3+y],now[nx*3+ny]); if(!dis.count(now)||dis[now]>step+1){ dis[now]=step+1; pre[now]={u,op[i]}; q.push({dis[now]+f(now),now}); } swap(now[x*3+y],now[nx*3+ny]); } } } string ans; while(end!=st){ ans+=pre[end].se; end=pre[end].fi; } reverse(ans.begin(),ans.end()); return ans; } int main() { string a,b,c; while(cin>>b){ a+=b; if(b!=\"x\") c+=b; } int t=0; for(int i=0;i&lt;c.size();i++) for(int j=i+1;j&lt;c.size();j++) if(c[j]&lt;c[i]) t++; if(t&amp;1) puts(\"unsolvable\"); else cout&lt;&lt;Astar(a)&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"A-star","slug":"A-star","permalink":"http://yoursite.com/tags/A-star/"}]},{"title":"牛客 - I love you（线性DP）","slug":"NK3947I","date":"2020-02-28T14:37:51.000Z","updated":"2020-02-28T14:39:56.629Z","comments":true,"path":"2020/02/28/NK3947I/","link":"","permalink":"http://yoursite.com/2020/02/28/NK3947I/","excerpt":"","text":"传送门：牛客 - 3947I 题目描述 此时相望不相闻，愿逐月华流照君。 一纸情书，到底蕴含了多少倍的爱情呢？ I love you, not only for what you are, but for what I am when I am with you. 输入描述共一行：一封若干个字符的情书（大小写不敏感）。情书不会超过684594个字符（大写、小写字母）。 输出描述共一行：包含一个整数，即iloveyou在情书中作为子序列出现的次数。由于答案可能很大，请输出对20010905取模后的值。 思路分析令dp[i]表示遍历到当前位置，已经匹配了字符串的第i位。 dp[1]=dp[1]+s[i]== i dp[2]=dp[2]+dp[1]*s[i]== l dp[3]=dp[3]+dp[2]*s[i]== o …… dp[8]就是答案 样例输入IloveyouNotonlyforwhatyouareButforwhatIamWhen样例输出17AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define rson ro&lt;&lt;1|1,mid+1,r #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; const int MOD=20010905; ll dp[8]; int main() { IOS; string s; cin>>s; for(auto i:s){ if( i=='i' || i=='I')dp[1]=(dp[1]+1)%MOD; if( i=='l' || i=='L')dp[2]=(dp[2]+dp[1])%MOD; if( i=='o' || i=='O')dp[3]=(dp[3]+dp[2])%MOD; if( i=='v' || i=='V')dp[4]=(dp[4]+dp[3])%MOD; if( i=='e' || i=='E')dp[5]=(dp[5]+dp[4])%MOD; if( i=='y' || i=='Y')dp[6]=(dp[6]+dp[5])%MOD; if( i=='o' || i=='O')dp[7]=(dp[7]+dp[6])%MOD; if( i=='u' || i=='U')dp[8]=(dp[8]+dp[7])%MOD; } cout&lt;&lt;dp[8]&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线性DP","slug":"线性DP","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7DP/"}]},{"title":"洛谷 - P1908 逆序对（树状数组 + 离散化）","slug":"luogu1908","date":"2020-02-28T14:33:54.000Z","updated":"2020-07-13T10:50:56.798Z","comments":true,"path":"2020/02/28/luogu1908/","link":"","permalink":"http://yoursite.com/2020/02/28/luogu1908/","excerpt":"","text":"传送门：洛谷 - P1908 题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。 输入描述第一行，一个数n，表示序列中有n个数。 输出描述第二行n个数，表示给定的序列。序列中每个数字不超过$10^9$ 思路分析逆序对也就是一个数前面有数比他大的，可以通过树桩数组求，从头开始，每次使a[i]位置的值+1，再求1~a[i]之间的和sum，i-sum就是这个数的逆序对个数，最后总和就是ans。 样例输入6 5 4 2 6 3 1样例输出11AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define rson ro&lt;&lt;1|1,mid+1,r #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; const int N=5e5+10; int n; int b[N],a[N],bit[N]; void prepare() { for(int i=1;i&lt;=n;i++) b[i]=a[i]; sort(b+1,b+n+1); int m=unique(b+1,b+n+1)-b-1; for(int i=1;i&lt;=n;i++){ a[i]=lower_bound(b+1,b+m+1,a[i])-b; } } void add(int x,int v){ for(int i=x;i&lt;=n;i+=lowbit(i)) bit[i]+=v; } int getsum(int x){ int s=0; for(int i=x;i>=1;i-=lowbit(i)) s+=bit[i]; return s; } int main() { IOS; cin>>n; for(int i=1;i&lt;=n;i++)cin>>a[i]; prepare(); ll ans=0; for(int i=1;i&lt;=n;i++){ add(a[i],1); ans+=i-getsum(a[i]); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}]},{"title":"CodeForces1263E - Editor","slug":"CF1263E","date":"2020-02-28T14:29:01.000Z","updated":"2020-02-28T14:33:07.879Z","comments":true,"path":"2020/02/28/CF1263E/","link":"","permalink":"http://yoursite.com/2020/02/28/CF1263E/","excerpt":"","text":"传送门：CodeForces - 1263E 题目描述The development of a text editor is a hard problem. You need to implement an extra module for brackets coloring in text. Your editor consists of a line with infinite length and cursor, which points to the current character. Please note that it points to only one of the characters (and not between a pair of characters). Thus, it points to an index character. The user can move the cursor left or right one position. If the cursor is already at the first (leftmost) position, then it does not move left. Initially, the cursor is in the first (leftmost) character. Also, the user can write a letter or brackets (either (, or )) to the position that the cursor is currently pointing at. A new character always overwrites the old value at that position. Your editor must check, whether the current line is the correct text. Text is correct if the brackets in them form the correct bracket sequence. Frmally, correct text (CT) must satisfy the following rules: any line without brackets is CT (the line can contain whitespaces); If the first character of the string — is (, the last — is ), and all the rest form a CT, then the whole line is a CT; two consecutively written CT is also CT. Examples of correct texts: hello(codeforces), round, ((i)(write))edi(tor)s, ( me). Examples of incorrect texts: hello)oops(, round), ((me). The user uses special commands to work with your editor. Each command has its symbol, which must be written to execute this command. The correspondence of commands and characters is as follows: L — move the cursor one character to the left (remains in place if it already points to the first character); R — move the cursor one character to the right; any lowercase Latin letter or bracket (( or )) — write the entered character to the position where the cursor is now. For a complete understanding, take a look at the first example and its illustrations in the note below. You are given a string containing the characters that the user entered. For the brackets coloring module’s work, after each command you need to: check if the current text in the editor is a correct text; if it is, print the least number of colors that required, to color all brackets. If two pairs of brackets are nested (the first in the second or vice versa), then these pairs of brackets should be painted in different colors. If two pairs of brackets are not nested, then they can be painted in different or the same colors. For example, for the bracket sequence ()(())()() the least number of colors is 2, and for the bracket sequence (()(()())())(()) — is 3. Write a program that prints the minimal number of colors after processing each command. 输入描述The first line contains an integer n $(1≤n≤10^6)$ — the number of commands. The second line contains $s$ — a sequence of commands. The string $s$ consists of $n$ characters. It is guaranteed that all characters in a string are valid commands. 输出描述In a single line print n integers, where the i-th number is: −1 if the line received after processing the first i commands is not valid text, the minimal number of colors in the case of the correct text. 思路分析有三种操作，L表示指针左移，R表示指针右移，其余将当前位置字符改变。每次操作之后，输出合法括号序列的最大层数，如果没有输入-1。设（权值为1，）权值为-1，用线段树维护区间最小值最大值，统计左右括号数量，如果数量匹配并且区间最小值为0，说明区间最大值为最大的匹配层数 样例输入11 (RaRbR)L)L(样例输出-1 -1 -1 -1 -1 -1 1 1 -1 -1 2 AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define ls ro&lt;&lt;1 #define fi first #define se second #define rs ro&lt;&lt;1|1 #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define lson ro&lt;&lt;1,l,mid #define rson ro&lt;&lt;1|1,mid+1,r #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; const int N=1e6+10; struct T { int mi,ma,l,r,lazy; } tree[N&lt;&lt;2]; void build(int ro,int l,int r) { tree[ro].l=l; tree[ro].r=r; tree[ro].mi=tree[ro].ma=0; tree[ro].lazy=0; if(l==r) { return ; } else { int mid=(l+r)>>1; build(lson); build(rson); } } void pushup(int ro) { if(tree[ro].l==tree[ro].r) return ; tree[ro].ma=max(tree[ls].ma,tree[rs].ma); tree[ro].mi=min(tree[ls].mi,tree[rs].mi); } void pushdown(int ro) { if(tree[ro].l==tree[ro].r) return ; if(tree[ro].lazy==0) return ; int lazy=tree[ro].lazy; tree[ro].lazy=0; tree[ls].ma+=lazy; tree[rs].ma+=lazy; tree[ls].mi+=lazy; tree[rs].mi+=lazy; tree[ls].lazy+=lazy; tree[rs].lazy+=lazy; } void update(int ro,int l,int r,int v) { if(l&lt;=tree[ro].l &amp;&amp; tree[ro].r&lt;=r) { tree[ro].lazy+=v; tree[ro].ma+=v; tree[ro].mi+=v; } else { pushdown(ro); int mid=(tree[ro].l+tree[ro].r)>>1; if(l&lt;=mid) update(ls,l,r,v); if(mid+1&lt;=r) update(rs,l,r,v); pushup(ro); } } int str[N]; char s[N]; int main() { int n; scanf(\"%d%s\",&amp;n,s); build(1,1,n); int cur=1,cnt=0; for(int i=0; i&lt;n; i++) { if(s[i]=='L') cur=max(1,cur-1); if(s[i]=='R') ++cur; if (('a' &lt;= s[i] &amp;&amp; s[i] &lt;= 'z') || s[i] == '(' || s[i] == ')') { if (str[cur] != 0) update(1, cur, n, -str[cur]); cnt -= str[cur]; str[cur] = 0; } if (s[i] == '(') update(1, cur, n, str[cur] = 1), ++cnt; if (s[i] == ')') update(1, cur, n, str[cur] = -1), --cnt; if (tree[1].mi == 0 &amp;&amp; cnt == 0) { printf(\"%d \", tree[1].ma); } else printf(\"-1 \"); } puts(\"\"); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"author":"小凡"},{"title":"CodeForces1288D - Minimax Problem（二分 + 状压）","slug":"CF1288D","date":"2020-02-28T14:26:59.000Z","updated":"2020-02-28T14:28:33.857Z","comments":true,"path":"2020/02/28/CF1288D/","link":"","permalink":"http://yoursite.com/2020/02/28/CF1288D/","excerpt":"","text":"传送门：CodeForces - 1288D 题目描述You are given n arrays $a_1, a_2, …, a_n$; each array consists of exactly m integers. We denote the y-th element of the x-th array as $a_{x,y}$. You have to choose two arrays $a_i and a_j $(1≤i,j≤n, it is possible that i=j). After that, you will obtain a new array b consisting of m integers, such that for every $k$ $\\in [1,m] b_k=max(a_{i,k},a_{j,k}$) Your goal is to choose i and j so that the value of $min(b_1,b_2,…,b_m)$ is maximum possible. 输入描述The first line contains two integers n and m $(1≤n≤3⋅10^5, 1≤m≤8)$ — the number of arrays and the number of elements in each array, respectively. Then n lines follow, the x-th line contains the array ax represented by $m$ integers $a_{x,1}, a_{x,2}, …, a_{x,m} (0≤a_{x,y}≤10^9).$ 输出描述Print two integers i and j (1≤i,j≤n, it is possible that i=j) — the indices of the two arrays you have to choose so that the value of $min(b_1,b_2,…,b_m)$ is maximum possible. If there are multiple answers, print any of them. 思路分析有n个长度为m的数组，每次选择两个数组，可以是相同的，然后对于每一个下标取最大值，得到一个新数组，求新数组的最小值的最大值。最小值最大问题，首先考虑二分答案，由于长度最多只有8，可以进行状态压缩。对于check，每次的mid，对每个数组的每一位进行判断，如果&gt;=mid，则该位为1，最后得到一个二进制数，将每个二进制状态的数组标记，最后只需要暴力枚举两个状态 $i|j==(1&lt;&lt;m)-1$就可以 样例输入6 5 5 0 3 1 2 1 8 9 1 3 1 2 3 4 5 9 1 0 3 7 2 3 0 6 3 6 4 1 7 0样例输出1 5 AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define lowbit(x) x&amp;(-x) #define pii pair&lt;int,int> #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; const int N=3e5+10; int a[N][9],vis[1&lt;&lt;8]; int n,m,ax,ay; int check(int mid){ mem(vis,0); for(int i=1;i&lt;=n;i++){ int s=0; for(int j=1;j&lt;=m;j++){ if(a[i][j]>=mid){ s+=(1&lt;&lt;(j-1)); } } vis[s]=i; } for(int i=0;i&lt;(1&lt;&lt;m);i++){ for(int j=0;j&lt;(1&lt;&lt;m);j++){ if(vis[i]&amp;&amp;vis[j]&amp;&amp;(i|j)==(1&lt;&lt;m)-1){ ax=vis[i]; ay=vis[j]; return 1; } } } return 0; } int main() { IOS; int ma=-INF; cin>>n>>m; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ cin>>a[i][j]; ma=max(ma,a[i][j]); } } int l=0,r=ma; while(r>=l){ int mid=(l+r)/2; if(check(mid)){ l=mid+1; }else{ r=mid-1; } } cout&lt;&lt;ax&lt;&lt;\" \"&lt;&lt;ay&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"}],"author":"小凡"},{"title":"洛谷 - P1879 [USACO06NOV]玉米田Corn Fields（状压DP）","slug":"luogu1879","date":"2020-02-28T14:25:07.000Z","updated":"2020-02-28T14:26:35.632Z","comments":true,"path":"2020/02/28/luogu1879/","link":"","permalink":"http://yoursite.com/2020/02/28/luogu1879/","excerpt":"","text":"传送门： 题目描述农场主John新买了一块长方形的新牧场，这块牧场被划分成M行N列(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)，每一格都是一块正方形的土地。John打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。 遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是John不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。 John想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案） 输入描述第一行：两个整数M和N，用空格隔开。 第2到第M+1行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。 输出描述一个整数，即牧场分配总方案数除以100,000,000的余数。 思路分析很经典的状压dp，具体细节写在代码注释里面。 样例输入2 3 1 1 1 0 1 0样例输出9 AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define pii pair&lt;int,int> #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; const ll mod=100000000; ll dp[13][1&lt;&lt;13]; int a[13][13],f[13]; bool ok[1&lt;&lt;13]; int main() { IOS; int n,m; cin>>n>>m; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ cin>>a[i][j]; f[i]=(f[i]&lt;&lt;1)+a[i][j]; //每一行的初始状态 } } int cnt=0; for(int i=0;i&lt;(1&lt;&lt;m);i++){ if(((i&lt;&lt;1)&amp;i)==0){ ok[i]=true; if((i&amp;f[1])==i) //判断这种状态是否满足（不相邻并且是肥沃的土地） dp[1][i]=1; } } for(int i=2;i&lt;=n;i++){ for(int j=0;j&lt;(1&lt;&lt;m);j++){ if(ok[j]&amp;&amp;(j&amp;f[i-1])==j){ for(int k=0;k&lt;(1&lt;&lt;m);k++){ if(ok[k] &amp;&amp; (k&amp;j)==0 &amp;&amp; (k&amp;f[i])==k) dp[i][k]=(dp[i][k]+dp[i-1][j]+mod)%mod; } } } } ll ans=0; for(int i=0;i&lt;(1&lt;&lt;m);i++) ans=(ans+dp[n][i]+mod)%mod; cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"状压DP","slug":"状压DP","permalink":"http://yoursite.com/tags/%E7%8A%B6%E5%8E%8BDP/"}],"author":"小凡"},{"title":"BZOJ - 1087 [SCOI2005]互不侵犯King（状压DP）","slug":"BZOJ1087","date":"2020-02-28T14:22:26.000Z","updated":"2020-02-28T14:24:05.091Z","comments":true,"path":"2020/02/28/BZOJ1087/","link":"","permalink":"http://yoursite.com/2020/02/28/BZOJ1087/","excerpt":"","text":"传送门：BZOJ - 1087 题目描述在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上，左下，右上，右下，八个方向上附近的各一个格子，共8个格子。 输入描述只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N） 输出描述方案数。 思路分析一道很经典的状压DP，我也是看了半天题解才懂的。 需要用到三个数组： dp[i][j][k]表示第i层状态为j所用棋子总数为k的方案数 ok[i]表示第i种状态是否合法 num[i]表示第i种状态需要多少个棋子 状压dp的关键就是各种状态的表示以及位运算 样例输入3 2样例输出16 AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define pii pair&lt;int,int> #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; const int N=10; ll dp[N][1&lt;&lt;N][N*N],num[1&lt;&lt;N]; bool ok[1&lt;&lt;N]; int main() { IOS; int n,k; cin>>n>>k; ll sum=1&lt;&lt;n; for(int i=0; i&lt;sum; i++) { //判断每种状态所需要的棋子个数 int pos=i; while(pos) { if(pos&amp;1)num[i]++; pos>>=1; } } for(int i=0; i&lt;sum; i++) { if(((i&lt;&lt;1)&amp;i)==0) //判断每种状态是否合法，相邻 ok[i]=true; } for(int i=0; i&lt;sum; i++) { if(ok[i]&amp;&amp;num[i]&lt;=k) dp[1][i][num[i]]=1; //初始化第一排的dp数组 } for(int i=2; i&lt;=n; i++) { for(int j=0; j&lt;sum; j++) { if(ok[j]) { for(int s=0; s&lt;sum; s++) { if(j&amp;s)continue; //判断两种状态是否合法 if((j&lt;&lt;1)&amp;s)continue; if((j>>1)&amp;s)continue; for(int t=k; t>=num[j]; t--) dp[i][j][t]+=dp[i-1][s][t-num[j]]; } } } } ll ans=0; for(int i=0; i&lt;sum; i++) ans+=dp[n][i][k]; cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"状压DP","slug":"状压DP","permalink":"http://yoursite.com/tags/%E7%8A%B6%E5%8E%8BDP/"}],"author":"小凡"},{"title":"POJ - 2955 Brackets （区间DP）","slug":"POJ2955","date":"2020-02-28T14:19:30.000Z","updated":"2020-02-28T14:21:11.614Z","comments":true,"path":"2020/02/28/POJ2955/","link":"","permalink":"http://yoursite.com/2020/02/28/POJ2955/","excerpt":"","text":"传送门：POJ - 2955 思路分析定义dp数组dp[i][j]为区间i-j之间的最大匹配数量，如果第i个括号和第j个括号匹配的话，很容易想到状态转移方程为dp[i][j]=dp[i+1][j-1]+2,然后再枚举i到j之间的括号k，更新最大值为，dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j])。 样例输入((())) ()()() ([]]) )[)( ([][][) end样例输出6 6 4 0 6 AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define fi first #define se second #define ll long long #define pii pair&lt;int,int> #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; int dp[1111][1111]; string s; int judge(int l,int r){ if((s[l]=='['&amp;&amp;s[r]==']')||(s[l]=='('&amp;&amp;s[r]==')')) return 1; else return 0; } int main() { IOS; while(cin>>s){ if(s==\"end\") break; int n=s.size(); memset(dp,0,sizeof dp); for(int i=1;i&lt;n;i++){ for(int l=0,r=l+i;r&lt;n;l++,r++){ if(judge(l,r)) dp[l][r]=dp[l+1][r-1]+2; for(int k=l;k&lt;r;k++) dp[l][r]=max(dp[l][r],dp[l][k]+dp[k+1][r]); } } cout&lt;&lt;dp[0][n-1]&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"区间DP","slug":"区间DP","permalink":"http://yoursite.com/tags/%E5%8C%BA%E9%97%B4DP/"}],"author":"小凡"},{"title":"HDU - 1195 Open the Lock","slug":"HDU1195","date":"2020-02-28T14:14:23.000Z","updated":"2020-03-18T11:08:04.266Z","comments":true,"path":"2020/02/28/HDU1195/","link":"","permalink":"http://yoursite.com/2020/02/28/HDU1195/","excerpt":"","text":"传送门：HDU - 1195 题目描述Now an emergent task for you is to open a password lock. The password is consisted of four digits. Each digit is numbered from 1 to 9.Each time, you can add or minus 1 to any digit. When add 1 to ‘9’, the digit will change to be ‘1’ and when minus 1 to ‘1’, the digit wil change to be ‘9’. You can also exchange the digit with its neighbor. Each action will take one step. Now your task is to use minimal steps to open the lock. Note: The leftmost digit is not the neighbor of the rightmost digit. 输入描述The input file begins with an integer T, indicating the number of test cases. Each test case begins with a four digit N, indicating the initial state of the password lock. Then followed a line with anotther four dight M, indicating the password which can open the lock. There is one blank line after each test case. 输出描述For each test case, print the minimal steps in one line. 思路分析将一个数通过一系列操作变成另一个数，对于每一位可以有四种操作，+1，-1，或者交换相邻，直接bfs。 样例输入2 1234 2144 1111 9999样例输出2 4 AC代码 #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> #include &lt;unordered_map> using namespace std; #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define pii pair&lt;int,int> #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; inline int read () { register int s = 0, w = 1; register char ch = getchar (); while (! isdigit (ch)) {if (ch == '-') w = -1; ch = getchar ();} while (isdigit (ch)) {s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + (ch ^ 48); ch = getchar ();} return s * w; } string s,x; int len,ans; struct node{ string s; int d; }; unordered_map&lt;string,int> ma; int cnt=0; void bfs(){ queue&lt;node>q; node a; a.s=x; a.d=0; q.push(a); while(!q.empty()){ node next; node now=q.front(); q.pop(); if(now.s==s){ ans=now.d; break; } for(int i=0;i&lt;len;i++){ string x; x=now.s; if(s[i]==x[i]) continue; if(x[i]=='9'){ x[i]='1'; next.s=x; next.d=now.d+1; if(!ma[x]){ ma[x]++; q.push(next); } x[i]='8'; next.s=x; next.d=now.d+1; if(!ma[x]){ ma[x]++; q.push(next); } }else if(x[i]=='1'){ x[i]='9'; next.s=x; next.d=now.d+1; if(!ma[x]){ ma[x]++; q.push(next); } x[i]='2'; next.s=x; next.d=now.d+1; if(!ma[x]){ ma[x]++; q.push(next); } }else{ x=now.s; x[i]++; next.s=x; next.d=now.d+1; if(!ma[x]){ ma[x]++; q.push(next); } x=now.s; x[i]--; next.s=x; next.d=now.d+1; if(!ma[x]){ ma[x]++; q.push(next); } } if(i!=len-1){ x=now.s; swap(x[i],x[i+1]); next.s=x; next.d=now.d+1; if(!ma[x]){ ma[x]++; q.push(next); } } if(i!=0){ x=now.s; swap(x[i],x[i-1]); next.s=x; next.d=now.d+1; if(!ma[x]){ ma[x]++; q.push(next); } } } } return ; } int main() { int t; t=read(); while(t--){ ans=0; ma.clear(); cin>>s>>x; ma[x]++; len=s.size(); bfs(); printf(\"%d\\n\",ans); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"http://yoursite.com/tags/BFS/"}],"author":"小凡"},{"title":"CodeForces1136D - Nastya Is Buying Lunch","slug":"CF1136D","date":"2020-02-28T14:11:39.000Z","updated":"2020-02-28T14:18:28.911Z","comments":true,"path":"2020/02/28/CF1136D/","link":"","permalink":"http://yoursite.com/2020/02/28/CF1136D/","excerpt":"","text":"传送门：CodeForces - 1136D 题目描述At the big break Nastya came to the school dining room. There are n pupils in the school, numbered from 1 to n. Unfortunately, Nastya came pretty late, so that all pupils had already stood in the queue, i.e. Nastya took the last place in the queue. Of course, it’s a little bit sad for Nastya, but she is not going to despond because some pupils in the queue can agree to change places with some other pupils. Formally, there are some pairs u, v such that if the pupil with number u stands directly in front of the pupil with number v, Nastya can ask them and they will change places. Nastya asks you to find the maximal number of places in queue she can move forward. 输入描述The first line contains two integers n and m $(1≤n≤3⋅10^5, 0≤m≤5⋅10^5)$ — the number of pupils in the queue and number of pairs of pupils such that the first one agrees to change places with the second one if the first is directly in front of the second. The second line contains n integers$ p_1, p_2, …, p_n$ — the initial arrangement of pupils in the queue, from the queue start to its end (1≤$p_i$≤n, p is a permutation of integers from 1 to n). In other words, pi is the number of the pupil who stands on the i-th position in the queue. The i-th of the following m lines contains two integers ui, vi $(1≤u_i,v_i≤n,u_i≠v_i)$, denoting that the pupil with number ui agrees to change places with the pupil with number vi if $u_i$ is directly in front of $v_i$. It is guaranteed that if i≠j, than $v_i≠v_j $or $u_i≠u_j$. Note that it is possible that in some pairs both pupils agree to change places with each other. Nastya is the last person in the queue, i.e. the pupil with number $p_n$. 输出描述Print a single integer — the number of places in queue she can move forward. 思路分析题意大概是，$n$个人排成一排，只有相邻的两个人可以换位，现在给你$m$个信息$u$和$v$，如果$u$刚好在$v$前面且相邻，那么可以换位置，现在问你最后一个人最多能够向前移动多少个位置，从后面往前遍历，如果当前这个人距离小明（最开始最后面的那个）的距离为$x$，如果他后面的可以和他交换的人数也为$x$，那么小明可以往前一步。 样例输入3 3 3 1 2 1 2 3 1 3 2样例输出2 AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define pii pair&lt;int,int> #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; const int N=1e6; int a[N],num[N]; vi q[N]; int main(){ int n,m; cin>>n>>m; for(int i=0;i&lt;n;i++)cin>>a[i]; for(int i=0;i&lt;m;i++){ int x,y; cin>>x>>y; q[y].pb(x); } for(auto i:q[a[n-1]])num[i]++; int ans=n-1; for(int i=n-2;i>=0;i--){ if(i+num[a[i]]==ans)ans--; else{ for(auto it:q[a[i]]){ num[it]++; } } } cout&lt;&lt;n-1-ans&lt;&lt;endl; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"}],"author":"小凡"},{"title":"HDU - 2089 不要62（数位DP）","slug":"HDU2089","date":"2020-02-28T14:09:00.000Z","updated":"2020-03-02T07:44:49.184Z","comments":true,"path":"2020/02/28/HDU2089/","link":"","permalink":"http://yoursite.com/2020/02/28/HDU2089/","excerpt":"","text":"传送门：HDU - 2089 题目描述杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。不吉利的数字为所有含有4或62的号码。例如：62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 输入描述输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。 输出描述对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 思路分析这是一道经典的数位DP，这道题比较难想的是limit（也许只是我觉得难想），理解之后呢就很简单了，就是判断上界的问题，比如2234，在搜索第二位的时候如果第一位是1，那么第二位最多到2，如果第一位小于2的话，那么第二位就可以到9，这就是limit的作用。 样例输入1 100 0 0样例输出80 AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define pii pair&lt;int,int> #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; int dig[22]; int dp[22][2]; int dfs(int len ,bool if6,bool limit) { if(len==0) return 1; if(!limit &amp;&amp; dp[len][if6]) return dp[len][if6]; int ans=0; int ma=limit?dig[len]:9; for(int i=0; i&lt;=ma; i++) { if((if6 &amp;&amp; i==2) || i==4) continue; ans+=dfs(len-1,i==6,limit &amp;&amp; i==dig[len]); } if(!limit) dp[len][if6]=ans; return ans; } int solve(int x) { int len=0; while(x) { dig[++len]=x%10; x/=10; } return dfs(len,false,true); } int main() { IOS; int x,y; while(cin>>x>>y&amp;&amp;x+y) { cout&lt;&lt;solve(y)-solve(x-1)&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数位DP","slug":"数位DP","permalink":"http://yoursite.com/tags/%E6%95%B0%E4%BD%8DDP/"}],"author":"小凡"},{"title":"NBUT - 1580 调皮的小明（完全背包）","slug":"NBUT1580","date":"2020-02-27T09:30:21.000Z","updated":"2020-02-28T14:04:35.894Z","comments":true,"path":"2020/02/27/NBUT1580/","link":"","permalink":"http://yoursite.com/2020/02/27/NBUT1580/","excerpt":"","text":"传送门：NBUT - 1580 题目描述小明是个数学炒鸡棒的小学生， 精通200以内的加法，老师看不下去了，让小明去自学素数，这不，第二天，小明就回到学校，跟全班同学说他有一个问题，把一个数分成一个或多个素数的和，有多少种情况。9 = 2 + 2 + 2 + 39 = 2 + 79 = 2 + 2 + 59 = 3 + 3 + 3所以有4种。老师瞬间呆住了，这小明是吃错药了么。。。不过老师还是希望帮小明解决这个题目。请问你能帮助老师吗？答不出来，老师可是要叫家长咯…… 输入描述多组数据，每组数据输入一个N。2&lt;= N &lt;= 200 输出描述输出分解的种类数. 思路分析把题意转化一下，就变成了一个完全背包求方案数的问题，对于N，就是重量为N的背包，物品为小于等于N的所有素数，每个物品可以用无限次，问装满有多少种装法 样例输入8 9样例输出3 4 AC代码 #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define pii pair&lt;int,int> #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; const int N=1e7+5; bool ok[N]; int prim[N]; int pos=0; void p(int n) { memset(ok,true,sizeof(ok)); ok[0]=ok[1]=false; for(int i=2;i&lt;=n;i++) { if(ok[i]) { prim[pos++]=i; for(int j=i*i;j&lt;=n;j+=i) { ok[j]=false; } } } } int dp[222]; int main() { p(201); int n; dp[0]=1; for(int i=0;i&lt;46;i++){ for(int j=prim[i];j&lt;=200;j++){ dp[j]+=dp[j-prim[i]]; } } while(cin>>n){ cout&lt;&lt;dp[n]&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"背包DP","slug":"背包DP","permalink":"http://yoursite.com/tags/%E8%83%8C%E5%8C%85DP/"}],"author":"小凡"},{"title":"POJ - 3107 Godfather （树的重心）","slug":"POJ3107","date":"2020-02-27T09:26:02.000Z","updated":"2020-02-28T14:05:02.404Z","comments":true,"path":"2020/02/27/POJ3107/","link":"","permalink":"http://yoursite.com/2020/02/27/POJ3107/","excerpt":"","text":"传送门：POJ - 3107 题目描述Last years Chicago was full of gangster fights and strange murders. The chief of the police got really tired of all these crimes, and decided to arrest the mafia leaders. Unfortunately, the structure of Chicago mafia is rather complicated. There are n persons known to be related to mafia. The police have traced their activity for some time, and know that some of them are communicating with each other. Based on the data collected, the chief of the police suggests that the mafia hierarchy can be represented as a tree. The head of the mafia, Godfather, is the root of the tree, and if some person is represented by a node in the tree, its direct subordinates are represented by the children of that node. For the purpose of conspiracy the gangsters only communicate with their direct subordinates and their direct master. Unfortunately, though the police know gangsters’ communications, they do not know who is a master in any pair of communicating persons. Thus they only have an undirected tree of communications, and do not know who Godfather is. Based on the idea that Godfather wants to have the most possible control over mafia, the chief of the police has made a suggestion that Godfather is such a person that after deleting it from the communications tree the size of the largest remaining connected component is as small as possible. Help the police to find all potential Godfathers and they will arrest them. 输入描述The first line of the input file contains n — the number of persons suspected to belong to mafia $(2 ≤ n ≤ 50 000)$. Let them be numbered from 1 to n. The following n − 1 lines contain two integer numbers each. The pair ai, bi means that the gangster ai has communicated with the gangster bi. It is guaranteed that the gangsters’ communications form a tree. 输出描述Print the numbers of all persons that are suspected to be Godfather. The numbers must be printed in the increasing order, separated by spaces. 思路分析实际上就是求一棵无根树的重心 树的重心也叫树的质心，找到一个点，其所有子树中最大的子树节点数量最少。 样例输入6 1 2 2 3 2 5 3 4 3 6样例输出2 3 AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define pii pair&lt;int,int> #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; const int N=50010; struct edge{ int v,next; }e[N&lt;&lt;1]; int head[N],tot[N],dp[N],cnt; void add(int u,int v){ e[++cnt].v=v; e[cnt].next=head[u]; head[u]=cnt; } void dfs(int u,int fa){ tot[u]=1; for(int i=head[u];i;i=e[i].next){ int v=e[i].v; if(v==fa) continue; dfs(v,u); dp[u]=max(dp[u],tot[v]); tot[u]+=tot[v]; } } void init(){ mem(head,0); mem(dp,0); cnt=0; } int main() { int n; while(~scanf(\"%d\",&amp;n)){ init(); for(int i=0;i&lt;n-1;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); add(x,y); add(y,x); } dfs(1,0); int mi=INF; for(int i=1;i&lt;=n;i++){ dp[i]=max(dp[i],n-tot[i]); mi=min(dp[i],mi); } for(int i=1;i&lt;=n;i++){ if(dp[i]==mi) printf(\"%d \",i); } puts(\"\"); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"小凡"},{"title":"CodeForces1285D - Dr. Evil Underscores","slug":"CF1285D","date":"2020-02-27T09:22:47.000Z","updated":"2020-02-28T14:05:58.228Z","comments":true,"path":"2020/02/27/CF1285D/","link":"","permalink":"http://yoursite.com/2020/02/27/CF1285D/","excerpt":"","text":"传送门：CodeForces - 1285D 题目描述Today, as a friendship gift, Bakry gave Badawy n integers $a_1,a_2,…,a_n$ and challenged him to choose an integer $X$ such that the value Max{a_1⊕X,a_2⊕X,…a_n⊕X} is minimum possible As always, Badawy is too lazy, so you decided to help him and find the minimum possible value of Max{$a_1⊕X,a_2⊕X,…a_n⊕X$} 输入描述The first line contains integer n $(1≤n≤10^5)$. The second line contains n integers a1,a2,…,an $(0≤a_i≤2^{30−1})$. 输出描述Print one integer — the minimum possible value of Max{$a_1⊕X,a_2⊕X,…a_n⊕X$} 思路分析有n个数，寻找一个$X$使得Max{$a_1⊕X,a_2⊕X,…a_n⊕X$}最小，并输出。这道题可以通过贪心来取最小值，对于第$i$位，如果该位只有1或0，那么Ans的这一位取0，如果0和1都存在，那么这一位肯定取1。所以我们可以建出Trie树，从树的最高位开始贪心，如果有0有1则对两个子树取Min并加上$2^i$，否则直接对子树进行操作。 样例输入3 1 2 3 样例输出2 AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define pii pair&lt;int,int> #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; int dfs(vi a,int dep){ if(a.size()==0||dep&lt;0) return 0; vi q1,q2; for(auto i:a){ if((i>>dep)&amp;1) q1.pb(i); else q2.pb(i); } if(q1.size()==0) return dfs(q2,dep-1); if(q2.size()==0) return dfs(q1,dep-1); return min(dfs(q1,dep-1),dfs(q2,dep-1))+(1&lt;&lt;dep); } int main() { IOS; vi a; int n; cin>>n; for(int i=0;i&lt;n;i++){ int x; cin>>x; a.pb(x); } cout&lt;&lt;dfs(a,30)&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"分治","slug":"分治","permalink":"http://yoursite.com/tags/%E5%88%86%E6%B2%BB/"}],"author":"小凡"},{"title":"CodeForces-148D Bag of mice（概率DP）","slug":"CF148D","date":"2020-02-27T09:15:39.000Z","updated":"2020-02-28T14:05:54.832Z","comments":true,"path":"2020/02/27/CF148D/","link":"","permalink":"http://yoursite.com/2020/02/27/CF148D/","excerpt":"","text":"传送门：CodeForces - 148D 题目描述The dragon and the princess are arguing about what to do on the New Year’s Eve. The dragon suggests flying to the mountains to watch fairies dancing in the moonlight, while the princess thinks they should just go to bed early. They are desperate to come to an amicable agreement, so they decide to leave this up to chance. They take turns drawing a mouse from a bag which initially contains w white and b black mice. The person who is the first to draw a white mouse wins. After each mouse drawn by the dragon the rest of mice in the bag panic, and one of them jumps out of the bag itself (the princess draws her mice carefully and doesn’t scare other mice). Princess draws first. What is the probability of the princess winning? If there are no more mice in the bag and nobody has drawn a white mouse, the dragon wins. Mice which jump out of the bag themselves are not considered to be drawn (do not define the winner). Once a mouse has left the bag, it never returns to it. Every mouse is drawn from the bag with the same probability as every other one, and every mouse jumps out of the bag with the same probability as every other one. 输入描述The only line of input data contains two integers $w$ and $b$ $(0 ≤ w, b ≤ 1000)$. 输出描述Output the probability of the princess winning. The answer is considered to be correct if its absolute or relative error does not exceed $10^{-9}$. 思路分析 有w个白耗子，b个黑耗子，公主和龙一起抓耗子，谁先抓到白耗子，谁就赢 龙抓一次耗子，会吓跑一只耗子（这只耗子不算谁赢），而公主不会 我们可以定义一个dp数组，dp[i][j]表示有i只白耗子和j只黒耗子的时候公主赢的概率，每一轮的顺序是公主先抓，龙抓，耗子跑。我们只需要推出公主有赢的可能的状态，那么有三种。 公主抓到白耗子：dp[i][j]+= i / ( i + j ) 公主抓到黒耗子，龙抓到黒耗子，黒耗子跑了：dp[i][j] = ( j / (i + j) ) * ( (j - 1) / (i + j - 1) * (j - 2) / (i + j - 2) ) * dp[i][j - 3] 公主抓到黒耗子，龙抓到黒耗子，白耗子跑了：dp[i][j] = ( j / (i + j) ) * ( (j - 1) / (i + j - 1) * i / (i + j - 2) ) * dp[i - 1][j - 2] 记得初始化数组，dp[i][0]=1 样例输入1 3样例输出0.500000000 AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define fi first #define se second #define ll long long #define pb push_back #define vi vector&lt;int> #define pii pair&lt;int,int> #define mem(a,b) memset(a,b,sizeof(a)) #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; const int N=1010; double dp[N][N]; int main() { int a,b; cin>>a>>b; for(int i=1;i&lt;=a;i++) dp[i][0]=1; for(int i=1;i&lt;=a;i++){ for(int j=1;j&lt;=b;j++){ dp[i][j] += (double) i / (i + j); if(j >= 2) dp[i][j] += (double) j / (i + j) * (double) (j - 1) / (i + j - 1) * (double) i / (i + j - 2) * dp[i - 1][j - 2]; if(j >= 3) dp[i][j] += (double) j / (i + j) * (double) (j - 1) / (i + j - 1) * (double) (j - 2) / (i + j - 2) * dp[i][j - 3]; } } printf(\"%.9lf\\n\",dp[a][b]); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"概率DP","slug":"概率DP","permalink":"http://yoursite.com/tags/%E6%A6%82%E7%8E%87DP/"}],"author":"小凡"},{"title":"CodeForces-1279D Santa's Bot（逆元）","slug":"CF1279D","date":"2020-02-27T09:07:18.000Z","updated":"2020-03-03T12:00:30.284Z","comments":true,"path":"2020/02/27/CF1279D/","link":"","permalink":"http://yoursite.com/2020/02/27/CF1279D/","excerpt":"","text":"传送门：CodeForces - 1279D 题目描述Santa Claus has received letters from n different kids throughout this year. Of course, each kid wants to get some presents from Santa: in particular, the i-th kid asked Santa to give them one of ki different items as a present. Some items could have been asked by multiple kids. Santa is really busy, so he wants the New Year Bot to choose the presents for all children. Unfortunately, the Bot’s algorithm of choosing presents is bugged. To choose a present for some kid, the Bot does the following: choose one kid x equiprobably among all n kids; choose some item y equiprobably among all kx items kid x wants; choose a kid z who will receive the present equipropably among all n kids （this choice is independent of choosing x and y）; the resulting triple (x,y,z) is called the decision of the Bot. If kid z listed item y as an item they want to receive, then the decision valid. Otherwise, the Bot’s choice is invalid. Santa is aware of the bug, but he can’t estimate if this bug is really severe. To do so, he wants to know the probability that one decision generated according to the aforementioned algorithm is valid. Can you help him? 输入描述The first line contains one integer n $(1≤n≤10^6)$ — the number of kids who wrote their letters to Santa. Then n lines follow, the i-th of them contains $a$ list of items wanted by the i-th kid in the following format: $k_i a_{i,1} a_{i,2} … a_{i,k_i}$ $(1≤k_i,a_i,j≤10^6)$, where $k_i$ is the number of items wanted by the i-th kid, and $a_{i,j} are the items themselves. No item is contained in the same list more than once. It is guaranteed that $\\sum_{i=1}^{n}{k_i}&lt;=10^6$. 输出描述Print the probatility that the Bot produces a valid decision as follows: Let this probability be represented as an irreducible fraction $xy$. You have to print $x⋅y^{-1}$ mod 998244353, where $y^{-1}$ is the inverse element of $y$ modulo 998244353 （such integer that $y⋅y^{-1}$ has remainder 1 mod 998244353）. 思路分析总共有n个人，每一个人喜欢ki种不同的东西,n个人里面抽一个是 $\\frac{1}{n}$从n个人里面抽一个，然后从这个人喜欢的东西里面抽一个,从$k_i$个东西里面抽是$\\frac{1}{k_i}$然后任意在所有人里面抽一个，问这个人喜欢的礼物和之前的那个喜欢的东西重复的概率.最后从n个人里面抽一个的正好重复的概率是$\\frac{想要这个礼物的人数}{n}$ 最后乘起来就是总概率了。 这道题需要用到乘法逆元，具体怎么算可以去看这个网站 OI Wiki 乘法逆元 样例输入2 2 2 1 1 1 样例输出124780545 AC代码 #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define fi first #define se second #define ll long long #define pii pair&lt;int,int> #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int INF = 0x3f3f3f3f; const int mod=998244353; inline int read () { register int s = 0, w = 1; register char ch = getchar (); while (! isdigit (ch)) {if (ch == '-') w = -1; ch = getchar ();} while (isdigit (ch)) {s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + (ch ^ 48); ch = getchar ();} return s * w; } const int N=1e6+10; ll q(ll a,ll b){ ll sum=1; while(b){ if(b&amp;1)sum=sum%mod*a%mod; a=(ll)a*a%mod; b>>=1; } return sum%mod; } ll inv(ll a,ll b){ return (a%mod*q(b,mod-2)%mod)%mod; } ll b[N]; vector&lt;ll>a[N]; int main() { int t; cin>>t; for(int i=0;i&lt;t;i++){ ll n; cin>>n; for(int j=0;j&lt;n;j++){ ll x; cin>>x; a[i].push_back(x); b[x]++; } } ll ans=0; for(int i=0;i&lt;t;i++) for(int j=0;j&lt;a[i].size();j++) ans=ans%mod+(inv(1,t)%mod*inv(1,a[i].size())%mod*inv(b[a[i][j]],t))%mod; cout&lt;&lt;ans%mod&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"}],"author":"小凡"},{"title":"POJ-1679 The Unique MST（次小生成树）","slug":"POJ1679","date":"2020-02-27T09:01:12.000Z","updated":"2020-02-28T14:05:11.772Z","comments":true,"path":"2020/02/27/POJ1679/","link":"","permalink":"http://yoursite.com/2020/02/27/POJ1679/","excerpt":"","text":"传送门：POJ - 1679 题目描述Given a connected undirected graph, tell if its minimum spanning tree is unique. Definition 1 (Spanning Tree): Consider a connected, undirected graph G = (V, E). A spanning tree of G is a subgraph of G, say T = (V’, E’), with the following properties: V’ = V. T is connected and acyclic. Definition 2 (Minimum Spanning Tree): Consider an edge-weighted, connected, undirected graph G = (V, E). The minimum spanning tree T = (V, E’) of G is the spanning tree that has the smallest total cost. The total cost of T means the sum of the weights on all the edges in E’. 输入描述The first line contains a single integer $t$ $(1 &lt;= t &lt;= 20)$, the number of test cases. Each case represents a graph. It begins with a line containing two integers $n$ and $m$ $(1 &lt;= n &lt;= 100)$, the number of nodes and edges. Each of the following m lines contains a triple $(x_i, y_i, w_i)$, indicating that xi and yi are connected by an edge with weight = wi. For any two nodes, there is at most one edge connecting them. 输出描述For each input, if the MST is unique, print the total cost of it, or otherwise print the string ‘Not Unique!’. 思路分析题目的意思是：判断最小生成树是否唯一。思路：先生成一条最小树，记录所使用的边，然后再枚举换掉每一个边能否再生成权值相等的树。 样例输入2 3 3 1 2 1 2 3 2 3 1 3 4 4 1 2 2 2 3 2 3 4 2 4 1 2样例输出3 Not Unique! AC代码 #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define ll long long #define ull unsigned long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int maxn=1e6+10; const ll mod=1e9+7; const int INF = 0x3f3f3f3f; int n,m,f[10000],vis[10000]; struct node{ int x,y,w; }s[10000]; int cmp(node a,node b){ return a.w&lt;b.w; } int find(int x){ if(f[x]==x) return x; else return f[x]=find(f[x]); } void sta(){ for(int i=0;i&lt;=n;i++) f[i]=i; } int main() { int t; cin>>t; while(t--){ cin>>n>>m; sta(); memset(s,0,sizeof(s)); memset(vis,0,sizeof(vis)); for(int i=0;i&lt;m;i++) cin>>s[i].x>>s[i].y>>s[i].w; sort(s,s+m,cmp); int cnt=0,ans=0,k=0; for(int i=0;i&lt;m;i++){ int t1=find(s[i].x); int t2=find(s[i].y); if(t1!=t2){ f[t2]=t1; cnt++; ans+=s[i].w; vis[k++]=i; //记录已经使用的边 } if(cnt==n-1) break; } int flag=0; for(int i=0;i&lt;k;i++){ //枚举去除一条已经使用的边 int num=0,sum=0; sta(); for(int j=0;j&lt;m;j++){ if(j==vis[i]) continue; //去除该已经使用的边 int t1=find(s[j].x); int t2=find(s[j].y); if(t1!=t2){ f[t2]=t1; num++; sum+=s[j].w; } if(num==n-1&amp;&amp;sum==ans){ //有可能生成不了树，但是sum的值可能与ans相同，所以得两个条件同时判断 flag=1; break; } } } if(flag) cout&lt;&lt;\"Not Unique!\"&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}],"author":"小凡"},{"title":"POJ-2421 Constructing Roads","slug":"POJ2421","date":"2020-02-27T08:58:29.000Z","updated":"2020-02-28T14:05:05.659Z","comments":true,"path":"2020/02/27/POJ2421/","link":"","permalink":"http://yoursite.com/2020/02/27/POJ2421/","excerpt":"","text":"传送门：POJ - 2421 题目描述There are N villages, which are numbered from 1 to N, and you should build some roads such that every two villages can connect to each other. We say two village A and B are connected, if and only if there is a road between A and B, or there exists a village C such that there is a road between A and C, and C and B are connected. We know that there are already some roads between some villages and your job is the build some roads such that all the villages are connect and the length of all the roads built is minimum. 输入描述The first line is an integer N (3 &lt;= N &lt;= 100), which is the number of villages. Then come N lines, the i-th of which contains N integers, and the j-th of these N integers is the distance (the distance should be an integer within [1, 1000]) between village i and village j. Then there is an integer Q (0 &lt;= Q &lt;= N * (N + 1) / 2). Then come Q lines, each line contains two integers a and b (1 &lt;= a &lt; b &lt;= N), which means the road between village a and village b has been built. 输出描述You should output a line contains an integer, which is the length of all the roads to be built such that all the villages are connected, and this value is minimum. 思路分析也是村庄连通问题，这题不一样的地方在于：已经有Q条道路已经修好。我们可以通过并查集的连通操作将已经连通的两个村庄标记。 样例输入3 0 990 692 990 0 179 692 179 0 1 1 2样例输出179 AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; #define ll long long #define ull unsigned long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int maxn=1e6+10; const ll mod=1e9+7; const int INF = 0x3f3f3f3f; int f[10000],n; struct node{ int x,y,m; }s[10000]; int cmp(node a,node b){ return a.m&lt;b.m; } int find(int x){ if(f[x]==x) return x; else return f[x]=find(f[x]); } int unite(int a,int b){ int t1,t2; t1=find(a); t2=find(b); if(t1!=t2){ f[t2]=t1; return 1; } return 0; } int main() { IOS; while(cin>>n&amp;&amp;n){ int k=0; for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ int le; cin>>le; if(j>i){ s[++k].x=i; s[k].y=j; s[k].m=le; } } } int cnt=0,ans=0; int t; cin>>t; for(int i=0;i&lt;t;i++){ int a,b; cin>>a>>b; if(unite(a,b)) cnt++; } sort(s+1,s+1+k,cmp); for(int i=1;i&lt;=k;i++){ if(unite(s[i].x,s[i].y)){ cnt++; ans+=s[i].m; } if(cnt==n-1) break; } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}],"author":"小凡"},{"title":"HDU-1875 畅通工程再续","slug":"HDU1875","date":"2020-02-27T08:56:21.000Z","updated":"2020-02-28T14:05:33.048Z","comments":true,"path":"2020/02/27/HDU1875/","link":"","permalink":"http://yoursite.com/2020/02/27/HDU1875/","excerpt":"","text":"传送门：HDU - 1875 题目描述相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元/米。 输入描述输入包括多组数据。输入首先包括一个整数T(T &lt;= 200)，代表有T组数据。每组数据首先是一个整数C(C &lt;= 100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 &lt;= x, y &lt;= 1000的整数。 输出描述每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”. 思路分析思路和上一题差不多，多一步计算任意两点之间的距离，再套用最小生成树模板就行了，这里用的是Kruskal算法 样例输入2 2 10 10 20 20 3 1 1 2 2 1000 1000样例输出1414.2 oh! AC代码#include&lt;bits/stdc++.h> using namespace std; #define ll long long #define ull unsigned long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int maxn=1e6+10; const ll mod=1e9+7; const int INF = 0x3f3f3f3f; int n,k; int f[10000]; struct node{ int a,b; double d; }s[10000]; struct point{ int x,y; }a[10000]; int cmp(node a,node b){ return a.d&lt;b.d; } int find(int x){ if(f[x]==x) return x; else return f[x]=find(f[x]); } int unite(int a,int b){ int t1,t2; t1=find(a); t2=find(b); if(t1!=t2){ f[t2]=t1; return 1; } return 0; } double dis(point a,point b){ return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); } void sta(){ memset(s,0,sizeof(s)); memset(a,0,sizeof(a)); for(int i=0;i&lt;=n;i++) f[i]=i; } void kruskal(){ int cnt=0; double ans=0; for(int i=0;i&lt;k;i++){ if(unite(s[i].a,s[i].b)){ cnt++; ans+=s[i].d; } if(cnt==n-1) break; } if(cnt&lt;n-1) printf(\"oh!\\n\"); else printf(\"%.1lf\\n\",ans*100); } int main() { int t; cin>>t; while(t--){ cin>>n; sta(); for(int i=0;i&lt;n;i++){ cin>>a[i].x>>a[i].y; } k=0; for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ double u; u=dis(a[i],a[j]); if(u&lt;10.0||u>1000.0) continue; s[k].a=i; s[k].b=j; s[k++].d=u; } } sort(s,s+k,cmp); kruskal(); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}],"author":"小凡"},{"title":"HDU-1233 还是畅通工程","slug":"HDU1233","date":"2020-02-27T08:53:16.000Z","updated":"2020-02-28T14:05:43.511Z","comments":true,"path":"2020/02/27/HDU1233/","link":"","permalink":"http://yoursite.com/2020/02/27/HDU1233/","excerpt":"","text":"传送门：HDU - 1233 题目描述某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。 输入描述测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )随后的N*(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。当N为0时，输入结束，该用例不被处理。 输出描述对每个测试用例，在1行里输出最小的公路总长度。 题意分析有n个村庄，那么至少需要n-1条线路，要想长度最短，我们可以贪心，每次尽力选择较短的路线，这就需要对所有边的权值进行从小到大排序，判断两个村庄是否已经连通可以通过并查集来解决。 样例输入3 1 2 1 1 3 2 2 3 4 4 1 2 1 1 3 4 1 4 1 2 3 3 2 4 2 3 4 5 0样例输出3 5 AC代码 #include&lt;bits/stdc++.h> #pragma GCC optimize(2) using namespace std; typedef long long ll; typedef pair&lt;int, int> pii; typedef pair&lt;ll, ll> pll; typedef map&lt;int, int> mii; typedef map&lt;ll, ll> mll; #define ull unsigned long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int maxn=1e6+10; const ll mod=1e9+7; const int INF = 0x3f3f3f3f; const double pi=acos(-1.0); int f[10000]; struct node{ int x,y,m; }a[10000]; int cmp(node a,node b){ return a.m&lt;b.m; } int find(int x){ if(f[x]==x) return x; else return f[x]=find(f[x]); } int unite(int a,int b){ int t1,t2; t1=find(a); t2=find(b); if(t1!=t2){ f[t2]=t1; return 1; } return 0; } int main(){ IOS; int n; while(cin>>n){ if(n==0) return 0; memset(f,0,sizeof(f)); int cnt,i; cnt=n*(n-1)/2; for(i=1;i&lt;=cnt;i++){ cin>>a[i].x>>a[i].y>>a[i].m; } sort(a+1,a+cnt+1,cmp); for(i=1;i&lt;=n;i++) f[i]=i; int sum=0,ans=0; for(i=1;i&lt;=cnt;i++){ if(unite(a[i].x,a[i].y)){ sum++; ans+=a[i].m; } if(sum==n-1) break; } cout&lt;&lt;ans&lt;&lt;endl; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}],"author":"小凡"},{"title":"CodeForces-1238B Kill'Em All","slug":"CF1238B","date":"2020-02-27T08:50:09.000Z","updated":"2020-02-28T14:06:13.090Z","comments":true,"path":"2020/02/27/CF1238B/","link":"","permalink":"http://yoursite.com/2020/02/27/CF1238B/","excerpt":"","text":"传送门：CodeForces - 1238B 题目描述Ivan plays an old action game called Heretic. He’s stuck on one of the final levels of this game, so he needs some help with killing the monsters. The main part of the level is a large corridor (so large and narrow that it can be represented as an infinite coordinate line). The corridor is divided into two parts; let’s assume that the point x=0 is where these parts meet. The right part of the corridor is filled with n monsters — for each monster, its initial coordinate xi is given (and since all monsters are in the right part, every xi is positive). The left part of the corridor is filled with crusher traps. If some monster enters the left part of the corridor or the origin (so, its current coordinate becomes less than or equal to 0), it gets instantly killed by a trap. The main weapon Ivan uses to kill the monsters is the Phoenix Rod. It can launch a missile that explodes upon impact, obliterating every monster caught in the explosion and throwing all other monsters away from the epicenter. Formally, suppose that Ivan launches a missile so that it explodes in the point c. Then every monster is either killed by explosion or pushed away. Let some monster’s current coordinate be y, then: if c=y, then the monster is killed;if y&lt;c, then the monster is pushed r units to the left, so its current coordinate becomes y−r;if y&gt;c, then the monster is pushed r units to the right, so its current coordinate becomes y+r. Ivan is going to kill the monsters as follows: choose some integer point d and launch a missile into that point, then wait until it explodes and all the monsters which are pushed to the left part of the corridor are killed by crusher traps, then, if at least one monster is still alive, choose another integer point (probably the one that was already used) and launch a missile there, and so on. What is the minimum number of missiles Ivan has to launch in order to kill all of the monsters? You may assume that every time Ivan fires the Phoenix Rod, he chooses the impact point optimally. You have to answer q independent queries. 输入描述The first line contains one integer $q$ $(1≤q≤10^5)$ — the number of queries. The first line of each query contains two integers $n$ and $r$ $(1≤n,r≤10^5)$ — the number of enemies and the distance that the enemies are thrown away from the epicenter of the explosion. The second line of each query contains $n$ integers $x_i$ $(1≤x_i≤10^5)$ — the initial positions of the monsters. It is guaranteed that sum of all n over all queries does not exceed $10^5$. 输出描述For each query print one integer — the minimum number of shots from the Phoenix Rod required to kill all monsters. 题意分析最小次数就应该从最后开始打，只需要从最后开始遍历，判断它能否被推死就可以了！ 样例输入2 3 2 1 3 5 4 1 5 2 3 5样例输出2 2 AC代码#include&lt;bits/stdc++.h> using namespace std; typedef long long ll; #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int a[100005]; int main() { IOS; int N; cin>>N; while(N--) { int n,r; cin>>n>>r; int i; for(i=0; i&lt;n; i++) { cin>>a[i]; } sort(a,a+n); int cnt=0; a[n]=-1; for(i=n-1; i>=0; i--) { if(a[i]==a[i+1])continue; if(a[i]-cnt*r&lt;=0)break; cnt++; } cout&lt;&lt;cnt&lt;&lt;endl; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[],"author":"小凡"},{"title":"CodeForces-1216D Swords","slug":"CF1216D","date":"2020-02-27T08:46:04.000Z","updated":"2020-02-28T14:06:17.439Z","comments":true,"path":"2020/02/27/CF1216D/","link":"","permalink":"http://yoursite.com/2020/02/27/CF1216D/","excerpt":"","text":"传送门：CodeForces - 1216D 题目描述There were n types of swords in the theater basement which had been used during the plays. Moreover there were exactly x swords of each type. y people have broken into the theater basement and each of them has taken exactly z swords of some single type. Note that different people might have taken different types of swords. Note that the values x,y and z are unknown for you. The next morning the director of the theater discovers the loss. He counts all swords — exactly ai swords of the i-th type are left untouched. The director has no clue about the initial number of swords of each type in the basement, the number of people who have broken into the basement and how many swords each of them have taken. For example, if n=3, a=[3,12,6] then one of the possible situations is x=12, y=5 and z=3. Then the first three people took swords of the first type and the other two people took swords of the third type. Note that you don’t know values x,y and z beforehand but know values of n and a. Thus he seeks for your help. Determine the minimum number of people y, which could have broken into the theater basement, and the number of swords z each of them has taken. 输入描述The first line of the input contains one integer $n$ $(2≤n≤2*10^5)$ — the number of types of swords. The second line of the input contains the sequence $a_1,a_2,…,a_n$ $(0≤a_i≤10^9)$, where ai equals to the number of swords of the i-th type, which have remained in the basement after the theft. It is guaranteed that there exists at least one such pair of indices $(j,k)$ that $a_j≠a_k$. 输出描述Print two integers y and z — the minimum number of people which could have broken into the basement and the number of swords each of them has taken. 题意分析n把剑，其中有一种剑没被偷过（就是最大值），其余都被偷过，每个人偷的数目都相同，应该就是gcd！ 样例输入3 3 12 6样例输出5 3 AC代码 #include&lt;bits/stdc++.h> using namespace std; typedef long long ll; #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); ll a[200002]; int main() { IOS; int n; cin>>n; int i; ll t=-1,sum=0; for(i=0; i&lt;n; i++) { cin>>a[i]; sum+=a[i]; t=max(t,a[i]); } ll f=0; for(i=0;i&lt;n;i++){ f=__gcd(f,t-a[i]); } ll p; p=(t*n-sum)/f; cout&lt;&lt;p&lt;&lt;\" \"&lt;&lt;f&lt;&lt;endl; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[],"author":"小凡"},{"title":"HDU-1728 逃离迷宫","slug":"HDU1728","date":"2020-02-27T08:42:44.000Z","updated":"2020-03-18T11:07:23.616Z","comments":true,"path":"2020/02/27/HDU1728/","link":"","permalink":"http://yoursite.com/2020/02/27/HDU1728/","excerpt":"","text":"传送门：HUD - 1728 题目描述给定一个m × n (m行, n列)的迷宫，迷宫中有两个位置，gloria想从迷宫的一个位置走到另外一个位置，当然迷宫中有些地方是空地，gloria可以穿越，有些地方是障碍，她必须绕行，从迷宫的一个位置，只能走到与它相邻的4个位置中,当然在行走过程中，gloria不能走到迷宫外面去。令人头痛的是，gloria是个没什么方向感的人，因此，她在行走过程中，不能转太多弯了，否则她会晕倒的。我们假定给定的两个位置都是空地，初始时，gloria所面向的方向未定，她可以选择4个方向的任何一个出发，而不算成一次转弯。gloria能从一个位置走到另外一个位置吗？ 输入描述第1行为一个整数t $(1 ≤ t ≤ 100)$,表示测试数据的个数，接下来为t组测试数据，每组测试数据中,第1行为两个整数m, n $(1 ≤ m, n ≤ 100)$,分别表示迷宫的行数和列数，接下来m行，每行包括n个字符，其中字符’.’表示该位置为空地，字符’*’表示该位置为障碍，输入数据中只有这两种字符，每组测试数据的最后一行为5个整数k, x1, y1, x2, y2 $(1 ≤ k ≤ 10, 1 ≤ x_1, x_2 ≤ n, 1 ≤ y_1, y_2 ≤ m)$,其中k表示gloria最多能转的弯数，$(x_1, y_1)$, $(x_2, y_2)$表示两个位置，其中x1，x2对应列，y1, y2对应行。 输出描述每组测试数据对应为一行，若gloria能从一个位置走到另外一个位置，输出“yes”，否则输出“no”。 题意分析常规做法会tle，必须剪枝。特别注意一下x1，x2对应列，y1, y2对应行 样例输入2 5 5 ...** *.**. ..... ..... *.... 1 1 1 1 3 5 5 ...** *.**. ..... ..... *.... 2 1 1 1 3样例输出no yes AC代码#include&lt;bits/stdc++.h> #pragma GCC optimize(2) using namespace std; typedef long long ll; typedef pair&lt;int, int> pii; typedef pair&lt;ll, ll> pll; typedef map&lt;int, int> mii; typedef map&lt;ll, ll> mll; #define ull unsigned long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int maxn=1e6+10; const ll mod=1e9+7; const int INF = 0x3f3f3f3f; int n,m,k,x1,y1,x2,y2,f; int dx[4]= {1,-1,0,0},dy[4]= {0,0,1,-1}; char a[102][102]; int turn[102][102]; void dfs(int x,int y,int t) { if(x==x2&amp;&amp;y==y2&amp;&amp;turn[x][y]&lt;=k) { f=1; return; } if(turn[x][y]>k) return; if(x!=x2&amp;&amp;y!=y2&amp;&amp;turn[x][y]==k) return; for(int i=0; i&lt;4; i++) { int nx=x+dx[i]; int ny=y+dy[i]; if(nx&lt;=0||ny&lt;=0||nx>n||ny>m||a[nx][ny]=='*') continue; if(turn[nx][ny]&lt;turn[x][y]) continue; if(t!=-1&amp;&amp;i!=t&amp;&amp;turn[nx][ny]&lt;turn[x][y]+1) continue; if(t!=-1&amp;&amp;i!=t) turn[nx][ny]=turn[x][y]+1; else turn[nx][ny]=turn[x][y]; dfs(nx,ny,i); if(f) return; } } int main() { IOS; int t; cin>>t; while(t--) { f=0; cin>>n>>m; memset(a,0,sizeof(a)); memset(turn,maxn,sizeof(turn)); for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=m; j++) { cin>>a[i][j]; } } cin>>k>>y1>>x1>>y2>>x2; turn[x1][y1]=0; dfs(x1,y1,-1); if(f)cout&lt;&lt;\"yes\"&lt;&lt;endl; else cout&lt;&lt;\"no\"&lt;&lt;endl; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}],"author":"小凡"},{"title":"HDU-2553 N皇后","slug":"HDU2553","date":"2020-02-27T08:39:52.000Z","updated":"2020-03-18T11:07:16.389Z","comments":true,"path":"2020/02/27/HDU2553/","link":"","permalink":"http://yoursite.com/2020/02/27/HDU2553/","excerpt":"","text":"传送门：HDU - 2553 题目描述在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。你的任务是，对于给定的N，求出有多少种合法的放置方法。 输入描述共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。 输出描述共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 题意分析棋盘问题，判断对角线就行了，这题直接交的话会TLE，所以得先打表。 样例输入1 8 5 0样例输出1 92 10 AC代码#include&lt;bits/stdc++.h> #pragma GCC optimize(2) using namespace std; typedef long long ll; typedef pair&lt;int, int> pii; typedef pair&lt;ll, ll> pll; typedef map&lt;int, int> mii; typedef map&lt;ll, ll> mll; #define ull unsigned long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int maxn=1e6+10; const ll mod=1e9+7; const int INF = 0x3f3f3f3f; int n,sum; int a[12][12],vis[11]; bool judge(int x,int y) { int i,j,f=0; for(i=x+1,j=y+1; i!=n,j!=n; i++,j++) { if(a[i][j]==2) { f=1; break; } } for(i=x+1,j=y-1; i!=n,j!=-1; i++,j--) { if(a[i][j]==2) { f=1; break; } } for(i=x-1,j=y-1; i!=-1,j!=-1; i--,j--) { if(a[i][j]==2) { f=1; break; } } for(i=x-1,j=y+1; i!=-1,j!=n; i--,j++) { if(a[i][j]==2) { f=1; break; } } if(f)return false; else return true; } void dfs(int x,int y) { if(y==n) { sum++; return ; } for(int i=0; i&lt;n; i++) { if(!vis[i]&amp;&amp; judge(x,i)) { a[x][i]=2; vis[i]=1; dfs(x+1,y+1); vis[i]=0; a[x][i]=0; } } } int main() { IOS; int x; for(int i=1; i&lt;=10; i++) { n=i; sum=0; memset(a,0,sizeof(a)); memset(vis,0,sizeof(vis)); dfs(0,0); cout&lt;&lt;sum&lt;&lt;endl; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}],"author":"小凡"},{"title":"CodeForces-510B Fox And Two Dots","slug":"CF510B","date":"2020-02-27T08:33:53.000Z","updated":"2020-03-18T11:07:02.701Z","comments":true,"path":"2020/02/27/CF510B/","link":"","permalink":"http://yoursite.com/2020/02/27/CF510B/","excerpt":"","text":"传送门：CodeForces - 510B 题目描述Fox Ciel is playing a mobile puzzle game called “Two Dots”. The basic levels are played on a board of size n × m cells, like this: Each cell contains a dot that has some color. We will use different uppercase Latin characters to express different colors. The key of this game is to find a cycle that contain dots of same color. Consider 4 blue dots on the picture forming a circle as an example. Formally, we call a sequence of dots $d_1$, $d_2$, …, $d_k$ a cycle if and only if it meets the following condition: These k dots are different: if i ≠ j then $d_i$ is different from $d_j$. k is at least 4. All dots belong to the same color. For all $1 ≤ i ≤ k - 1$: $d_i$ and $d_i$ + 1 are adjacent. Also, dk and d1 should also be adjacent. Cells x and y are called adjacent if they share an edge. Determine if there exists a cycle on the field. 输入描述The first line contains two integers n and m $(2 ≤ n, m ≤ 50)$: the number of rows and columns of the board. Then n lines follow, each line contains a string consisting of m characters, expressing colors of dots in each line. Each character is an uppercase Latin letter. 输出描述Output “Yes” if there exists a cycle, and “No” otherwise. 题意分析在一个n*m的矩阵中，能否用同一种字母组成一个环，从起点点开始上下左右，并且将途经所有点标记，如果最后能回到起点，说明能组成一个环，要注意一点的就是，搜索过程中下一个点不能与上一个点相同 样例输入3 4 AAAA ABCA AAAA样例输出Yes AC代码#include&lt;bits/stdc++.h> #pragma GCC optimize(2) using namespace std; typedef long long ll; typedef pair&lt;int, int> pii; typedef pair&lt;ll, ll> pll; typedef map&lt;int, int> mii; typedef map&lt;ll, ll> mll; #define ull unsigned long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int maxn=1e6+10; const ll mod=1e9+7; const int INF = 0x3f3f3f3f; int n,m; char a[55][55]; int vis[55][55]; int d1[4]= {1,-1,0,0},d2[4]= {0,0,1,-1}; int f=0; bool judge(int x,int y) { if(x&lt;0||y&lt;0||x>=n||y>=m)return false; else return true; } void dfs(int x,int y,int xx,int yy) { if(vis[x][y]) { f=1; return; } vis[x][y]=1; for(int i=0; i&lt;4; i++) { int nx,ny; nx=x+d1[i]; ny=y+d2[i]; if(judge(nx,ny) &amp;&amp; a[nx][ny]==a[x][y] &amp;&amp; (nx!=xx||ny!=yy) ) { dfs(nx,ny,x,y); } } } int main() { IOS; int i,j; cin>>n>>m; for(i=0; i&lt;n; i++) { for(j=0; j&lt;m; j++) { cin>>a[i][j]; } } for(i=0; i&lt;n; i++) { for(j=0; j&lt;m; j++) { if(!vis[i][j]) { dfs(i,j,i,j); if(f)break; } } } if(f)cout&lt;&lt;\"Yes\"&lt;&lt;endl; else cout&lt;&lt;\"No\"&lt;&lt;endl; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}],"author":"小凡"},{"title":"POJ-3984 迷宫问题","slug":"POJ3984","date":"2020-02-27T08:06:44.000Z","updated":"2020-03-18T11:07:51.064Z","comments":true,"path":"2020/02/27/POJ3984/","link":"","permalink":"http://yoursite.com/2020/02/27/POJ3984/","excerpt":"","text":"传送门：POJ - 3984 题目描述定义一个二维数组： int maze[5][5] = { 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, }; 它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。 输入描述一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。 输出描述左上角到右下角的最短路径，格式如样例所示。 题意分析bfs板子，输出的时候得注意下得回溯输出。 样例输入0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0样例输出(0, 0) (1, 0) (2, 0) (2, 1) (2, 2) (2, 3) (2, 4) (3, 4) (4, 4) AC代码#include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;cmath> #include &lt;vector> #include &lt;string> #include &lt;cstdio> #include &lt;cstring> #include &lt;cstdlib> #include &lt;iomanip> #include &lt;iostream> #include &lt;algorithm> #include &lt;functional> using namespace std; typedef long long ll; typedef pair&lt;int, int> pii; typedef pair&lt;ll, ll> pll; typedef map&lt;int, int> mii; typedef map&lt;ll, ll> mll; #define ull unsigned long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int maxn=1e6+10; const ll mod=1e9+7; const int INF = 0x3f3f3f3f; struct node{ int x,y,pre; }s,now; int dis[4][2]={{-1,0},{1,0},{0,-1},{0,1}}; int a[10][10],vis[10][10]; int ro[10][10]; queue&lt;node>q; void bfs(){ s.x=0; s.y=0; s.pre=1; vis[0][0]=1; ro[0][0]=1; q.push(s); while(!q.empty()){ node now; now=q.front(); q.pop(); if(now.x==4&amp;&amp;now.y==4){ return; } for(int i=0;i&lt;4;i++){ s=now; s.x+=dis[i][0]; s.y+=dis[i][1]; s.pre++; if(s.x&lt;0||s.x>5||s.y&lt;0||s.y>5||a[s.x][s.y]==1||vis[s.x][s.y]==1){ continue; }else { vis[s.x][s.y]=1; q.push(s); ro[s.x][s.y]=s.pre; } } } } void print(int x,int y){ if(x==0&amp;&amp;y==0)return; for(int i=0;i&lt;4;i++){ if(ro[x+dis[i][0]][y+dis[i][1]]==ro[x][y]-1){ print(x+dis[i][0],y+dis[i][1]); printf(\"(%d, %d)\\n\",x,y); } } } int main() { int i,j; for( i=0;i&lt;5;i++){ for( j=0;j&lt;5;j++){ cin>>a[i][j]; } } for(i=0;i&lt;8;i++){ for(j=0;j&lt;8;j++){ ro[i][i]=-5; } } printf(\"(0, 0)\\n\"); bfs(); print(4,4); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"http://yoursite.com/tags/BFS/"}],"author":"小凡"},{"title":"POJ-1321 棋盘问题","slug":"POJ1321","date":"2020-02-27T08:02:41.000Z","updated":"2020-03-18T11:06:49.404Z","comments":true,"path":"2020/02/27/POJ1321/","link":"","permalink":"http://yoursite.com/2020/02/27/POJ1321/","excerpt":"","text":"传送门：POJ - 1321 题目描述在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 输入描述输入含有多组测试数据。 每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n 当为-1 -1时表示输入结束。 随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 输出描述对于每一组数据，给出一行输出，输出摆放的方案数目C $(C&lt;2^31)$。 题意分析搜 样例输入2 1 #. .# 4 4 ...# ..#. .#.. #... -1 -1样例输出2 1 AC代码#include &lt;iostream> #include &lt;string> #include &lt;cstring> #include &lt;cstdio> #include &lt;map> #include &lt;set> #include &lt;queue> #include &lt;stack> #include &lt;algorithm> #include &lt;cstdlib> #include &lt;cmath> #include &lt;vector> #include &lt;iomanip> #pragma GCC optimize(2) using namespace std; typedef long long ll; typedef pair&lt;int, int> pii; typedef pair&lt;ll, ll> pll; typedef map&lt;int, int> mii; typedef map&lt;ll, ll> mll; #define ull unsigned long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int maxn=1e6+10; const ll mod=1e9+7; const int INF = 0x3f3f3f3f; char a[10][10]; int vis[20]; int n,k,sum; void dfs(int d,int ans) { if(ans==k) { sum++; return ; } if(d==n)return ; for(int i=0; i&lt;n; i++) { if(!vis[i]&amp;&amp;a[d][i]=='#') { vis[i]=1; dfs(d+1,ans+1); vis[i]=0; } } dfs(d+1,ans); } int main() { IOS; while(cin>>n>>k) { memset(a,0,sizeof(a)); memset(vis,0,sizeof(vis)); if(n==-1)break; int i,j; sum=0; for(i=0; i&lt;n; i++) { for(j=0; j&lt;n; j++) { cin>>a[i][j]; } } dfs(0,0); cout&lt;&lt;sum&lt;&lt;endl; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}],"author":"小凡"},{"title":"Openj-2748 全排列","slug":"OPJ2748","date":"2020-02-27T07:55:28.000Z","updated":"2020-03-18T11:06:36.993Z","comments":true,"path":"2020/02/27/OPJ2748/","link":"","permalink":"http://yoursite.com/2020/02/27/OPJ2748/","excerpt":"","text":"传送门：Openj - 2748 题目描述给定一个由不同的小写字母组成的字符串，输出这个字符串的所有全排列。 我们假设对于小写字母有’a’ &lt; ‘b’ &lt; … &lt; ‘y’ &lt; ‘z’，而且给定的字符串中的字母已经按照从小到大的顺序排列。 输入描述输入只有一行，是一个由不同的小写字母组成的字符串，已知字符串的长度在1到6之间。 输出描述输出这个字符串的所有排列方式，每行一个排列。要求字母序比较小的排列在前面。字母序如下定义：已知S = s 1s 2…s k , T = t 1t 2…t k，则S &lt; T 等价于，存在p (1 &lt;= p &lt;= k)，使得s 1 = t 1, s 2 = t 2, …, s p - 1 = t p - 1, s p &lt; t p成立。 题意分析搜就行了 样例输入abc样例输出abc acb bac bca cab cba AC代码#include&lt;bits/stdc++.h> #pragma GCC optimize(2) using namespace std; typedef long long ll; typedef pair&lt;int, int> pii; typedef pair&lt;ll, ll> pll; typedef map&lt;int, int> mii; typedef map&lt;ll, ll> mll; #define ull unsigned long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int maxn=1e6+10; const ll mod=1e9+7; const int INF = 0x3f3f3f3f; char a[maxn]; char s[maxn]; int vis[maxn]; int n; void dfs(int dep) { if(dep==n){ s[dep]=0; printf(\"%s\\n\",s); return ; } for(int i=0;i&lt;n;i++){ if(!vis[i]){ s[dep]=a[i]; vis[i]=1; dfs(dep+1); vis[i]=0; } } } int main() { scanf(\"%s\",a); n=strlen(a); dfs(0); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}],"author":"小凡"},{"title":"HDU-1241 Oil Deposits","slug":"HDU1241","date":"2020-02-27T07:50:59.000Z","updated":"2020-03-18T11:06:26.510Z","comments":true,"path":"2020/02/27/HDU1241/","link":"","permalink":"http://yoursite.com/2020/02/27/HDU1241/","excerpt":"","text":"传送门：HDU - 1241 题目描述The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. 输入描述The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each . Each character corresponds to one plot, and is either *, representing the absence of oil, or @’, representing an oil pocket. 输出描述For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets. 题意分析一道dfs板子题，油的四面八方为同一个，所以找到一个它四面八方全部标记并往下继续搜索 样例输入1 1 * 3 5 *@*@* **@** *@*@* 1 8 @@****@* 5 5 ****@ *@@*@ *@**@ @@@*@ @@**@ 0 0 样例输出0 1 2 2 AC代码#include&lt;bits/stdc++.h> #pragma GCC optimize(2) using namespace std; typedef long long ll; typedef pair&lt;int, int> pii; typedef pair&lt;ll, ll> pll; typedef map&lt;int, int> mii; typedef map&lt;ll, ll> mll; #define ull unsigned long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int maxn=1e6+10; const ll mod=1e9+7; const int INF = 0x3f3f3f3f; int n,m,i,j; char a[200][200]; void dfs(int x,int y) { if(x>=n||y>=m||x&lt;0||y&lt;0||a[x][y]=='*')return ; a[x][y]='*'; dfs(x-1,y-1); dfs(x,y-1); dfs(x+1,y-1); dfs(x-1,y); dfs(x+1,y); dfs(x-1,y+1); dfs(x,y+1); dfs(x+1,y+1); } int main() { IOS; while(cin>>n>>m) { if(n==0)return 0; memset(a,0,sizeof(a)); for(i=0; i&lt;n; i++) { for(j=0; j&lt;m; j++) { cin>>a[i][j]; } } int sum=0; for(i=0; i&lt;n; i++) { for(j=0; j&lt;m; j++) { if(a[i][j]=='@') { sum++; dfs(i,j); } } } cout&lt;&lt;sum&lt;&lt;endl; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}],"author":"小凡"},{"title":"CodeForces-455A Boredom（线性DP）","slug":"CF455A","date":"2020-02-27T07:37:45.000Z","updated":"2020-02-28T14:05:51.267Z","comments":true,"path":"2020/02/27/CF455A/","link":"","permalink":"http://yoursite.com/2020/02/27/CF455A/","excerpt":"","text":"传送门：CodeForces - 455A 题目描述Alex doesn’t like boredom. That’s why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it. Given a sequence a consisting of n integers. The player can make several steps. In a single step he can choose an element of the sequence （let’s denote it ak） and delete it, at that all elements equal to ak + 1 and ak - 1 also must be deleted from the sequence. That step brings ak points to the player. Alex is a perfectionist, so he decided to get as many points as possible. Help him. 输入描述The first line contains integer n $(1 ≤ n ≤ 10^5)$ that shows how many numbers are in Alex’s sequence. The second line contains n integers $a_1, a_2, …, a_n$ $(1 ≤ a_i ≤ 10^5)$. 输出描述Print a single integer — the maximum number of points that Alex can earn. 题意分析没有 样例输入2 1 2样例输出2 AC代码#include&lt;bits/stdc++.h> #pragma GCC optimize(2) using namespace std; typedef long long ll; typedef pair&lt;int, int> pii; typedef pair&lt;ll, ll> pll; #define ull unsigned long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int maxn=1e6+10; const ll mod=1e9+7; ll a[maxn],dp[maxn]; int main() { IOS; ll n,i,t=-1; cin>>n; for(i=0;i&lt;n;i++){ ll x; cin>>x; a[x]++; t=max(t,x); } ll ma; dp[1]=a[1]; for(i=2;i&lt;=t;i++){ dp[i]=max(dp[i-1],dp[i-2]+a[i]*i); } cout&lt;&lt;dp[t]&lt;&lt;endl; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线性DP","slug":"线性DP","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7DP/"}],"author":"小凡"},{"title":"CodeForces-1249E By Elevator or Stairs?（线性DP）","slug":"CF1249E","date":"2019-10-31T11:43:14.000Z","updated":"2020-02-28T14:06:06.200Z","comments":true,"path":"2019/10/31/CF1249E/","link":"","permalink":"http://yoursite.com/2019/10/31/CF1249E/","excerpt":"","text":"传送门：CodeForces - 1249E 题目描述You are planning to buy an apartment in a n-floor building. The floors are numbered from 1 to n from the bottom to the top. At first for each floor you want to know the minimum total time to reach it from the first （the bottom） floor. Let: ai for all i from 1 to n−1 be the time required to go from the i-th floor to the (i+1)-th one （and from the (i+1)-th to the i-th as well） using the stairs bi for all i from 1 to n−1 be the time required to go from the i-th floor to the (i+1)-th one （and from the (i+1)-th to the i-th as well） using the elevator, also there is a value c — time overhead for elevator usage （you need to wait for it, the elevator doors are too slow!） In one move, you can go from the floor you are staying at x to any floor y (x≠y) in two different ways: If you are using the stairs, just sum up the corresponding values of ai. Formally, it will take $∑i=min(x,y)max(x,y)$−1ai time units. If you are using the elevator, just sum up c and the corresponding values of bi. Formally, it will take $c+∑i=min(x,y)max(x,y)$−1bi time units. You can perform as many moves as you want （possibly zero）. So your task is for each i to determine the minimum total time it takes to reach the i-th floor from the 1-st (bottom) floor. 输入描述The first line of the input contains two integers n and c $(2≤n≤2⋅10^5,1≤c≤1000)$ — the number of floors in the building and the time overhead for the elevator rides. The second line of the input contains n−1 integers $a_1,a_2,…,a_{n−1}$ $(1≤a_i≤1000)$, where ai is the time required to go from the i-th floor to the (i+1)-th one （and from the (i+1)-th to the i-th as well） using the stairs. The third line of the input contains n−1 integers $b_1,b_2,…,b_{n−1}$ $(1≤b_i≤1000)$, where bi is the time required to go from the i-th floor to the (i+1)-th one （and from the (i+1)-th to the i-th as well） using the elevator. 输出描述Print n integers t1,t2,…,tn, where ti is the minimum total time to reach the i-th floor from the first floor if you can perform as many moves as you want. 题意分析选择坐电梯或者楼梯，坐电梯前需等待c，求最短时间 样例输入10 2 7 6 18 6 16 18 1 17 17 6 9 3 10 9 1 10 1 5样例输出0 7 13 18 24 35 36 37 40 45 AC代码#include&lt;bits/stdc++.h> #pragma GCC optimize(2) using namespace std; typedef long long ll; typedef pair&lt;int, int> pii; typedef pair&lt;ll, ll> pll; #define ull unsigned long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int maxn=1e6+10; const ll mod=1e9+7; int a[maxn],b[maxn],dp[maxn][5]; int main() { IOS; int n,k,i; cin>>n>>k; for(i=1; i&lt;n; i++)cin>>a[i]; for(i=1; i&lt;n; i++)cin>>b[i]; cout&lt;&lt;0&lt;&lt;\" \"; dp[0][0]=a[0]; dp[0][1]=b[0]+k; for(i=1; i&lt;n; i++) { dp[i][0]=min(dp[i-1][0]+a[i],dp[i-1][1]+a[i]); dp[i][1]=min(dp[i-1][1]+b[i],dp[i-1][0]+b[i]+k); cout&lt;&lt;min(dp[i][0],dp[i][1]); if(i==n-1)cout&lt;&lt;endl; else cout&lt;&lt;\" \"; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线性DP","slug":"线性DP","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7DP/"}],"author":"小凡"},{"title":"CodeForces-1195C Basketball Exercise（线性DP）","slug":"CF1195C","date":"2019-10-30T11:43:14.000Z","updated":"2020-02-28T14:06:21.675Z","comments":true,"path":"2019/10/30/CF1195C/","link":"","permalink":"http://yoursite.com/2019/10/30/CF1195C/","excerpt":"传送门：CodeForces - 1195C 题目描述Finally, a basketball court has been opened in SIS, so Demid has decided to hold a basketball exercise session. 2⋅n students have come to Demid’s exercise session, and he lined up them into two rows of the same size （there are exactly n people in each row）. Students are numbered from 1 to n in each row in order from left to right. Now Demid wants to choose a team to play basketball. He will choose players from left to right, and the index of each chosen player （excluding the first one taken） will be strictly greater than the index of the previously chosen player. To avoid giving preference to one of the rows, Demid chooses students in such a way that no consecutive chosen students belong to the same row. The first student can be chosen among all 2n students （there are no additional constraints）, and a team can consist of any number of students. Demid thinks, that in order to compose a perfect team, he should choose students in such a way, that the total height of all chosen students is maximum possible. Help Demid to find the maximum possible total height of players in a team he can choose.","text":"传送门：CodeForces - 1195C 题目描述Finally, a basketball court has been opened in SIS, so Demid has decided to hold a basketball exercise session. 2⋅n students have come to Demid’s exercise session, and he lined up them into two rows of the same size （there are exactly n people in each row）. Students are numbered from 1 to n in each row in order from left to right. Now Demid wants to choose a team to play basketball. He will choose players from left to right, and the index of each chosen player （excluding the first one taken） will be strictly greater than the index of the previously chosen player. To avoid giving preference to one of the rows, Demid chooses students in such a way that no consecutive chosen students belong to the same row. The first student can be chosen among all 2n students （there are no additional constraints）, and a team can consist of any number of students. Demid thinks, that in order to compose a perfect team, he should choose students in such a way, that the total height of all chosen students is maximum possible. Help Demid to find the maximum possible total height of players in a team he can choose. 输入描述The first line of the input contains a single integer $n$ $(1≤n≤10^5)$ — the number of students in each row. The second line of the input contains n integers h1,1,h1,2,…,h1,n $(1≤h1,i≤10^9)$, where h1,i is the height of the i-th student in the first row. The third line of the input contains n integers h2,1,h2,2,…,h2,n $(1≤h2,i≤10^9)$, where h2,i is the height of the i-th student in the second row. 输出描述Print a single integer — the maximum possible total height of players in a team Demid can choose. 题意分析给定两个序列a和b,可以选任意的数,但要满足以下规则：连续选择的两个数不能来自同一行同一列，求和最大值。 样例输入5 9 3 5 7 3 5 8 1 4 5样例输出29 AC代码#include&lt;bits/stdc++.h> #pragma GCC optimize(2) using namespace std; typedef long long ll; typedef pair&lt;int, int> pii; typedef pair&lt;ll, ll> pll; #define ull unsigned long long #define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); const int maxn=1e6+10; const ll mod=1e9+7; ll a[maxn],b[maxn],dp[maxn][3]; int main() { IOS; ll n,i; cin>>n; for(i=1; i&lt;=n; i++)cin>>a[i]; for(i=1; i&lt;=n; i++)cin>>b[i]; for(i=1;i&lt;=n;i++){ dp[i][0]=max(dp[i-1][0],dp[i-1][1]+a[i]); dp[i][1]=max(dp[i-1][1],dp[i-1][0]+b[i]); } cout&lt;&lt;max(dp[n][0],dp[n][1])&lt;&lt;endl; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"线性DP","slug":"线性DP","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7DP/"}],"author":"小凡"},{"title":"CodeForces-1247B2 TV Subscriptions （Hard Version）","slug":"CF1247B2","date":"2019-10-30T11:43:14.000Z","updated":"2020-02-28T14:06:10.031Z","comments":true,"path":"2019/10/30/CF1247B2/","link":"","permalink":"http://yoursite.com/2019/10/30/CF1247B2/","excerpt":"传送门：CodeForces - 1247B2 题目描述The only difference between easy and hard versions is constraints. The BerTV channel every day broadcasts one episode of one of the k TV shows. You know the schedule for the next n days: a sequence of integers a1,a2,…,an $(1≤a_i≤k)$, where ai is the show, the episode of which will be shown in i-th day. The subscription to the show is bought for the entire show (i.e. for all its episodes), for each show the subscription is bought separately. How many minimum subscriptions do you need to buy in order to have the opportunity to watch episodes of purchased shows d (1≤d≤n) days in a row? In other words, you want to buy the minimum number of TV shows so that there is some segment of d consecutive days in which all episodes belong to the purchased shows.","text":"传送门：CodeForces - 1247B2 题目描述The only difference between easy and hard versions is constraints. The BerTV channel every day broadcasts one episode of one of the k TV shows. You know the schedule for the next n days: a sequence of integers a1,a2,…,an $(1≤a_i≤k)$, where ai is the show, the episode of which will be shown in i-th day. The subscription to the show is bought for the entire show (i.e. for all its episodes), for each show the subscription is bought separately. How many minimum subscriptions do you need to buy in order to have the opportunity to watch episodes of purchased shows d (1≤d≤n) days in a row? In other words, you want to buy the minimum number of TV shows so that there is some segment of d consecutive days in which all episodes belong to the purchased shows. 输入描述The first line contains an integer t $(1≤t≤10000)$ — the number of test cases in the input. Then t test case descriptions follow. The first line of each test case contains three integers n,k and d $(1≤n≤2⋅10^5$, $1≤k≤10^6$, $1≤d≤n)$. The second line contains n integers $a_1$,$a_2$,…,$a_n$ $(1≤a_i≤k)$, where ai is the show that is broadcasted on the i-th day. It is guaranteed that the sum of the values ​​of n for all test cases in the input does not exceed $2⋅10^5$. 输出描述Print t integers — the answers to the test cases in the input in the order they follow. The answer to a test case is the minimum number of TV shows for which you need to purchase a subscription so that you can watch episodes of the purchased TV shows on BerTV for d consecutive days. Please note that it is permissible that you will be able to watch more than d days in a row. 题意分析求长度为D的区间内的最小元素种类数 样例输入4 5 2 2 1 2 1 2 1 9 3 3 3 3 3 2 2 2 1 1 1 4 10 4 10 8 6 4 16 9 8 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 样例输出2 1 4 5 AC代码#include&lt;bits/stdc++.h> using namespace std; typedef long long ll; const int maxn=1e6+10; const ll mod=1e9+7; mii p; int a[maxn]; int main() { int t,i; cin>>t; while(t--) { p.clear(); int n,k,d,f,ma=1000000; cin>>n>>k>>d; int cnt=d; int sum=n-d+1; for(i=1; i&lt;=n; i++) { cin>>a[i]; p[a[i]]++; if(i>=d) { int x=p.size(); ma=min(ma,x); if(p[a[i-d+1]]>1)p[a[i-d+1]]--; else p.erase(p.find(a[i-d+1])); } } cout&lt;&lt;ma&lt;&lt;endl; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[],"author":"小凡"}],"categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"序列自动机","slug":"序列自动机","permalink":"http://yoursite.com/tags/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"费用流","slug":"费用流","permalink":"http://yoursite.com/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"},{"name":"kmp","slug":"kmp","permalink":"http://yoursite.com/tags/kmp/"},{"name":"背包DP","slug":"背包DP","permalink":"http://yoursite.com/tags/%E8%83%8C%E5%8C%85DP/"},{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"},{"name":"数位DP","slug":"数位DP","permalink":"http://yoursite.com/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"分块","slug":"分块","permalink":"http://yoursite.com/tags/%E5%88%86%E5%9D%97/"},{"name":"bitset","slug":"bitset","permalink":"http://yoursite.com/tags/bitset/"},{"name":"单调队列","slug":"单调队列","permalink":"http://yoursite.com/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"},{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"二分图","slug":"二分图","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"点分治","slug":"点分治","permalink":"http://yoursite.com/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"势能线段树","slug":"势能线段树","permalink":"http://yoursite.com/tags/%E5%8A%BF%E8%83%BD%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树套树","slug":"树套树","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%A5%97%E6%A0%91/"},{"name":"CDQ分治","slug":"CDQ分治","permalink":"http://yoursite.com/tags/CDQ%E5%88%86%E6%B2%BB/"},{"name":"树上启发式合并","slug":"树上启发式合并","permalink":"http://yoursite.com/tags/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"},{"name":"线段树合并","slug":"线段树合并","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"},{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"},{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://yoursite.com/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"主席树","slug":"主席树","permalink":"http://yoursite.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"BFS","slug":"BFS","permalink":"http://yoursite.com/tags/BFS/"},{"name":"LCA","slug":"LCA","permalink":"http://yoursite.com/tags/LCA/"},{"name":"计数DP","slug":"计数DP","permalink":"http://yoursite.com/tags/%E8%AE%A1%E6%95%B0DP/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://yoursite.com/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"区间DP","slug":"区间DP","permalink":"http://yoursite.com/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"Tarjan","slug":"Tarjan","permalink":"http://yoursite.com/tags/Tarjan/"},{"name":"博弈","slug":"博弈","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%BC%88/"},{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"倍增","slug":"倍增","permalink":"http://yoursite.com/tags/%E5%80%8D%E5%A2%9E/"},{"name":"manacher","slug":"manacher","permalink":"http://yoursite.com/tags/manacher/"},{"name":"随机化","slug":"随机化","permalink":"http://yoursite.com/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"},{"name":"三分","slug":"三分","permalink":"http://yoursite.com/tags/%E4%B8%89%E5%88%86/"},{"name":"交互","slug":"交互","permalink":"http://yoursite.com/tags/%E4%BA%A4%E4%BA%92/"},{"name":"状压DP","slug":"状压DP","permalink":"http://yoursite.com/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"平衡树","slug":"平衡树","permalink":"http://yoursite.com/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"莫队","slug":"莫队","permalink":"http://yoursite.com/tags/%E8%8E%AB%E9%98%9F/"},{"name":"单调栈","slug":"单调栈","permalink":"http://yoursite.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"A-star","slug":"A-star","permalink":"http://yoursite.com/tags/A-star/"},{"name":"最大权闭合图","slug":"最大权闭合图","permalink":"http://yoursite.com/tags/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%9B%BE/"},{"name":"线性DP","slug":"线性DP","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7DP/"},{"name":"分治","slug":"分治","permalink":"http://yoursite.com/tags/%E5%88%86%E6%B2%BB/"},{"name":"概率DP","slug":"概率DP","permalink":"http://yoursite.com/tags/%E6%A6%82%E7%8E%87DP/"}]}